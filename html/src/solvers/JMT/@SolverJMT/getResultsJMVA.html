<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getResultsJMVA</title>
  <meta name="keywords" content="getResultsJMVA">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../../index.html">solvers</a> &gt; <a href="../index.html">JMT</a> &gt; <a href="index.html">@SolverJMT</a> &gt; getResultsJMVA.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\JMT\@SolverJMT&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>getResultsJMVA
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>function [result, parsed] = getResultsJMVA(self) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="SolverJMT.html" class="code" title="">SolverJMT</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [result, parsed] = getResultsJMVA(self)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 <span class="keyword">try</span>
0006     fileName = strcat(self.getFilePath(),<span class="string">'jmva'</span>,filesep,self.getFileName(),<span class="string">'.jmva-result.jmva'</span>);
0007     <span class="keyword">if</span> exist(fileName,<span class="string">'file'</span>)
0008         Pref.Str2Num = <span class="string">'always'</span>;
0009         parsed = xml_read(fileName,Pref);
0010     <span class="keyword">else</span>
0011         error(<span class="string">'JMT did not output a result file, the analysis has likely failed.'</span>);
0012     <span class="keyword">end</span>
0013 <span class="keyword">catch</span> me    
0014     error(<span class="string">'Unknown error upon parsing JMT result file. '</span>);
0015 <span class="keyword">end</span>
0016 self.result.(<span class="string">'solver'</span>) = self.getName();
0017 self.result.(<span class="string">'model'</span>) = parsed.ATTRIBUTE;
0018 self.result.(<span class="string">'metric'</span>) = {};
0019 self.result.(<span class="string">'Prob'</span>) = struct();
0020 <span class="keyword">try</span>
0021     <span class="comment">% older JMVA versions do not have the logValue field and will throw an</span>
0022     <span class="comment">% exception</span>
0023     <span class="keyword">switch</span> class(parsed.solutions.algorithm.normconst.ATTRIBUTE.logValue)
0024         <span class="keyword">case</span> <span class="string">'double'</span>
0025             self.result.Prob.logNormConst = parsed.solutions.algorithm.normconst.ATTRIBUTE.logValue;
0026         <span class="keyword">otherwise</span>
0027             self.result.Prob.logNormConst = NaN;
0028     <span class="keyword">end</span>
0029 <span class="keyword">catch</span>
0030     self.result.Prob.logNormConst = NaN;
0031 <span class="keyword">end</span>
0032 
0033 qn = self.model.getStruct;
0034 <span class="comment">%%%</span>
0035 M = qn.nstations;    <span class="comment">%number of stations</span>
0036 S = qn.nservers;
0037 NK = qn.njobs';  <span class="comment">% initial population per class</span>
0038 C = qn.nchains;
0039 SCV = qn.scv;
0040 
0041 <span class="comment">% determine service times</span>
0042 ST = 1./qn.rates;
0043 ST(isnan(qn.rates))=0;
0044 SCV(isnan(SCV))=1;
0045 
0046 alpha = zeros(qn.nstations,qn.nclasses);
0047 Vchain = zeros(qn.nstations,qn.nchains);
0048 <span class="keyword">for</span> c=1:qn.nchains
0049     inchain = find(qn.chains(c,:));
0050     <span class="keyword">for</span> i=1:qn.nstations
0051         Vchain(i,c) = sum(qn.visits{c}(i,inchain)) / sum(qn.visits{c}(qn.refstat(inchain(1)),inchain));
0052         <span class="keyword">for</span> k=inchain
0053             alpha(i,k) = alpha(i,k) + qn.visits{c}(i,k) / sum(qn.visits{c}(i,inchain));
0054         <span class="keyword">end</span>
0055     <span class="keyword">end</span>
0056 <span class="keyword">end</span>
0057 Vchain(~isfinite(Vchain))=0;
0058 alpha(~isfinite(alpha))=0;
0059 alpha(alpha&lt;1e-12)=0;
0060 
0061 STchain = zeros(M,C);
0062 
0063 SCVchain = zeros(M,C);
0064 Nchain = zeros(1,C);
0065 refstatchain = zeros(C,1);
0066 <span class="keyword">for</span> c=1:qn.nchains
0067     inchain = find(qn.chains(c,:));
0068     isOpenChain = any(isinf(qn.njobs(inchain)));
0069     <span class="keyword">for</span> i=1:qn.nstations
0070         <span class="comment">% we assume that the visits in L(i,inchain) are equal to 1</span>
0071         STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0072         <span class="keyword">if</span> isOpenChain &amp;&amp; i == qn.refstat(inchain(1)) <span class="comment">% if this is a source ST = 1 / arrival rates</span>
0073             STchain(i,c) = 1 / sumfinite(qn.rates(i,inchain)); <span class="comment">% ignore degenerate classes with zero arrival rates</span>
0074         <span class="keyword">else</span>
0075             STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0076         <span class="keyword">end</span>
0077         SCVchain(i,c) = SCV(i,inchain) * alpha(i,inchain)';
0078     <span class="keyword">end</span>
0079     Nchain(c) = sum(NK(inchain));
0080     refstatchain(c) = qn.refstat(inchain(1));
0081     <span class="keyword">if</span> any((qn.refstat(inchain(1))-refstatchain(c))~=0)
0082         error(sprintf(<span class="string">'Classes in chain %d have different reference station.'</span>,c));
0083     <span class="keyword">end</span>
0084 <span class="keyword">end</span>
0085 STchain(~isfinite(STchain))=0;
0086 <span class="comment">%%%</span>
0087 statres = parsed.solutions.algorithm.stationresults;
0088 
0089 <span class="keyword">for</span> k=1:qn.nclasses
0090     <span class="keyword">for</span> i=1:qn.nstations
0091         <span class="keyword">switch</span> qn.nodetype(self.getStruct.stationToNode(i))
0092             <span class="keyword">case</span> NodeType.Source
0093                 s = struct();
0094                 s.(<span class="string">'alfa'</span>) = NaN;
0095                 s.(<span class="string">'analyzedSamples'</span>) = Inf;
0096                 s.(<span class="string">'class'</span>) = qn.classnames{k};
0097                 s.(<span class="string">'discardedSamples'</span>) = 0;
0098                 s.(<span class="string">'lowerLimit'</span>) = qn.rates(i,k);
0099                 s.(<span class="string">'maxSamples'</span>) = Inf;
0100                 s.(<span class="string">'meanValue'</span>) = qn.rates(i,k);
0101                 s.(<span class="string">'measureType'</span>) = Metric.Tput;
0102                 s.(<span class="string">'nodeType'</span>) = <span class="string">'station'</span>;
0103                 s.(<span class="string">'precision'</span>) = Inf;
0104                 s.(<span class="string">'station'</span>) = qn.nodenames{self.getStruct.stationToNode(i)};
0105                 s.(<span class="string">'successful'</span>) = <span class="string">'true'</span>;
0106                 s.(<span class="string">'upperLimit'</span>) = qn.rates(i,k);
0107                 self.result.metric{end+1} = s;
0108                 
0109                 s = struct();
0110                 s.(<span class="string">'alfa'</span>) = NaN;
0111                 s.(<span class="string">'analyzedSamples'</span>) = Inf;
0112                 s.(<span class="string">'class'</span>) = qn.classnames{k};
0113                 s.(<span class="string">'discardedSamples'</span>) = 0;
0114                 s.(<span class="string">'lowerLimit'</span>) = 0;
0115                 s.(<span class="string">'maxSamples'</span>) = Inf;
0116                 s.(<span class="string">'meanValue'</span>) = 0;
0117                 s.(<span class="string">'measureType'</span>) = Metric.QLen;
0118                 s.(<span class="string">'nodeType'</span>) = <span class="string">'station'</span>;
0119                 s.(<span class="string">'precision'</span>) = Inf;
0120                 s.(<span class="string">'station'</span>) = qn.nodenames{self.getStruct.stationToNode(i)};
0121                 s.(<span class="string">'successful'</span>) = <span class="string">'true'</span>;
0122                 s.(<span class="string">'upperLimit'</span>) = 0;
0123                 self.result.metric{end+1} = s;
0124                 
0125                 s = struct();
0126                 s.(<span class="string">'alfa'</span>) = NaN;
0127                 s.(<span class="string">'analyzedSamples'</span>) = Inf;
0128                 s.(<span class="string">'class'</span>) = qn.classnames{k};
0129                 s.(<span class="string">'discardedSamples'</span>) = 0;
0130                 s.(<span class="string">'lowerLimit'</span>) = 0;
0131                 s.(<span class="string">'maxSamples'</span>) = Inf;
0132                 s.(<span class="string">'meanValue'</span>) = 0;
0133                 s.(<span class="string">'measureType'</span>) = Metric.RespT;
0134                 s.(<span class="string">'nodeType'</span>) = <span class="string">'station'</span>;
0135                 s.(<span class="string">'precision'</span>) = Inf;
0136                 s.(<span class="string">'station'</span>) = qn.nodenames{self.getStruct.stationToNode(i)};
0137                 s.(<span class="string">'successful'</span>) = <span class="string">'true'</span>;
0138                 s.(<span class="string">'upperLimit'</span>) = 0;
0139                 self.result.metric{end+1} = s;
0140                 
0141                 s = struct();
0142                 s.(<span class="string">'alfa'</span>) = NaN;
0143                 s.(<span class="string">'analyzedSamples'</span>) = Inf;
0144                 s.(<span class="string">'class'</span>) = qn.classnames{k};
0145                 s.(<span class="string">'discardedSamples'</span>) = 0;
0146                 s.(<span class="string">'lowerLimit'</span>) = 0;
0147                 s.(<span class="string">'maxSamples'</span>) = Inf;
0148                 s.(<span class="string">'meanValue'</span>) = 0;
0149                 s.(<span class="string">'measureType'</span>) = Metric.Util;
0150                 s.(<span class="string">'nodeType'</span>) = <span class="string">'station'</span>;
0151                 s.(<span class="string">'precision'</span>) = Inf;
0152                 s.(<span class="string">'station'</span>) = qn.nodenames{self.getStruct.stationToNode(i)};
0153                 s.(<span class="string">'successful'</span>) = <span class="string">'true'</span>;
0154                 s.(<span class="string">'upperLimit'</span>) = 0;
0155                 self.result.metric{end+1} = s;
0156         <span class="keyword">end</span>
0157     <span class="keyword">end</span>
0158 <span class="keyword">end</span>
0159 
0160 <span class="comment">%%</span>
0161 <span class="comment">%Rchain</span>
0162 <span class="comment">%Xchain</span>
0163 <span class="comment">%Tchain</span>
0164 <span class="comment">% for c=1:qn.nchains</span>
0165 <span class="comment">%     inchain = find(qn.chains(c,:));</span>
0166 <span class="comment">%     for k=inchain(:)'</span>
0167 <span class="comment">%         X(k) = Xchain(c) * alpha(qn.refstat(k),k);</span>
0168 <span class="comment">%         for i=1:qn.nstations</span>
0169 <span class="comment">%             if isinf(S(i))</span>
0170 <span class="comment">%                 U(i,k) = ST(i,k) * (Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c)) * alpha(i,k);</span>
0171 <span class="comment">%             else</span>
0172 <span class="comment">%                 U(i,k) = ST(i,k) * (Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c)) * alpha(i,k) / S(i);</span>
0173 <span class="comment">%             end</span>
0174 <span class="comment">%             if Lchain(i,c) &gt; 0</span>
0175 <span class="comment">%                 Q(i,k) = Rchain(i,c) * ST(i,k) / STchain(i,c) * Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);</span>
0176 <span class="comment">%                 T(i,k) = Tchain(i,c) * alpha(i,k);</span>
0177 <span class="comment">%                 R(i,k) = Q(i,k) / T(i,k);</span>
0178 <span class="comment">%             else</span>
0179 <span class="comment">%                 T(i,k) = 0;</span>
0180 <span class="comment">%                 R(i,k)=0;</span>
0181 <span class="comment">%                 Q(i,k)=0;</span>
0182 <span class="comment">%             end</span>
0183 <span class="comment">%         end</span>
0184 <span class="comment">%         C(k) = qn.njobs(k) / X(k);</span>
0185 <span class="comment">%     end</span>
0186 <span class="comment">% end</span>
0187 <span class="comment">% Q=abs(Q); R=abs(R); X=abs(X); U=abs(U); T=abs(T); C=abs(C);</span>
0188 <span class="comment">% T(~isfinite(T))=0; U(~isfinite(U))=0; Q(~isfinite(Q))=0; R(~isfinite(R))=0; X(~isfinite(X))=0; C(~isfinite(C))=0;</span>
0189 <span class="comment">%%</span>
0190 
0191 <span class="keyword">for</span> i=1:length(statres)
0192     classres = statres(i).classresults;
0193     <span class="keyword">for</span> c=1:length(classres)
0194         inchain = find(qn.chains(c,:));
0195         <span class="keyword">for</span> m=1:length(classres(c).measure)
0196             <span class="keyword">for</span> k=inchain(:)'
0197                 s = struct();
0198                 s.(<span class="string">'alfa'</span>) = NaN;
0199                 s.(<span class="string">'analyzedSamples'</span>) = Inf;
0200                 s.(<span class="string">'class'</span>) = qn.classnames{k};
0201                 s.(<span class="string">'discardedSamples'</span>) = 0;
0202                 s.(<span class="string">'meanValue'</span>) = classres(c).measure(m).ATTRIBUTE.meanValue;
0203                 s.(<span class="string">'maxSamples'</span>) = Inf;
0204                 s.(<span class="string">'measureType'</span>) = classres(c).measure(m).ATTRIBUTE.measureType;
0205                 <span class="keyword">switch</span> classres(c).measure(m).ATTRIBUTE.measureType
0206                     <span class="keyword">case</span> <span class="string">'Utilization'</span>
0207                         <span class="keyword">if</span> isinf(qn.nservers(i))
0208                             s.meanValue = ST(i,k) * (s.meanValue / STchain(i,c)) * Vchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);
0209                         <span class="keyword">else</span>
0210                             s.meanValue = ST(i,k) * (s.meanValue / STchain(i,c)) / Vchain(qn.refstat(k),c) * alpha(i,k);<span class="comment">% / qn.nservers(i);</span>
0211                         <span class="keyword">end</span>
0212                         s.(<span class="string">'measureType'</span>) = classres(c).measure(m).ATTRIBUTE.measureType;
0213                     <span class="keyword">case</span> <span class="string">'Throughput'</span>
0214                         s.meanValue = s.meanValue * alpha(i,k);
0215                     <span class="keyword">case</span> <span class="string">'Number of Customers'</span>
0216                         <span class="comment">% Q(i,k) = Rchain(i,c) * ST(i,k) / STchain(i,c) * Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);</span>
0217                         s.meanValue = s.meanValue * ST(i,k) / STchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);                       
0218                     <span class="keyword">case</span> <span class="string">'Residence time'</span>
0219                         s.(<span class="string">'measureType'</span>) = <span class="string">'Response Time'</span>;                        
0220                         s.meanValue = s.meanValue / qn.visits{c}(i,k); <span class="comment">% this is to convert from JMVA's residence into LINE's response time per visit</span>
0221                         <span class="keyword">if</span> isinf(qn.nservers(i))                        
0222                             s.meanValue = s.meanValue * ST(i,k) / STchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);
0223                         <span class="keyword">else</span>                            
0224                             s.meanValue = s.meanValue * ST(i,k) / STchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);
0225                         <span class="keyword">end</span>
0226                     <span class="keyword">otherwise</span>
0227                         s.(<span class="string">'measureType'</span>) = classres(c).measure(m).ATTRIBUTE.measureType;
0228                 <span class="keyword">end</span>
0229                 s.(<span class="string">'lowerLimit'</span>) = s.meanValue;
0230                 s.(<span class="string">'upperLimit'</span>) = s.meanValue;
0231                 s.(<span class="string">'nodeType'</span>) = <span class="string">'station'</span>;
0232                 s.(<span class="string">'precision'</span>) = Inf;
0233                 s.(<span class="string">'station'</span>) = statres(i).ATTRIBUTE.station;
0234                 s.(<span class="string">'successful'</span>) = classres(c).measure(m).ATTRIBUTE.successful;                
0235                 self.result.metric{end+1} = s;
0236             <span class="keyword">end</span>
0237         <span class="keyword">end</span>
0238     <span class="keyword">end</span>
0239 <span class="keyword">end</span>
0240 result = self.result;
0241 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>