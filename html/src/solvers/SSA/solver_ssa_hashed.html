<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_ssa_hashed</title>
  <meta name="keywords" content="solver_ssa_hashed">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">SSA</a> &gt; solver_ssa_hashed.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\SSA&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_ssa_hashed
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [pi,SSq,arvRates,depRates]=solver_ssa_hashed(qn,options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="solver_ssa_analysis.html" class="code" title="function [QN,UN,RN,TN,CN,XN,runtime] = solver_ssa_analysis(qn, options)">solver_ssa_analysis</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="solver_ssa_analysis_spmd.html" class="code" title="function [XN,UN,QN,RN,TN,CN]=solver_ssa_analysis_spmd(laboptions, qn, qnc, PH)">solver_ssa_analysis_spmd</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [pi,SSq,arvRates,depRates]=solver_ssa_hashed(qn,options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 <span class="comment">% by default the jobs are all initialized in the first valid state</span>
0006 <span class="comment">%% generate local state spaces</span>
0007 nstations = qn.nstations;
0008 nstateful = qn.nstateful;
0009 <span class="comment">%init_nserver = qn.nservers; % restore Inf at delay nodes</span>
0010 R = qn.nclasses;
0011 N = qn.njobs';
0012 sync = qn.sync;
0013 csmask = qn.csmask;
0014 
0015 cutoff = options.cutoff;
0016 <span class="keyword">if</span> prod(size(cutoff))==1
0017     cutoff = cutoff * ones(qn.nstations, qn.nclasses);
0018 <span class="keyword">end</span>
0019 
0020 <span class="comment">%%</span>
0021 Np = N';
0022 capacityc = zeros(qn.nnodes, qn.nclasses);
0023 <span class="keyword">for</span> ind=1:qn.nnodes
0024     <span class="keyword">if</span> qn.isstation(ind) <span class="comment">% place jobs across stations</span>
0025         ist = qn.nodeToStation(ind);
0026         isf = qn.nodeToStateful(ind);
0027         <span class="keyword">for</span> r=1:qn.nclasses <span class="comment">%cut-off open classes to finite capacity</span>
0028             c = find(qn.chains(:,r));
0029             <span class="keyword">if</span> ~isempty(qn.visits{c}) &amp;&amp; qn.visits{c}(ist,r) == 0
0030                 capacityc(ind,r) = 0;
0031             <span class="keyword">elseif</span> any(isnan(qn.mu{ist,r})) <span class="comment">% disabled</span>
0032                 capacityc(ind,r) = 0;
0033             <span class="keyword">else</span>
0034                 <span class="keyword">if</span> isinf(N(r))
0035                     capacityc(ind,r) =  min(cutoff(ist,r), qn.classcap(ist,r));
0036                 <span class="keyword">else</span>
0037                     capacityc(ind,r) =  sum(qn.njobs(qn.chains(c,:)));
0038                 <span class="keyword">end</span>
0039             <span class="keyword">end</span>
0040         <span class="keyword">end</span>
0041         <span class="keyword">if</span> isinf(qn.nservers(ist))
0042             qn.nservers(ist) = sum(capacityc(ind,:));
0043         <span class="keyword">end</span>
0044     <span class="keyword">elseif</span> qn.isstateful(ind) <span class="comment">% generate state space of other stateful nodes that are not stations</span>
0045         isf = qn.nodeToStateful(ind);
0046         ist = qn.nodeToStation(ind);
0047         <span class="keyword">switch</span> qn.nodetype(ind)
0048             <span class="keyword">case</span> NodeType.Cache
0049                 <span class="keyword">for</span> r=1:qn.nclasses <span class="comment">% restrict state space generation for immediate events</span>
0050                     <span class="keyword">if</span> isnan(qn.varsparam{ind}.p{r})
0051                         capacityc(ind,r) =  0; <span class="comment">%</span>
0052                     <span class="keyword">else</span>
0053                         capacityc(ind,r) =  1; <span class="comment">%</span>
0054                     <span class="keyword">end</span>
0055                 <span class="keyword">end</span>
0056             <span class="keyword">otherwise</span>
0057                 capacityc(ind,:) =  1; <span class="comment">%</span>
0058         <span class="keyword">end</span>
0059     <span class="keyword">end</span>
0060 <span class="keyword">end</span>
0061 
0062 <span class="comment">%%</span>
0063 <span class="keyword">if</span> any(isinf(Np))
0064     Np(isinf(Np)) = 0;
0065 <span class="keyword">end</span>
0066 
0067 init_state_hashed = ones(1,nstateful); <span class="comment">% pick the first state in space{i}</span>
0068 
0069 <span class="comment">%%</span>
0070 arvRatesSamples = zeros(options.samples,nstateful,R);
0071 depRatesSamples = zeros(options.samples,nstateful,R);
0072 A = length(sync);
0073 samples_collected = 1;
0074 state = init_state_hashed;
0075 stateCell = cell(nstateful,1);
0076 <span class="keyword">for</span> ind=1:qn.nnodes
0077     <span class="keyword">if</span> qn.isstateful(ind)
0078         isf = qn.nodeToStateful(ind);
0079         stateCell{isf} = qn.space{isf}(state(isf),:);
0080     <span class="keyword">end</span>
0081 <span class="keyword">end</span>
0082 output = zeros(samples_collected,1+length(init_state_hashed));
0083 output(1,:) = [0,init_state_hashed];
0084 local = qn.nnodes+1;
0085 last_node_a = 0;
0086 last_node_p = 0;
0087 <span class="keyword">for</span> act=1:A
0088     node_a{act} = sync{act}.active{1}.node;
0089     node_p{act} = sync{act}.passive{1}.node;
0090     class_a{act} = sync{act}.active{1}.class;
0091     class_p{act} = sync{act}.passive{1}.class;
0092     event_a{act} = sync{act}.active{1}.event;
0093     event_p{act} = sync{act}.passive{1}.event;
0094     outprob_a{act} = [];
0095     outprob_p{act} = [];
0096 <span class="keyword">end</span>
0097 
0098 <span class="keyword">while</span> samples_collected &lt; options.samples
0099     <span class="comment">%samples_collected</span>
0100     ctr = 1;
0101     enabled_action = {}; <span class="comment">% row is action label, col1=rate, col2=new state</span>
0102     enabled_new_state = {};
0103     enabled_rates = [];
0104     <span class="keyword">for</span> act=1:A
0105         update_cond_a = ((node_a{act} == last_node_a || node_a{act} == last_node_p));
0106                 
0107         <span class="keyword">if</span> update_cond_a || isempty(outprob_a{act})
0108             state_a(act) = state(qn.nodeToStateful(node_a{act}));
0109             [new_state_a{act}, rate_a{act}, outprob_a{act}, qn] = State.afterEventHashedOrAdd(qn, node_a{act}, state_a(act), event_a{act}, class_a{act});
0110         <span class="keyword">end</span>
0111         
0112         <span class="keyword">if</span> all(new_state_a{act}) == -1 <span class="comment">% hash not found</span>
0113             <span class="keyword">continue</span>
0114         <span class="keyword">end</span>
0115         
0116         <span class="keyword">for</span> ia=1:length(new_state_a{act}) <span class="comment">% for all possible new states</span>
0117             <span class="keyword">if</span> new_state_a{act}(ia) == -1 <span class="comment">% hash not found</span>
0118                 <span class="keyword">continue</span>
0119             <span class="keyword">end</span>
0120             update_cond_p = ((node_p{act} == last_node_a || node_p{act} == last_node_p)) || isempty(outprob_p{act});
0121             update_cond = update_cond_a || update_cond_p;
0122             <span class="keyword">if</span> rate_a{act}(ia)&gt;0
0123                 <span class="keyword">if</span> node_p{act} ~= local
0124                     state_p{act} = state(qn.nodeToStateful(node_p{act}));
0125                     <span class="keyword">if</span> node_p{act} == node_a{act} <span class="comment">%self-loop</span>
0126                         <span class="keyword">if</span> update_cond
0127                             [new_state_p{act}, ~, outprob_p{act}] = State.afterEventHashedOrAdd(qn, node_p{act}, new_state_a{act}(ia), event_p{act}, class_p{act});
0128                         <span class="keyword">end</span>
0129                     <span class="keyword">else</span> <span class="comment">% departure</span>
0130                         <span class="keyword">if</span> update_cond
0131                             [new_state_p{act}, ~, outprob_p{act}] = State.afterEventHashedOrAdd( qn, node_p{act}, state_p{act}, event_p{act}, class_p{act});
0132                         <span class="keyword">end</span>
0133                     <span class="keyword">end</span>
0134                     <span class="keyword">if</span> new_state_p{act} ~= -1
0135                         <span class="keyword">if</span> qn.isstatedep(node_a{act},3)
0136                             newStateCell = stateCell;
0137                             newStateCell{qn.nodeToStateful(node_a{act})} = qn.space{qn.nodeToStateful(node_a{act})}(new_state_a{act}(ia),:);
0138                             newStateCell{qn.nodeToStateful(node_p{act})} = qn.space{qn.nodeToStateful(node_p{act})}(new_state_p{act},:);
0139                             prob_sync_p{act} = sync{act}.passive{1}.prob(stateCell, newStateCell); <span class="comment">%state-dependent</span>
0140                         <span class="keyword">else</span>
0141                             prob_sync_p{act} = sync{act}.passive{1}.prob;
0142                         <span class="keyword">end</span>
0143                     <span class="keyword">else</span>
0144                         prob_sync_p{act} = 0;
0145                     <span class="keyword">end</span>
0146                 <span class="keyword">end</span>
0147                 <span class="keyword">if</span> ~isempty(new_state_a{act}(ia))
0148                     <span class="keyword">if</span> node_p{act} == local
0149                         new_state = state;
0150                         new_state(qn.nodeToStateful(node_a{act})) = new_state_a{act}(ia);
0151                         prob_sync_p{act} = 1;
0152                     <span class="keyword">elseif</span> new_state_p{act} ~= -1
0153                         new_state = state;
0154                         new_state(qn.nodeToStateful(node_a{act})) = new_state_a{act}(ia);
0155                         new_state(qn.nodeToStateful(node_p{act})) = new_state_p{act};
0156                     <span class="keyword">end</span>
0157                     <span class="keyword">if</span> ~isnan(rate_a{act})
0158                         <span class="keyword">if</span> all(new_state&gt;0)
0159                             <span class="keyword">if</span> event_a{act} == Event.DEP
0160                                 node_a_sf{act} = qn.nodeToStateful(node_a{act});
0161                                 node_p_sf{act} = qn.nodeToStateful(node_p{act});
0162                                 depRatesSamples(samples_collected,node_a_sf{act},class_a{act}) = depRatesSamples(samples_collected,node_a_sf{act},class_a{act}) + outprob_a{act} * outprob_p{act} * rate_a{act}(ia) * prob_sync_p{act};
0163                                 arvRatesSamples(samples_collected,node_p_sf{act},class_p{act}) = arvRatesSamples(samples_collected,node_p_sf{act},class_p{act}) + outprob_a{act} * outprob_p{act} * rate_a{act}(ia) * prob_sync_p{act};
0164                             <span class="keyword">end</span>
0165                             <span class="keyword">if</span> any(new_state ~= state)
0166                                 <span class="keyword">if</span> node_p{act} &lt; local &amp;&amp; ~csmask(class_a{act}, class_p{act}) &amp;&amp; qn.nodetype(node_p{act})~=NodeType.Source &amp;&amp; (rate_a{act}(ia) * prob_sync_p{act} &gt;0)
0167                                     error(<span class="string">'Fatal error: state-dependent routing at node %d violates class switching mask (node %d -&gt; node %d, class %d -&gt; class %d).'</span>, node_a{act}, node_a{act}, node_p{act}, class_a{act}, class_p{act});
0168                                 <span class="keyword">end</span>
0169                                 enabled_rates(ctr) = rate_a{act}(ia) * prob_sync_p{act};
0170                                 enabled_action{ctr} = act;
0171                                 enabled_new_state{ctr} = new_state;
0172                                 ctr = ctr + 1;
0173                             <span class="keyword">end</span>
0174                         <span class="keyword">end</span>
0175                     <span class="keyword">end</span>
0176                 <span class="keyword">end</span>
0177             <span class="keyword">end</span>
0178         <span class="keyword">end</span>
0179     <span class="keyword">end</span>
0180     tot_rate = sum(enabled_rates);
0181     cum_rate = cumsum(enabled_rates) / tot_rate;
0182     firing_ctr = 1 + max([0,find( rand &gt; cum_rate )]); <span class="comment">% select action</span>
0183     last_node_a = node_a{enabled_action{firing_ctr}};
0184     last_node_p = node_p{enabled_action{firing_ctr}};
0185     next_state = enabled_new_state{firing_ctr};
0186     output(samples_collected, :) = [-(log(rand)/tot_rate), state];
0187     samples_collected = samples_collected + 1;
0188     state = next_state;
0189     <span class="keyword">if</span> options.verbose
0190         <span class="keyword">if</span> samples_collected == 1e2
0191             fprintf(1,sprintf(<span class="string">'SSA samples: %6d'</span>,samples_collected));
0192         <span class="keyword">elseif</span> options.verbose == 2
0193             <span class="keyword">if</span> samples_collected == 0
0194                 fprintf(1,sprintf(<span class="string">'SSA samples: %6d'</span>,samples_collected));
0195             <span class="keyword">else</span>
0196                 fprintf(1,sprintf(<span class="string">'\b\b\b\b\b\b%6d'</span>,samples_collected));
0197             <span class="keyword">end</span>
0198         <span class="keyword">elseif</span> mod(samples_collected,1e2)==0 || options.verbose == 2
0199             fprintf(1,sprintf(<span class="string">'\b\b\b\b\b\b%6d'</span>,samples_collected));
0200         <span class="keyword">end</span>
0201     <span class="keyword">end</span>
0202 <span class="keyword">end</span>
0203 
0204 <span class="comment">%Q</span>
0205 <span class="comment">%transient = min([floor(samples_collected/10),1000]); % remove first part of simulation (10% of the samples up to 1000 max)</span>
0206 <span class="comment">%transient = 0;</span>
0207 <span class="comment">%output = output((transient+1):end,:);</span>
0208 [u,ui,uj] = unique(output(:,2:end),<span class="string">'rows'</span>);
0209 arvRates = zeros(size(u,1),qn.nstateful,R);
0210 depRates = zeros(size(u,1),qn.nstateful,R);
0211 pi = zeros(1,size(u,1));
0212 <span class="keyword">for</span> s=1:size(u,1)
0213     pi(s) = sum(output(uj==s,1));    
0214 <span class="keyword">end</span>
0215 
0216 <span class="keyword">for</span> ind=1:qn.nnodes
0217     <span class="keyword">if</span> qn.isstateful(ind)
0218         isf = qn.nodeToStateful(ind);
0219         <span class="keyword">if</span> qn.isstation(ind)
0220             ist = qn.nodeToStation(ind);
0221             K = qn.phasessz(ist,:);<span class="comment">% disabled classes still occupy 1 state element</span>
0222             Ks = qn.phaseshift(ist,:);
0223         <span class="keyword">end</span>
0224         <span class="keyword">for</span> s=1:size(u,1)
0225             <span class="keyword">for</span> r=1:R
0226                 arvRates(s,isf,r) = arvRatesSamples(ui(s),isf,r); <span class="comment">% we just need one sample</span>
0227                 depRates(s,isf,r) = depRatesSamples(ui(s),isf,r); <span class="comment">% we just need one sample</span>
0228             <span class="keyword">end</span>
0229             state_i = qn.space{isf}(u(s,isf),:);
0230             <span class="comment">%if isf==2</span>
0231             <span class="comment">%    state_i</span>
0232             <span class="comment">%end</span>
0233             <span class="keyword">if</span> qn.isstation(ind)
0234                 [~,nir] = State.toMarginalAggr(qn, ind, state_i, K, Ks);
0235                 ist = qn.nodeToStation(ind);
0236                 SSq(s,((ist-1)*R+1):ist*R) = nir;
0237             <span class="keyword">end</span>
0238         <span class="keyword">end</span>
0239     <span class="keyword">end</span>
0240 <span class="keyword">end</span>
0241 
0242 pi = pi/sum(pi);
0243 <span class="keyword">if</span> options.verbose
0244     fprintf(1,<span class="string">'\n'</span>);
0245 <span class="keyword">end</span>
0246 <span class="comment">%unique(Q,'rows')</span>
0247 <span class="comment">%qn.nservers = init_nserver; % restore Inf at delay nodes</span>
0248 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>