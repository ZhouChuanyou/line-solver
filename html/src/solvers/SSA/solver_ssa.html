<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_ssa</title>
  <meta name="keywords" content="solver_ssa">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">SSA</a> &gt; solver_ssa.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\SSA&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_ssa
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [pi,SSq,arvRates,depRates]=solver_ssa(qn,options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="solver_ssa_analysis.html" class="code" title="function [QN,UN,RN,TN,CN,XN,runtime] = solver_ssa_analysis(qn, options)">solver_ssa_analysis</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="solver_ssa_analysis_spmd.html" class="code" title="function [XN,UN,QN,RN,TN,CN]=solver_ssa_analysis_spmd(laboptions, qn, qnc, PH)">solver_ssa_analysis_spmd</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [pi,SSq,arvRates,depRates]=solver_ssa(qn,options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 <span class="comment">% by default the jobs are all initialized in the first valid state</span>
0006 <span class="comment">%% generate local state spaces</span>
0007 nstations = qn.nstations;
0008 nstateful = qn.nstateful;
0009 <span class="comment">%init_nserver = qn.nservers; % restore Inf at delay nodes</span>
0010 R = qn.nclasses;
0011 N = qn.njobs';
0012 sync = qn.sync;
0013 csmask = qn.csmask;
0014 
0015 cutoff = options.cutoff;
0016 <span class="keyword">if</span> prod(size(cutoff))==1
0017     cutoff = cutoff * ones(qn.nstations, qn.nclasses);
0018 <span class="keyword">end</span>
0019 
0020 <span class="comment">%%</span>
0021 Np = N';
0022 capacityc = zeros(qn.nnodes, qn.nclasses);
0023 <span class="keyword">for</span> ind=1:qn.nnodes
0024     <span class="keyword">if</span> qn.isstation(ind) <span class="comment">% place jobs across stations</span>
0025         ist = qn.nodeToStation(ind);
0026         isf = qn.nodeToStateful(ind);
0027         <span class="keyword">for</span> r=1:qn.nclasses <span class="comment">%cut-off open classes to finite capacity</span>
0028             c = find(qn.chains(:,r));
0029             <span class="keyword">if</span> ~isempty(qn.visits{c}) &amp;&amp; qn.visits{c}(ist,r) == 0
0030                 capacityc(ind,r) = 0;
0031             <span class="keyword">elseif</span> any(isnan(qn.mu{ist,r})) <span class="comment">% disabled</span>
0032                 capacityc(ind,r) = 0;
0033             <span class="keyword">else</span>
0034                 <span class="keyword">if</span> isinf(N(r))
0035                     capacityc(ind,r) =  min(cutoff(ist,r), qn.classcap(ist,r));
0036                 <span class="keyword">else</span>
0037                     capacityc(ind,r) =  sum(qn.njobs(qn.chains(c,:)));
0038                 <span class="keyword">end</span>
0039             <span class="keyword">end</span>
0040         <span class="keyword">end</span>
0041         <span class="keyword">if</span> isinf(qn.nservers(ist))
0042             qn.nservers(ist) = sum(capacityc(ind,:));
0043         <span class="keyword">end</span>
0044     <span class="keyword">elseif</span> qn.isstateful(ind) <span class="comment">% generate state space of other stateful nodes that are not stations</span>
0045         isf = qn.nodeToStateful(ind);
0046         ist = qn.nodeToStation(ind);
0047         <span class="keyword">switch</span> qn.nodetype(ind)
0048             <span class="keyword">case</span> NodeType.Cache
0049                 <span class="keyword">for</span> r=1:qn.nclasses <span class="comment">% restrict state space generation for immediate events</span>
0050                     <span class="keyword">if</span> isnan(qn.varsparam{ind}.pref{r})
0051                         capacityc(ind,r) =  0; <span class="comment">%</span>
0052                     <span class="keyword">else</span>
0053                         capacityc(ind,r) =  1; <span class="comment">%</span>
0054                     <span class="keyword">end</span>
0055                 <span class="keyword">end</span>
0056             <span class="keyword">otherwise</span>
0057                 capacityc(ind,:) =  1; <span class="comment">%</span>
0058         <span class="keyword">end</span>
0059     <span class="keyword">end</span>
0060 <span class="keyword">end</span>
0061 
0062 <span class="comment">%%</span>
0063 <span class="keyword">if</span> any(isinf(Np))
0064     Np(isinf(Np)) = 0;
0065 <span class="keyword">end</span>
0066 
0067 init_state_hashed = ones(1,nstateful); <span class="comment">% pick the first state in space{i}</span>
0068 
0069 <span class="comment">%%</span>
0070 arvRatesSamples = zeros(options.samples,nstateful,R);
0071 depRatesSamples = zeros(options.samples,nstateful,R);
0072 A = length(sync);
0073 samples_collected = 1;
0074 state = init_state_hashed;
0075 stateCell = cell(nstateful,1);
0076 nir = {};
0077 <span class="keyword">for</span> ind=1:qn.nnodes
0078     <span class="keyword">if</span> qn.isstateful(ind)
0079         isf = qn.nodeToStateful(ind);
0080         stateCell{isf} = qn.space{isf}(state(isf),:);
0081         <span class="keyword">if</span> qn.isstation(ind)
0082             ist = qn.nodeToStation(ind);
0083             [~,nir{ist}] = State.toMarginal(qn, ind, qn.space{isf}(state(isf),:));
0084             nir{ist} = nir{ist}(:);
0085         <span class="keyword">end</span>
0086     <span class="keyword">end</span>
0087 <span class="keyword">end</span>
0088 
0089 state = cell2mat(stateCell');
0090 output = zeros(1+length(state),samples_collected);
0091 output(1:(1+length(state)),1) = [0, state]';
0092 SSq = cell2mat(nir');
0093 local = qn.nnodes+1;
0094 last_node_a = 0;
0095 last_node_p = 0;
0096 <span class="keyword">for</span> act=1:A
0097     node_a{act} = sync{act}.active{1}.node;
0098     node_p{act} = sync{act}.passive{1}.node;
0099     class_a{act} = sync{act}.active{1}.class;
0100     class_p{act} = sync{act}.passive{1}.class;
0101     event_a{act} = sync{act}.active{1}.event;
0102     event_p{act} = sync{act}.passive{1}.event;
0103     outprob_a{act} = [];
0104     outprob_p{act} = [];
0105 <span class="keyword">end</span>
0106 newStateCell = cell(1,A);
0107 isSimulation = true; <span class="comment">% allow state vector to grow, e.g. for FCFS buffers</span>
0108 <span class="keyword">while</span> samples_collected &lt; options.samples
0109     <span class="comment">%samples_collected</span>
0110     ctr = 1;
0111     enabled_action = {}; <span class="comment">% row is action label, col1=rate, col2=new state</span>
0112     enabled_new_state = {};
0113     enabled_rates = [];
0114     <span class="keyword">for</span> act=1:A
0115         update_cond_a = true; <span class="comment">%((node_a{act} == last_node_a || node_a{act} == last_node_p));</span>
0116         newStateCell{act} = stateCell;
0117         <span class="keyword">if</span> update_cond_a || isempty(outprob_a{act})
0118             isf = qn.nodeToStateful(node_a{act});
0119             [newStateCell{act}{qn.nodeToStateful(node_a{act})}, rate_a{act}, outprob_a{act}] =  State.afterEvent(qn, node_a{act}, stateCell{isf}, event_a{act}, class_a{act}, isSimulation);
0120         <span class="keyword">end</span>
0121         
0122         <span class="keyword">if</span> isempty(newStateCell{act}{qn.nodeToStateful(node_a{act})}) || isempty(rate_a{act}) <span class="comment">% state not found</span>
0123             <span class="keyword">continue</span>
0124         <span class="keyword">end</span>
0125         
0126         <span class="keyword">for</span> ia=1:size(newStateCell{act}{qn.nodeToStateful(node_a{act})},1) <span class="comment">% for all possible new states</span>
0127             <span class="keyword">if</span> newStateCell{act}{qn.nodeToStateful(node_a{act})}(ia,:) == -1 <span class="comment">% hash not found</span>
0128                 <span class="keyword">continue</span>
0129             <span class="keyword">end</span>
0130             update_cond_p = ((node_p{act} == last_node_a || node_p{act} == last_node_p)) || isempty(outprob_p{act});
0131             update_cond = true; <span class="comment">%update_cond_a || update_cond_p;</span>
0132             <span class="keyword">if</span> rate_a{act}(ia)&gt;0
0133                 <span class="keyword">if</span> node_p{act} ~= local
0134                     <span class="keyword">if</span> node_p{act} == node_a{act} <span class="comment">%self-loop</span>
0135                         <span class="keyword">if</span> update_cond
0136                             [newStateCell{act}{qn.nodeToStateful(node_p{act})}, ~, outprob_p{act}] =  State.afterEvent(qn, node_p{act}, newStateCell{act}{qn.nodeToStateful(node_a{act})}, event_p{act}, class_p{act}, isSimulation);
0137                         <span class="keyword">end</span>
0138                     <span class="keyword">else</span> <span class="comment">% departure</span>
0139                         <span class="keyword">if</span> update_cond
0140                             [newStateCell{act}{qn.nodeToStateful(node_p{act})}, ~, outprob_p{act}] =  State.afterEvent(qn, node_p{act}, newStateCell{act}{qn.nodeToStateful(node_p{act})}, event_p{act}, class_p{act}, isSimulation);
0141                         <span class="keyword">end</span>
0142                     <span class="keyword">end</span>
0143                     <span class="keyword">if</span> ~isempty(newStateCell{act}{qn.nodeToStateful(node_p{act})})
0144                         <span class="keyword">if</span> qn.isstatedep(node_a{act},3)
0145                             prob_sync_p{act} = sync{act}.passive{1}.prob(stateCell, newStateCell{act}); <span class="comment">%state-dependent</span>
0146                         <span class="keyword">else</span>
0147                             prob_sync_p{act} = sync{act}.passive{1}.prob;
0148                         <span class="keyword">end</span>
0149                     <span class="keyword">else</span>
0150                         prob_sync_p{act} = 0;
0151                     <span class="keyword">end</span>
0152                 <span class="keyword">end</span>
0153                 <span class="keyword">if</span> ~isempty(newStateCell{act}{qn.nodeToStateful(node_a{act})})
0154                     <span class="keyword">if</span> node_p{act} == local
0155                         prob_sync_p{act} = 1; <span class="comment">%outprob_a{act}; % was 1</span>
0156                     <span class="keyword">end</span>
0157                     <span class="keyword">if</span> ~isnan(rate_a{act})
0158                         <span class="keyword">if</span> all(~cellfun(@isempty,newStateCell{act}))
0159                             <span class="keyword">if</span> event_a{act} == Event.DEP
0160                                 node_a_sf{act} = qn.nodeToStateful(node_a{act});
0161                                 node_p_sf{act} = qn.nodeToStateful(node_p{act});
0162                                 depRatesSamples(samples_collected,node_a_sf{act},class_a{act}) = depRatesSamples(samples_collected,node_a_sf{act},class_a{act}) + outprob_a{act} * outprob_p{act} * rate_a{act}(ia) * prob_sync_p{act};
0163                                 arvRatesSamples(samples_collected,node_p_sf{act},class_p{act}) = arvRatesSamples(samples_collected,node_p_sf{act},class_p{act}) + outprob_a{act} * outprob_p{act} * rate_a{act}(ia) * prob_sync_p{act};
0164                             <span class="keyword">end</span>
0165                             <span class="keyword">if</span> any(~cellfun(@isequal,newStateCell{act},stateCell))
0166                                 <span class="keyword">if</span> node_p{act} &lt; local &amp;&amp; ~csmask(class_a{act}, class_p{act}) &amp;&amp; qn.nodetype(node_p{act})~=NodeType.Source &amp;&amp; (rate_a{act}(ia) * prob_sync_p{act} &gt;0)
0167                                     error(<span class="string">'Fatal error: state-dependent routing at node %d violates class switching mask (node %d -&gt; node %d, class %d -&gt; class %d).'</span>, node_a{act}, node_a{act}, node_p{act}, class_a{act}, class_p{act});
0168                                 <span class="keyword">end</span>
0169                                 enabled_rates(ctr) = rate_a{act}(ia) * prob_sync_p{act};
0170                                 enabled_action{ctr} = act;
0171                                 <span class="comment">%enabled_new_state{ctr} = new_state;</span>
0172                                 ctr = ctr + 1;
0173                             <span class="keyword">end</span>
0174                         <span class="keyword">end</span>
0175                     <span class="keyword">end</span>
0176                 <span class="keyword">end</span>
0177             <span class="keyword">end</span>
0178         <span class="keyword">end</span>
0179     <span class="keyword">end</span>
0180     
0181     tot_rate = sum(enabled_rates);
0182     cum_rate = cumsum(enabled_rates) / tot_rate;
0183     firing_ctr = 1 + max([0,find( rand &gt; cum_rate )]); <span class="comment">% select action</span>
0184     last_node_a = node_a{enabled_action{firing_ctr}};
0185     last_node_p = node_p{enabled_action{firing_ctr}};
0186     state = cell2mat(stateCell');
0187     output(1:(1+length(state)),samples_collected) = [-(log(rand)/tot_rate), state]';
0188     
0189     <span class="keyword">for</span> ind=1:qn.nnodes
0190         <span class="keyword">if</span> qn.isstation(ind)
0191             isf = qn.nodeToStateful(ind);
0192             ist = qn.nodeToStation(ind);
0193             [~,nir{ist}] = State.toMarginal(qn, ind, stateCell{isf});
0194             nir{ist}=nir{ist}(:);
0195         <span class="keyword">end</span>
0196     <span class="keyword">end</span>
0197     SSq(:,samples_collected) = cell2mat(nir');
0198     
0199     samples_collected = samples_collected + 1;
0200     stateCell = newStateCell{enabled_action{firing_ctr}};
0201     <span class="keyword">if</span> options.verbose
0202         <span class="keyword">if</span> samples_collected == 1e2
0203             fprintf(1,sprintf(<span class="string">'SSA samples: %6d'</span>,samples_collected));
0204         <span class="keyword">elseif</span> options.verbose == 2
0205             <span class="keyword">if</span> samples_collected == 0
0206                 fprintf(1,sprintf(<span class="string">'SSA samples: %6d'</span>,samples_collected));
0207             <span class="keyword">else</span>
0208                 fprintf(1,sprintf(<span class="string">'\b\b\b\b\b\b%6d'</span>,samples_collected));
0209             <span class="keyword">end</span>
0210         <span class="keyword">elseif</span> mod(samples_collected,1e2)==0 || options.verbose == 2
0211             fprintf(1,sprintf(<span class="string">'\b\b\b\b\b\b%6d'</span>,samples_collected));
0212         <span class="keyword">end</span>
0213     <span class="keyword">end</span>
0214 <span class="keyword">end</span>
0215 
0216 <span class="comment">%transient = min([floor(samples_collected/10),1000]); % remove first part of simulation (10% of the samples up to 1000 max)</span>
0217 <span class="comment">%transient = 0;</span>
0218 <span class="comment">%output = output((transient+1):end,:);</span>
0219 output = output';
0220 [u,ui,uj] = unique(output(:,2:end),<span class="string">'rows'</span>);
0221 arvRates = zeros(size(u,1),qn.nstateful,R);
0222 depRates = zeros(size(u,1),qn.nstateful,R);
0223 
0224 pi = zeros(1,size(u,1));
0225 <span class="keyword">for</span> s=1:size(u,1)
0226     pi(s) = sum(output(uj==s,1));
0227 <span class="keyword">end</span>
0228 SSq = SSq(:,ui)';
0229 
0230 <span class="keyword">for</span> ind=1:qn.nnodes
0231     <span class="keyword">if</span> qn.isstateful(ind)
0232         isf = qn.nodeToStateful(ind);
0233         <span class="keyword">if</span> qn.isstation(ind)
0234             ist = qn.nodeToStation(ind);
0235             K = qn.phasessz(ist,:);
0236             Ks = qn.phaseshift(ist,:);
0237         <span class="keyword">end</span>
0238         <span class="keyword">for</span> s=1:size(u,1)
0239             <span class="keyword">for</span> r=1:R
0240                 arvRates(s,isf,r) = arvRatesSamples(ui(s),isf,r); <span class="comment">% we just need one sample</span>
0241                 depRates(s,isf,r) = depRatesSamples(ui(s),isf,r); <span class="comment">% we just need one sample</span>
0242             <span class="keyword">end</span>
0243         <span class="keyword">end</span>
0244     <span class="keyword">end</span>
0245 <span class="keyword">end</span>
0246 pi = pi/sum(pi);
0247 <span class="keyword">if</span> options.verbose
0248     fprintf(1,<span class="string">'\n'</span>);
0249 <span class="keyword">end</span>
0250 <span class="comment">%qn.nservers = init_nserver; % restore Inf at delay nodes</span>
0251 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>