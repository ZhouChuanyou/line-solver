<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_fluid_analysis</title>
  <meta name="keywords" content="solver_fluid_analysis">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">Fluid</a> &gt; solver_fluid_analysis.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\Fluid&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_fluid_analysis
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [Qfull, Ufull, Rfull, Tfull, Cfull, Xfull, t, Qfull_t, Ufull_t, Tfull_t, lastSolution] = solver_fluid_analysis(qn, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="solver_fluid_analysis_inner.html" class="code" title="function [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ymean_t, t,iters,runtime] = solver_fluid_analysis_inner(qn, options)">solver_fluid_analysis_inner</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="solver_fluid_initsol.html" class="code" title="function [init_sol, state] = solver_fluid_initsol(qn, options) %#ok<INUSD>">solver_fluid_initsol</a>	Copyright (c) 2012-2019, Imperial College London</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SolverFluid.html" class="code" title="">SolverFluid</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Qfull, Ufull, Rfull, Tfull, Cfull, Xfull, t, Qfull_t, Ufull_t, Tfull_t, lastSolution] = solver_fluid_analysis(qn, options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 Cfull=[]; Xfull=[];
0006 
0007 M = qn.nstations;
0008 K = qn.nclasses;
0009 mu = qn.mu;
0010 phi = qn.phi;
0011 S = qn.nservers;
0012 SCV = qn.scv;
0013 
0014 PH=cell(M,K);
0015 <span class="keyword">for</span> i=1:M
0016     <span class="keyword">for</span> k=1:K
0017         <span class="keyword">if</span> length(mu{i,k})==1
0018             PH{i,k} = map_exponential(1/mu{i,k});
0019             rates0(i,k) = mu{i,k};
0020             phases(i,k) = 1;
0021         <span class="keyword">else</span>
0022             D0 = diag(-mu{i,k})+diag(mu{i,k}(1:end-1).*(1-phi{i,k}(1:end-1)),1);
0023             D1 = zeros(size(D0));
0024             D1(:,1)=(phi{i,k}.*mu{i,k});
0025             PH{i,k} = map_normalize({D0,D1});
0026             rates0(i,k) = map_lambda(PH{i,k});
0027             phases(i,k) = length(D0);
0028         <span class="keyword">end</span>
0029     <span class="keyword">end</span>
0030 <span class="keyword">end</span>
0031 
0032 <span class="keyword">if</span> isempty(options.init_sol)
0033     options.init_sol = <a href="solver_fluid_initsol.html" class="code" title="function [init_sol, state] = solver_fluid_initsol(qn, options) %#ok<INUSD>">solver_fluid_initsol</a>(qn, options);
0034 <span class="keyword">end</span>
0035 
0036 outer_iters = 1;
0037 outer_runtime = tic;
0038 [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ~, t] = <a href="solver_fluid_analysis_inner.html" class="code" title="function [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ymean_t, t,iters,runtime] = solver_fluid_analysis_inner(qn, options)">solver_fluid_analysis_inner</a>(qn, options);
0039 outer_runtime = toc(outer_runtime);
0040 phases_last = phases;
0041 <span class="keyword">if</span> findstring(qn.sched, SchedStrategy.FCFS) ~= -1 <span class="comment">% if there are FCFS stations</span>
0042     rates = rates0;
0043     iter = 0;
0044     eta_1 = zeros(1,M);
0045     eta = Inf*ones(1,M);
0046     tol = 1e-2;
0047     
0048     <span class="keyword">while</span> max(abs(1-eta./eta_1)) &gt; tol &amp;&amp; iter &lt;= options.iter_max
0049         iter = iter + 1;
0050         eta_1 = eta;        
0051         eta= zeros(1,M);
0052         cs = ones(M,1);
0053         <span class="keyword">for</span> i=1:M
0054             B(i) = min(sum(Qfull(i,:)),S(i)); <span class="comment">% number of busy servers</span>
0055         <span class="keyword">end</span>        
0056         <span class="keyword">for</span> i=1:M
0057             sd = rates0(i,:)&gt;0;
0058             Ufull(i,sd) = Tfull(i,sd) ./ rates0(i,sd);
0059             <span class="keyword">switch</span> qn.sched{i}
0060                 <span class="keyword">case</span> SchedStrategy.FCFS
0061                     sd = rates0(i,:)&gt;0;
0062                     <span class="keyword">if</span> range(rates0(i,sd))&gt;0 <span class="comment">% check if non-product-form</span>
0063                         rho(i) = sum(Ufull(i,sd))/S(i); <span class="comment">% true utilization of each server</span>
0064                         ca = 0;
0065                         <span class="keyword">for</span> j=1:M
0066                             <span class="keyword">for</span> r=1:K
0067                                 <span class="keyword">if</span> rates0(j,r)&gt;0
0068                                     <span class="keyword">for</span> s=1:K
0069                                         <span class="keyword">if</span> rates0(i,s)&gt;0
0070                                             pji_rs = qn.rt((i-1)*qn.nclasses + r, (j-1)*qn.nclasses + s);
0071                                             ca = ca + (SCV(j,r))*Tfull(j,r)*pji_rs/sum(Tfull(i,sd));
0072                                         <span class="keyword">end</span>
0073                                     <span class="keyword">end</span>
0074                                 <span class="keyword">end</span>
0075                             <span class="keyword">end</span>
0076                         <span class="keyword">end</span>
0077                         cs(i) = (SCV(i,sd)*Tfull(i,sd)')/sum(Tfull(i,sd));
0078                         eta(i) = exp(-2*(1-rho(i))/(cs(i)+ca*rho(i)));
0079                         <span class="comment">%eta(i) = rho(i);</span>
0080                         <span class="comment">% dimensionally a utilization, (diffusion approximation, Kobayashi JACM)</span>
0081                     <span class="keyword">end</span>
0082             <span class="keyword">end</span>
0083         <span class="keyword">end</span>
0084         
0085         <span class="keyword">for</span> i=1:M
0086             <span class="keyword">switch</span> qn.sched{i}
0087                 <span class="keyword">case</span> SchedStrategy.FCFS
0088                     sd = rates0(i,:)&gt;0;
0089                     <span class="keyword">if</span> range(rates0(i,sd))&gt;0 <span class="comment">% check if non-product-form</span>
0090                         <span class="keyword">for</span> k=1:K
0091                             <span class="keyword">if</span> sum(Qfull(i,:)) &lt; S(i)
0092                                 <span class="keyword">if</span> Ufull(i,k) &gt; 0
0093                                     rates(i,k) = rates0(i,k);
0094                                 <span class="keyword">end</span>
0095                             <span class="keyword">else</span>
0096                                 <span class="keyword">if</span> rates(i,k) &gt; 0
0097                                     rates(i,k) = sum(Tfull(i,rates(i,:)&gt;0))/(eta(i)*S(i));
0098                                 <span class="keyword">end</span>
0099                             <span class="keyword">end</span>
0100                         <span class="keyword">end</span>
0101                     <span class="keyword">end</span>
0102             <span class="keyword">end</span>
0103         <span class="keyword">end</span>
0104         rates(isnan(rates))=0;
0105         
0106         <span class="keyword">for</span> i=1:M
0107             <span class="keyword">switch</span> qn.sched{i}
0108                 <span class="keyword">case</span> SchedStrategy.FCFS
0109                     <span class="keyword">for</span> k=1:K
0110                         <span class="keyword">if</span> rates(i,k)&gt;0
0111                             PH{i,k} = map_scale(PH{i,k},1/rates(i,k));
0112                             [muik,phiik] = Cox.fitMeanAndSCV(map_mean(PH{i,k}), SCV(i,k));
0113                             <span class="comment">%[muik,phiik] = Cox.fitMeanAndSCV(map_mean(PH{i,k}), 1); % replace with an exponential</span>
0114                             <span class="comment">% we now handle the case that due to either numerical issues</span>
0115                             <span class="comment">% or different relationship between scv and mean the size of</span>
0116                             <span class="comment">% the phase-type representation has changed</span>
0117                             phases(i,k) = length(muik);
0118                             <span class="keyword">if</span> phases(i,k) ~= phases_last(i,k) <span class="comment">% if number of phases changed</span>
0119                                 <span class="comment">% before we update qn we adjust the initial state</span>
0120                                 isf = qn.stationToStateful(i);
0121                                 [~, nir, sir] = State.toMarginal(qn, i, qn.state{isf}, options);
0122                             <span class="keyword">end</span>
0123                             <span class="comment">%if any(muik &gt; 0.01+ qn.mu{i,k} * rates(i,k) / rates0(i,k))</span>
0124                             <span class="comment">%    keyboard</span>
0125                             <span class="comment">%end</span>
0126                             qn.mu{i,k} = muik;
0127                             qn.phi{i,k} = phiik;
0128                             qn.phases = phases;
0129                             <span class="keyword">if</span> phases(i,k) ~= phases_last(i,k)
0130                                 isf = qn.stationToStateful(i);
0131                                 <span class="comment">% we now initialize the new service process</span>
0132                                 qn.state{isf} = State.fromMarginalAndStarted(qn, i, nir, sir, options);
0133                                 qn.state{isf} = qn.state{isf}(1,:); <span class="comment">% pick one as the marginals won't change</span>
0134                             <span class="keyword">end</span>
0135                         <span class="keyword">end</span>
0136                     <span class="keyword">end</span>
0137             <span class="keyword">end</span>
0138         <span class="keyword">end</span>
0139         
0140         options.init_sol = ymean{end}(:);
0141         <span class="keyword">if</span> norm(phases_last-phases)&gt;0 <span class="comment">% If there is a change of phases reset</span>
0142             options.init_sol = <a href="solver_fluid_initsol.html" class="code" title="function [init_sol, state] = solver_fluid_initsol(qn, options) %#ok<INUSD>">solver_fluid_initsol</a>(qn);
0143         <span class="keyword">end</span>
0144         qn.phases = phases;
0145         [Qfull, Ufull, ~, Tfull, ymean, ~, ~, ~, ~, ~, inner_iters, inner_runtime] = <a href="solver_fluid_analysis_inner.html" class="code" title="function [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ymean_t, t,iters,runtime] = solver_fluid_analysis_inner(qn, options)">solver_fluid_analysis_inner</a>(qn, options);
0146         phases_last = phases;
0147         outer_iters = outer_iters + inner_iters;
0148         outer_runtime = outer_runtime + inner_runtime;
0149     <span class="keyword">end</span> <span class="comment">% FCFS iteration ends here</span>
0150     <span class="comment">% The FCFS iteration reinitializes at the solution of the last</span>
0151     <span class="comment">% iterative step. We now have converged in the substitution of the</span>
0152     <span class="comment">% model parameters and we rerun everything from the true initial point</span>
0153     <span class="comment">% so that we get the correct transient.</span>
0154     options.init_sol = <a href="solver_fluid_initsol.html" class="code" title="function [init_sol, state] = solver_fluid_initsol(qn, options) %#ok<INUSD>">solver_fluid_initsol</a>(qn, options);
0155     [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ~, t] = <a href="solver_fluid_analysis_inner.html" class="code" title="function [Qfull, Ufull, Rfull, Tfull, ymean, Qfull_t, Ufull_t, Tfull_t, ymean_t, t,iters,runtime] = solver_fluid_analysis_inner(qn, options)">solver_fluid_analysis_inner</a>(qn, options);
0156 <span class="keyword">end</span>
0157 
0158 Ufull0 = Ufull;
0159 <span class="keyword">for</span> i=1:M
0160     sd = find(Qfull(i,:)&gt;0);
0161     Ufull(i,Qfull(i,:)==0)=0;
0162     <span class="keyword">switch</span> qn.sched{i}
0163         <span class="keyword">case</span> SchedStrategy.FCFS
0164             <span class="keyword">for</span> k=sd
0165                 <span class="comment">% correct for the real rates, instead of the diffusion</span>
0166                 <span class="comment">% approximation rates</span>
0167                 Ufull(i,k) = min([1,Qfull(i,k)/S(i),sum(Ufull0(i,sd)) * (Tfull(i,k)./rates0(i,k))/sum(Tfull(i,sd)./rates0(i,sd))]);
0168             <span class="keyword">end</span>
0169     <span class="keyword">end</span>
0170 <span class="keyword">end</span>
0171 Ufull(isnan(Ufull))=0;
0172 
0173 <span class="keyword">for</span> i=1:M
0174     sd = find(Qfull(i,:)&gt;0);
0175     Rfull(i,Qfull(i,:)==0)=0;
0176     <span class="keyword">for</span> k=sd
0177         <span class="keyword">switch</span> qn.sched{i}
0178             <span class="keyword">case</span> SchedStrategy.FCFS
0179                 Rfull(i,k) = Qfull(i,k) / Tfull(i,k);
0180         <span class="keyword">end</span>
0181     <span class="keyword">end</span>
0182 <span class="keyword">end</span>
0183 Rfull(isnan(Rfull))=0;
0184 
0185 <span class="keyword">for</span> k=1:K
0186     <span class="keyword">if</span> qn.refstat(k)&gt;0 <span class="comment">% ignore artificial classes</span>
0187         Xfull(k) = Tfull(qn.refstat(k),k);
0188         Cfull(k) = qn.njobs(k) ./ Xfull(k);
0189     <span class="keyword">end</span>
0190 <span class="keyword">end</span>
0191 
0192 lastSolution.odeStateVec = ymean{end};
0193 lastSolution.qn = qn;
0194 <span class="comment">%if options.verbose</span>
0195 <span class="comment">%    fprintf(1,'Fluid analysis completed in %0.6f sec [%d iterations]\n',outer_runtime,outer_iters);</span>
0196 <span class="comment">%end</span>
0197 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>