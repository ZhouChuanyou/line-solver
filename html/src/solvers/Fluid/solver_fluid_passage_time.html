<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_fluid_passage_time</title>
  <meta name="keywords" content="solver_fluid_passage_time">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">Fluid</a> &gt; solver_fluid_passage_time.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\Fluid&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_fluid_passage_time
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function RTret = solver_fluid_passt(qn, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="solver_fluid_odes.html" class="code" title="function [ode_h,q_indices] = solver_fluid_odes(N, Mu, Phi, P, S, sched, schedparam)">solver_fluid_odes</a>	Copyright (c) 2012-2019, Imperial College London</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SolverFluid.html" class="code" title="">SolverFluid</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [value,isterminal,direction] = events(t,y)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function RTret = solver_fluid_passt(qn, options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 iter_max = options.iter_max;
0006 verbose = options.verbose;
0007 y0 = options.init_sol;
0008 
0009 M = qn.nstations;    <span class="comment">%number of stations</span>
0010 K = qn.nclasses;    <span class="comment">%number of classes</span>
0011 N = qn.nclosedjobs;    <span class="comment">%population</span>
0012 Lambda = qn.mu;
0013 Pi = qn.phi;
0014 rt = qn.rt;
0015 S = qn.nservers;
0016 
0017 <span class="keyword">for</span> j = 1:M
0018     <span class="comment">%Set number of servers in delay station = population</span>
0019     <span class="keyword">if</span> isinf(S(j))
0020         S(j) = N;
0021     <span class="keyword">end</span>
0022 <span class="keyword">end</span>
0023 
0024 <span class="comment">%% initialization</span>
0025 
0026 <span class="comment">% phases = zeros(M,K);</span>
0027 <span class="comment">% for j = 1:M</span>
0028 <span class="comment">%     for k = 1:K</span>
0029 <span class="comment">%         %phases(i,k,e) = length(Lambda{e,i,k});</span>
0030 <span class="comment">%         phases(j,k) = length(Lambda{j,k});</span>
0031 <span class="comment">%     end</span>
0032 <span class="comment">% end</span>
0033 phases = qn.phases;
0034 slowrate = zeros(M,K);
0035 <span class="keyword">for</span> j = 1:M
0036     <span class="keyword">for</span> k = 1:K
0037         slowrate(j,k) = Inf;
0038         slowrate(j,k) = min(slowrate(j,k),min(Lambda{j,k}(:))); <span class="comment">%service completion (exit) rates in each phase</span>
0039     <span class="keyword">end</span>
0040 <span class="keyword">end</span>
0041 
0042 <span class="comment">%% response time analysis - starting from fixed point found</span>
0043 stiff = 1;
0044 chains = qn.chains;
0045 nChains = size(chains,1);
0046 
0047 RT = [];
0048 <span class="keyword">for</span> i = 1:qn.nstations
0049     <span class="keyword">for</span> k = 1:nChains <span class="comment">%once for each chain</span>
0050         idxClassesInChain = find(chains(k,:)==1);
0051         <span class="keyword">for</span> c = idxClassesInChain
0052             Knew = K + 1;
0053             numTranClasses = Knew - K;
0054             idxTranCl = zeros(1,K); <span class="comment">% indices of the transient class corresponding to each class in the original model for class k</span>
0055             idxTranCl(chains(k,:)==1) =  K+1:Knew;
0056             newLambda = cell(M,Knew);
0057             newPi = cell(M,Knew);
0058             new_rt = zeros(M*Knew, M*Knew);
0059             
0060             <span class="comment">% service rates</span>
0061             newLambda(:,1:K) = Lambda(:,:);
0062             newLambda(:,K+1) = Lambda(:,c);
0063             
0064             <span class="comment">% completion probabilities</span>
0065             newPi(:,1:K) = Pi(:,:);
0066             newPi(:,K+1) = Pi(:,c);
0067             
0068             <span class="comment">% routing/switching probabilities</span>
0069             <span class="comment">% among basic classes</span>
0070             <span class="keyword">for</span> l = 1:K
0071                 <span class="keyword">for</span> m = 1:K
0072                     new_rt(l:Knew:<span class="keyword">end</span>,m:Knew:end) = rt(l:K:<span class="keyword">end</span>,m:K:end);
0073                 <span class="keyword">end</span>
0074             <span class="keyword">end</span>
0075             
0076             <span class="comment">% copy probabilities from the original to the transient classes (forward)</span>
0077             <span class="keyword">for</span> l = 1:numTranClasses
0078                 <span class="keyword">for</span> m = 1:numTranClasses
0079                     <span class="keyword">if</span> sum(sum(rt(c:K:<span class="keyword">end</span>,idxClassesInChain(m):K:end))) &gt; 0
0080                         new_rt(K+l:Knew:<span class="keyword">end</span>,K+m:Knew:end) = rt(c:K:<span class="keyword">end</span>,idxClassesInChain(m):K:end);
0081                     <span class="keyword">end</span>
0082                 <span class="keyword">end</span>
0083             <span class="keyword">end</span>
0084             
0085             <span class="comment">%phases of transient classes</span>
0086             newPhases = zeros(M,Knew);
0087             newPhases(:,1:K) = phases;
0088             newPhases(:,K+1) = phases(:,c);
0089             
0090             <span class="comment">% identify classes in chain that complete</span>
0091             completingClassesInChain = c;
0092             
0093             <span class="comment">%determine final classes (leaves in the class graph)</span>
0094             <span class="keyword">for</span> s = completingClassesInChain' <span class="comment">% for each completing class</span>
0095                 <span class="comment">%routing matrix from a transient class that completes is diverted back into the original classes</span>
0096                 <span class="keyword">for</span> l = idxClassesInChain
0097                     <span class="keyword">for</span> j = 1:qn.nstations
0098                         <span class="comment">% return fluid to original class</span>
0099                         new_rt((i-1)*Knew+idxTranCl(c), (j-1)*Knew+l) = rt((i-1)*K+c, (j-1)*K+l);
0100                         <span class="comment">% delete corresponding transition among transient classes</span>
0101                         new_rt((i-1)*Knew+idxTranCl(c), (j-1)*Knew+idxTranCl(l)) = 0;
0102                     <span class="keyword">end</span>
0103                 <span class="keyword">end</span>
0104             <span class="keyword">end</span>
0105             
0106             <span class="comment">%setup the ODEs for the new QN</span>
0107             [newOde_h, ~] = <a href="solver_fluid_odes.html" class="code" title="function [ode_h,q_indices] = solver_fluid_odes(N, Mu, Phi, P, S, sched, schedparam)">solver_fluid_odes</a>(N, reshape({newLambda{:,:}},M,Knew), reshape({newPi{:,:}},M,Knew), new_rt, S, qn.sched);
0108             
0109             newY0 = zeros(1, sum(sum(newPhases(:,:))));
0110             newFluid = 0;
0111             <span class="keyword">for</span> j = 1:qn.nstations
0112                 <span class="keyword">for</span> l = 1:qn.nclasses
0113                     idxNew_jl = sum(sum(newPhases(1:j-1,:))) + sum(newPhases(j,1:l-1));
0114                     idxNew_jt = sum(sum(newPhases(1:j-1,:))) + sum(newPhases(j,1:idxTranCl(l)-1));
0115                     idx_jl = sum(sum(phases(1:j-1,:))) + sum(phases(j,1:l-1));
0116                     <span class="keyword">if</span> i == j &amp;&amp; l==c
0117                         newY0( idxNew_jt + 1 ) = sum(y0(idx_jl+1:idx_jl + phases(j,l))); <span class="comment">% mass in phases all moved back into phase 1</span>
0118                         newFluid = newFluid + sum(y0(idx_jl+1:idx_jl + phases(j,l)));
0119                     <span class="keyword">else</span> <span class="comment">% leave mass as it is</span>
0120                         newY0( idxNew_jl + 1: idxNew_jl + newPhases(j,l)  ) = y0(idx_jl+1:idx_jl + phases(j,l));
0121                     <span class="keyword">end</span>
0122                 <span class="keyword">end</span>
0123             <span class="keyword">end</span>
0124             
0125             iters = 0;
0126             iters = iters + 1;
0127             nonZeroRates = slowrate(:);
0128             nonZeroRates = nonZeroRates( nonZeroRates &gt;0 );
0129             T = abs(100/min(nonZeroRates)); <span class="comment">% solve ode until T = 100 events with slowest exit rate</span>
0130             
0131             <span class="comment">%indices new classes in all stations but delay</span>
0132             idxN = [];
0133             <span class="keyword">for</span> j = i
0134                 idxN = [idxN sum(sum(newPhases(1:j-1,: ) )) + sum(newPhases(j,1:K)) + [1:sum(newPhases(j,K+1:Knew))] ]; <span class="comment">%works for</span>
0135             <span class="keyword">end</span>
0136             
0137             <span class="comment">%% ODE analysis</span>
0138             fullt = [];
0139             fully = [];
0140             iter = 1;
0141             finished = 0;
0142             tref = 0;
0143             <span class="keyword">while</span> iter &lt;= iter_max &amp;&amp; finished == 0
0144                 <span class="comment">% solve ode - yt_e is the transient solution in stage e</span>
0145                 opt = odeset(<span class="string">'AbsTol'</span>, options.tol, <span class="string">'RelTol'</span>, options.tol, <span class="string">'NonNegative'</span>, 1:length(newY0),<span class="string">'Events'</span>,@<a href="#_sub1" class="code" title="subfunction [value,isterminal,direction] = events(t,y)">events</a>);
0146                 <span class="keyword">if</span> options.stiff
0147                     <span class="keyword">if</span> options.tol &lt; 1e-3
0148                         [t, yt_e] = feval(options.odesolvers.accurateStiffOdeSolver, newOde_h, [0 T], newY0, opt);
0149                     <span class="keyword">else</span>
0150                         [t, yt_e] = feval(options.odesolvers.fastStiffOdeSolver, newOde_h, [0 T], newY0, opt);
0151                     <span class="keyword">end</span>
0152                 <span class="keyword">else</span>
0153                     <span class="keyword">if</span> options.tol &lt; 1e-3
0154                         [t, yt_e] = feval(options.odesolvers.accurateOdeSolver, newOde_h, [0 T], newY0, opt);
0155                     <span class="keyword">else</span>
0156                         opt = odeset(<span class="string">'AbsTol'</span>, 1e-6, <span class="string">'RelTol'</span>, 1e-3,<span class="string">'Events'</span>,@<a href="#_sub1" class="code" title="subfunction [value,isterminal,direction] = events(t,y)">events</a>);
0157                         [t, yt_e] = feval(options.odesolvers.fastOdeSolver, newOde_h, [0 T], newY0, opt);
0158                     <span class="keyword">end</span>
0159                 <span class="keyword">end</span>
0160                 iter = iter + 1;
0161                 fullt = [fullt; t+tref];
0162                 fully = [fully; yt_e];
0163                 <span class="keyword">if</span> sum(yt_e(<span class="keyword">end</span>,idxN )) &lt; 10e-10
0164                     finished = 1;
0165                 <span class="keyword">end</span>
0166                 tref = tref + t(end);
0167                 newY0 = yt_e(<span class="keyword">end</span>,:);
0168             <span class="keyword">end</span>
0169             <span class="comment">% retrieve response time CDF for class k</span>
0170             RT{i,c,1} = fullt;
0171             <span class="keyword">if</span> newFluid &gt; 0
0172                 RT{i,c,2} = 1 - sum(fully(:,idxN ),2)/newFluid;
0173             <span class="keyword">else</span>
0174                 RT{i,c,2} = ones(size(fullt));
0175             <span class="keyword">end</span>
0176             <span class="keyword">if</span> iter &gt; iter_max
0177                 warning(<span class="string">'Maximum number of iterations reached when computing the response time distribution. Response time distributions may be inaccurate. Increase option.iter_max (currently at %s).'</span>,num2str(iter_max));
0178             <span class="keyword">end</span>
0179         <span class="keyword">end</span>
0180     <span class="keyword">end</span>
0181 <span class="keyword">end</span>
0182 
0183 RTret = {};
0184 <span class="keyword">for</span> i=1:qn.nstations
0185     <span class="keyword">for</span> c=1:qn.nclasses
0186         RTret{i,c} = [RT{i,c,2},RT{i,c,1}];
0187     <span class="keyword">end</span>
0188 <span class="keyword">end</span>
0189 <span class="keyword">return</span>
0190 
0191     <a name="_sub1" href="#_subfunctions" class="code">function [value,isterminal,direction] = events(t,y)</a>
0192         value = sum(y(idxN));
0193         isterminal = 1;
0194         direction = 0;
0195     <span class="keyword">end</span>
0196 
0197 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>