<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_fluid_SysRespT</title>
  <meta name="keywords" content="solver_fluid_SysRespT">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">Fluid</a> &gt; solver_fluid_SysRespT.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\Fluid&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_fluid_SysRespT
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function RTret = solver_fluid_sysrespt(qn, RTrange, options, completes) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="solver_fluid_odes.html" class="code" title="function [ode_h,q_indices] = solver_fluid_odes(N, Mu, Phi, P, S, sched, schedparam)">solver_fluid_odes</a>	Copyright (c) 2012-2019, Imperial College London</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [value,isterminal,direction] = events(t,y)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function RTret = solver_fluid_sysrespt(qn, RTrange, options, completes)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 
0006 iter_max = options.iter_max;
0007 verbose = options.verbose;
0008 y0 = options.init_sol;
0009 
0010 M = qn.nstations;    <span class="comment">%number of stations</span>
0011 K = qn.nclasses;    <span class="comment">%number of classes</span>
0012 N = qn.nclosedjobs;    <span class="comment">%population</span>
0013 Lambda = qn.mu;
0014 Pi = qn.phi;
0015 rt = qn.rt;
0016 S = qn.nservers;
0017 
0018 <span class="keyword">for</span> j = 1:M
0019     <span class="comment">%Set number of servers in delay station = population</span>
0020     <span class="keyword">if</span> isinf(S(j))
0021         S(j) = N;
0022     <span class="keyword">end</span>
0023 <span class="keyword">end</span>
0024 
0025 <span class="comment">%% initialization</span>
0026 
0027 phases = zeros(M,K);
0028 <span class="keyword">for</span> j = 1:M
0029     <span class="keyword">for</span> k = 1:K
0030         <span class="comment">%phases(i,k,e) = length(Lambda{e,i,k});</span>
0031         phases(j,k) = length(Lambda{j,k});
0032     <span class="keyword">end</span>
0033 <span class="keyword">end</span>
0034 slowrate = zeros(M,K);
0035 <span class="keyword">for</span> j = 1:M
0036     <span class="keyword">for</span> k = 1:K
0037         slowrate(j,k) = Inf;
0038         slowrate(j,k) = min(slowrate(j,k),min(Lambda{j,k}(:))); <span class="comment">%service completion (exit) rates in each phase</span>
0039     <span class="keyword">end</span>
0040 <span class="keyword">end</span>
0041 
0042 <span class="comment">%% response time analysis - starting from fixed point found</span>
0043 stiff = 1;
0044 chains = qn.chains;
0045 nChains = size(chains,1);
0046 
0047 RT = cell(nChains,2);
0048 <span class="keyword">for</span> k = 1:nChains <span class="comment">%once for each chain</span>
0049     idxClassesInChain = find(chains(k,:)==1);
0050     refStat = qn.refstat(idxClassesInChain(1));
0051     Knew = K + sum(chains(k,:),2);
0052     numTranClasses = Knew - K;
0053     idxTranCl = zeros(1,K); <span class="comment">% indices of the transient class corresponding to each class in the original model for class k</span>
0054     idxTranCl(chains(k,:)==1) =  K+1:Knew;
0055     newLambda = cell(M,Knew);
0056     newPi = cell(M,Knew);
0057     new_rt = zeros(M*Knew, M*Knew);
0058     
0059     <span class="comment">% service rates</span>
0060     newLambda(:,1:K) = Lambda(:,:);
0061     <span class="keyword">for</span> l = 1:numTranClasses
0062         newLambda(:,K+l) = Lambda(:,idxClassesInChain(l));
0063     <span class="keyword">end</span>
0064     
0065     <span class="comment">% completion probabilities</span>
0066     newPi(:,1:K) = Pi(:,:);
0067     <span class="keyword">for</span> l = 1:numTranClasses
0068         newPi(:,K+l) = Pi(:,idxClassesInChain(l));
0069     <span class="keyword">end</span>
0070     
0071     <span class="comment">% routing/switching probabilities</span>
0072     <span class="comment">% among basic classes</span>
0073     <span class="keyword">for</span> l = 1:K
0074         <span class="keyword">for</span> m = 1:K
0075             new_rt(l:Knew:<span class="keyword">end</span>,m:Knew:end) = rt(l:K:<span class="keyword">end</span>,m:K:end);
0076         <span class="keyword">end</span>
0077     <span class="keyword">end</span>
0078     
0079     <span class="comment">% copy probabilities from the original to the transient classes (forward)</span>
0080     <span class="keyword">for</span> l = 1:numTranClasses
0081         <span class="keyword">for</span> m = 1:numTranClasses
0082             <span class="keyword">if</span> sum(sum(rt(idxClassesInChain(l):K:<span class="keyword">end</span>,idxClassesInChain(m):K:end))) &gt; 0
0083                 new_rt(K+l:Knew:<span class="keyword">end</span>,K+m:Knew:end) = rt(idxClassesInChain(l):K:<span class="keyword">end</span>,idxClassesInChain(m):K:end);
0084             <span class="keyword">end</span>
0085         <span class="keyword">end</span>   
0086     <span class="keyword">end</span>
0087     
0088     <span class="comment">%phases of transient classes</span>
0089     newPhases = zeros(M,Knew);
0090     newPhases(:,1:K) = phases;
0091     <span class="keyword">for</span> l = 1:numTranClasses
0092         newPhases(:,K+l) = phases(:,idxClassesInChain(l));
0093     <span class="keyword">end</span>
0094     
0095     <span class="comment">% identify classes in chain that complete</span>
0096     completingClassesInChain = find(completes)';        
0097     
0098     <span class="comment">%determine final classes (leaves in the class graph)</span>
0099     <span class="keyword">for</span> s = completingClassesInChain' <span class="comment">% for each completing class</span>
0100         <span class="comment">%routing matrix from a transient class that completes is diverted back into the original classes</span>
0101         <span class="keyword">for</span> l = idxClassesInChain            
0102             rt_ls = rt(l:K:<span class="keyword">end</span>,s:K:end);               
0103             feedsRefStat = find(rt_ls(:,refStat)&gt;0)'; <span class="comment">% stations with transitions class l -&gt; class s to ref node</span>
0104             <span class="keyword">for</span> j = feedsRefStat
0105                 <span class="comment">% return fluid to original class</span>
0106                 new_rt((j-1)*Knew+idxTranCl(l), (refStat-1)*Knew+s) = rt((j-1)*K+l, (refStat-1)*K+s);                
0107                 <span class="comment">% delete corresponding transition among transient classes</span>
0108                 new_rt((j-1)*Knew+idxTranCl(l), (refStat-1)*Knew+idxTranCl(s)) = 0;                
0109             <span class="keyword">end</span>
0110         <span class="keyword">end</span>
0111     <span class="keyword">end</span>
0112     
0113     <span class="comment">%setup the ODEs for the new QN</span>
0114     [newOde_h, ~] = <a href="solver_fluid_odes.html" class="code" title="function [ode_h,q_indices] = solver_fluid_odes(N, Mu, Phi, P, S, sched, schedparam)">solver_fluid_odes</a>(N, reshape({newLambda{:,:}},M,Knew), reshape({newPi{:,:}},M,Knew), new_rt, S, qn.sched);
0115         
0116     stationsAfterRefStat = []; <span class="comment">% list of output stations when moving out of ref node</span>
0117     <span class="keyword">for</span> s = idxClassesInChain
0118         <span class="keyword">for</span> l = idxClassesInChain
0119             <span class="keyword">for</span> i=1:M
0120                 <span class="keyword">if</span> rt((refStat-1)*K + s, (i-1)*K + l) &gt; 0 &amp;&amp; ismember(l, completingClassesInChain)
0121                     stationsAfterRefStat = [stationsAfterRefStat, i];
0122                 <span class="keyword">end</span>
0123             <span class="keyword">end</span>
0124         <span class="keyword">end</span>
0125     <span class="keyword">end</span>
0126     
0127     newY0 = zeros(1, sum(sum(newPhases(:,:))));
0128     newFluid = 0;
0129     <span class="keyword">for</span> j = 1:M
0130         <span class="keyword">for</span> l = 1:K
0131             idxNew_jl = sum(sum(newPhases(1:j-1,:))) + sum(newPhases(j,1:l-1));
0132             idxNew_jt = sum(sum(newPhases(1:j-1,:))) + sum(newPhases(j,1:idxTranCl(l)-1));            
0133             idx_jl = sum(sum(phases(1:j-1,:))) + sum(phases(j,1:l-1));
0134             <span class="keyword">if</span> ismember(j,stationsAfterRefStat) &amp;&amp; ismember(l,idxClassesInChain) &amp;&amp; ismember(l, completingClassesInChain)
0135                 newY0( idxNew_jt + 1: idxNew_jt + newPhases(j,idxTranCl(l))  ) = y0(idx_jl+1:idx_jl + phases(j,l)); 
0136                 newFluid = newFluid + sum(y0(idx_jl+1:idx_jl + phases(j,l)));
0137             <span class="keyword">else</span> <span class="comment">% leave mass as it is</span>
0138                 newY0( idxNew_jl + 1: idxNew_jl + newPhases(j,l)  ) = y0(idx_jl+1:idx_jl + phases(j,l));
0139             <span class="keyword">end</span>
0140         <span class="keyword">end</span>
0141     <span class="keyword">end</span>
0142     y0
0143     newY0
0144     
0145     iters = 0;
0146     iters = iters + 1;
0147     RTtemp = cell (1,2);
0148     nonZeroRates = slowrate(:);
0149     nonZeroRates = nonZeroRates( nonZeroRates &gt;0 );
0150     T = abs(100/min(nonZeroRates)); <span class="comment">% solve ode until T = 100 events with slowest exit rate</span>
0151     
0152     <span class="comment">%indices new classes in all stations but delay</span>
0153     idxN = [];
0154     <span class="keyword">for</span> j = 1:M
0155         <span class="keyword">if</span> j ~= refStat
0156             idxN = [idxN sum(sum(newPhases(1:j-1,: ) )) + sum(newPhases(j,1:K)) + [1:sum(newPhases(j,K+1:Knew))] ]; <span class="comment">%works for</span>
0157         <span class="keyword">end</span>
0158     <span class="keyword">end</span>
0159     
0160     <span class="comment">%% ODE analysis</span>
0161     fullt = [];
0162     fully = [];
0163     iter = 1;
0164     finished = 0;
0165     tref = 0;
0166     <span class="keyword">while</span> iter &lt;= iter_max &amp;&amp; finished == 0
0167         <span class="comment">% solve ode - yt_e is the transient solution in stage e</span>
0168         opt = odeset(<span class="string">'AbsTol'</span>, options.tol, <span class="string">'RelTol'</span>, options.tol, <span class="string">'NonNegative'</span>, 1:length(newY0),<span class="string">'Events'</span>,@<a href="#_sub1" class="code" title="subfunction [value,isterminal,direction] = events(t,y)">events</a>);
0169         <span class="keyword">if</span> options.stiff
0170             <span class="keyword">if</span> options.tol &lt; 1e-3
0171                 [t, yt_e] = feval(options.odesolvers.accurateStiffOdeSolver, newOde_h, [0 T], newY0, opt);
0172             <span class="keyword">else</span>
0173                 [t, yt_e] = feval(options.odesolvers.fastStiffOdeSolver, newOde_h, [0 T], newY0, opt);
0174             <span class="keyword">end</span>
0175         <span class="keyword">else</span>
0176             <span class="keyword">if</span> options.tol &lt; 1e-3
0177                 [t, yt_e] = feval(options.odesolvers.accurateOdeSolver, newOde_h, [0 T], newY0, opt);
0178             <span class="keyword">else</span>
0179                 opt = odeset(<span class="string">'AbsTol'</span>, 1e-6, <span class="string">'RelTol'</span>, 1e-3,<span class="string">'Events'</span>,@<a href="#_sub1" class="code" title="subfunction [value,isterminal,direction] = events(t,y)">events</a>);
0180                 [t, yt_e] = feval(options.odesolvers.fastOdeSolver, newOde_h, [0 T], newY0, opt);
0181             <span class="keyword">end</span>
0182         <span class="keyword">end</span>
0183         iter = iter + 1;
0184         fullt = [fullt; t+tref];
0185         fully = [fully; yt_e];
0186         <span class="keyword">if</span> sum(yt_e(<span class="keyword">end</span>,idxN )) &lt; 10e-10
0187             finished = 1;
0188         <span class="keyword">end</span>
0189         tref = tref + t(end);
0190         newY0 = yt_e(<span class="keyword">end</span>,:);
0191     <span class="keyword">end</span>
0192     <span class="comment">% retrieve response time CDF for class k</span>
0193     RT{k,1} = fullt;
0194     <span class="keyword">if</span> newFluid &gt; 0
0195         RT{k,2} = 1 - sum(fully(:,idxN ),2)/newFluid;
0196     <span class="keyword">else</span>
0197         RT{k,2} = ones(size(fullt));
0198     <span class="keyword">end</span>
0199     <span class="keyword">if</span> iter &gt; iter_max
0200         warning(<span class="string">'Maximum number of iterations reached when computing the response time distribution.\n Response time distributions may be affected numerically'</span>);
0201     <span class="keyword">end</span>
0202     <span class="keyword">if</span> verbose &gt; 1
0203         a = ( RT{k,2}(1:end-1) + RT{k,2}(2:end) )/2;
0204         meanRT = sum(diff(RT{k,1}).*(1-a));
0205         disp([<span class="string">'Mean response time class '</span>, int2str(k),<span class="string">': '</span>, num2str(meanRT)]);
0206     <span class="keyword">end</span>
0207     <span class="comment">% determine the value of the  percentiles requested (RTrange)</span>
0208     <span class="keyword">if</span> ~isempty(RTrange) &amp;&amp; RTrange(1) &gt;=0 &amp;&amp; RTrange(end) &lt;=1
0209         <span class="keyword">if</span> newFluid &gt; 0
0210             percRT = interp1q(RT{k,2}, RT{k,1}, RTrange);
0211         <span class="keyword">else</span>
0212             percRT = zeros(size(RTrange));
0213         <span class="keyword">end</span>
0214         RT{k,1} = percRT;
0215         RT{k,2} = RTrange;
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 
0219 RTret = {};
0220 <span class="keyword">for</span> k=1:size(RT,1)
0221     RTret{k} = [RT{k,2},RT{k,1}];
0222 <span class="keyword">end</span>
0223 <span class="keyword">return</span>
0224 
0225     <a name="_sub1" href="#_subfunctions" class="code">function [value,isterminal,direction] = events(t,y)</a>
0226         value = sum(y(idxN));
0227         isterminal = 1;
0228         direction = 0;
0229     <span class="keyword">end</span>
0230 
0231 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>