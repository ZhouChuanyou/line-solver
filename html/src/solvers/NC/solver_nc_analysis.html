<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of solver_nc_analysis</title>
  <meta name="keywords" content="solver_nc_analysis">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">NC</a> &gt; solver_nc_analysis.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\NC&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>solver_nc_analysis
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [Q,U,R,T,C,X,lG,runtime] = solver_nc_analysis(qn, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SolverNC.html" class="code" title="">SolverNC</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [Q,U,R,T,C,X,lG,runtime] = solver_nc_analysis(qn, options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 M = qn.nstations;    <span class="comment">%number of stations</span>
0006 S = qn.nservers;
0007 NK = qn.njobs';  <span class="comment">% initial population per class</span>
0008 sched = qn.sched;
0009 <span class="comment">%chains = qn.chains;</span>
0010 C = qn.nchains;
0011 SCV = qn.scv;
0012 ST = 1 ./ qn.rates;
0013 ST(isnan(ST))=0;
0014 ST0=ST;
0015 
0016 alpha = zeros(qn.nstations,qn.nclasses);
0017 Vchain = zeros(qn.nstations,qn.nchains);
0018 <span class="keyword">for</span> c=1:qn.nchains
0019     inchain = find(qn.chains(c,:));
0020     <span class="keyword">for</span> i=1:qn.nstations
0021         Vchain(i,c) = sum(qn.visits{c}(i,inchain)) / sum(qn.visits{c}(qn.refstat(inchain(1)),inchain));
0022         <span class="keyword">for</span> k=inchain
0023             alpha(i,k) = alpha(i,k) + qn.visits{c}(i,k) / sum(qn.visits{c}(i,inchain));
0024         <span class="keyword">end</span>
0025     <span class="keyword">end</span>
0026 <span class="keyword">end</span>
0027 Vchain(~isfinite(Vchain))=0;
0028 alpha(~isfinite(alpha))=0;
0029 alpha(alpha&lt;1e-12)=0;
0030 eta_1 = zeros(1,M);
0031 eta = ones(1,M);
0032 <span class="keyword">if</span> findstring(sched,<span class="string">'fcfs'</span>) == -1, options.iter_max=1; <span class="keyword">end</span>
0033 it = 0;
0034 <span class="keyword">while</span> max(abs(1-eta./eta_1)) &gt; options.iter_tol &amp;&amp; it &lt;= options.iter_max
0035     it = it + 1;
0036     eta_1 = eta;
0037     M = qn.nstations;    <span class="comment">%number of stations</span>
0038     K = qn.nclasses;    <span class="comment">%number of classes</span>
0039     C = qn.nchains;
0040     Lchain = zeros(M,C);
0041     STchain = zeros(M,C);
0042     
0043     SCVchain = zeros(M,C);
0044     Nchain = zeros(1,C);
0045     refstatchain = zeros(C,1);
0046     <span class="keyword">for</span> c=1:C
0047         inchain = find(qn.chains(c,:));
0048         isOpenChain = any(isinf(qn.njobs(inchain)));
0049         <span class="keyword">for</span> i=1:M
0050             <span class="comment">% we assume that the visits in L(i,inchain) are equal to 1</span>
0051             Lchain(i,c) = Vchain(i,c) * ST(i,inchain) * alpha(i,inchain)';
0052             STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0053             <span class="keyword">if</span> isOpenChain &amp;&amp; i == qn.refstat(inchain(1)) <span class="comment">% if this is a source ST = 1 / arrival rates</span>
0054                 STchain(i,c) = sumfinite(ST(i,inchain)); <span class="comment">% ignore degenerate classes with zero arrival rates</span>
0055             <span class="keyword">else</span>
0056                 STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0057             <span class="keyword">end</span>
0058             SCVchain(i,c) = SCV(i,inchain) * alpha(i,inchain)';
0059         <span class="keyword">end</span>
0060         Nchain(c) = sum(NK(inchain));
0061         refstatchain(c) = qn.refstat(inchain(1));
0062         <span class="keyword">if</span> any((qn.refstat(inchain(1))-refstatchain(c))~=0)
0063             error(<span class="string">'Classes in chain %d have different reference station.'</span>,c);
0064         <span class="keyword">end</span>
0065     <span class="keyword">end</span>
0066     STchain(~isfinite(STchain))=0;
0067     Lchain(~isfinite(Lchain))=0;
0068     Tstart = tic;
0069     Nt = sum(Nchain(isfinite(Nchain)));
0070     
0071     Lcorr = zeros(M,C);
0072     Z = zeros(M,C);
0073     Zcorr = zeros(M,C);
0074     infServers = [];
0075     <span class="keyword">for</span> i=1:M
0076         <span class="keyword">if</span> isinf(S(i)) <span class="comment">% infinite server</span>
0077             <span class="comment">%mu_chain(i,1:sum(Nchain)) = 1:sum(Nchain);</span>
0078             infServers(end+1) = i;
0079             Lcorr(i,:) = 0;
0080             Z(i,:) = Lchain(i,:);
0081             Zcorr(i,:) = 0;
0082         <span class="keyword">else</span>
0083             <span class="keyword">if</span> strcmpi(options.method,<span class="string">'exact'</span>) &amp;&amp; S(i)&gt;1
0084                 warning(<span class="string">'%s does not support exact multiserver yet. Switching to default method.'</span>, mfilename); 
0085             <span class="keyword">end</span>
0086             Lcorr(i,:) = Lchain(i,:) / S(i);
0087             Z(i,:) = 0;
0088             Zcorr(i,:) = Lchain(i,:) * (S(i)-1)/S(i);
0089         <span class="keyword">end</span>
0090     <span class="keyword">end</span>
0091     Qchain = zeros(M,C);
0092     
0093     <span class="comment">% step 1</span>
0094     lG = pfqn_nc(Lcorr,Nchain,sum(Z,1)+sum(Zcorr,1), options);
0095     
0096     <span class="comment">% step 2 - reduce the artificial think time</span>
0097     <span class="keyword">if</span> any(S(isfinite(S)) &gt; 1)
0098         Xchain = zeros(1,C);
0099         <span class="keyword">for</span> r=1:C <span class="comment">% we need the utilizations in step 2 so we determine tput</span>
0100             Xchain(r) = exp(pfqn_nc(Lcorr,oner(Nchain,r),sum(Z,1)+sum(Zcorr,1), options) - lG);
0101         <span class="keyword">end</span>
0102         <span class="keyword">for</span> i=1:M
0103             <span class="keyword">if</span> isinf(S(i)) <span class="comment">% infinite server</span>
0104                 <span class="comment">% do nothing</span>
0105             <span class="keyword">else</span>
0106                 Zcorr(i,:) = max([0,(1-(Xchain*Lchain(i,:)'/S(i))^S(i))]) * Lchain(i,:) * (S(i)-1)/S(i);
0107             <span class="keyword">end</span>
0108         <span class="keyword">end</span>
0109         lG = pfqn_nc(Lcorr,Nchain,sum(Z,1)+sum(Zcorr,1), options); <span class="comment">% update lG</span>
0110     <span class="keyword">end</span>
0111     
0112     <span class="keyword">for</span> r=1:C
0113         lGr(r) = pfqn_nc(Lcorr,oner(Nchain,r),sum(Z,1)+sum(Zcorr,1), options);
0114         Xchain(r) = exp(lGr(r) - lG);
0115         <span class="keyword">for</span> i=1:M
0116             <span class="keyword">if</span> Lchain(i,r)&gt;0
0117                 <span class="keyword">if</span> isinf(S(i)) <span class="comment">% infinite server</span>
0118                     Qchain(i,r) = Lchain(i,r) * Xchain(r);
0119                 <span class="keyword">else</span>
0120                     lGar(i,r) = pfqn_nc([Lcorr(setdiff(1:size(Lcorr,1),i),:),zeros(size(Lcorr,1)-1,1); Lcorr(i,:),1], [oner(Nchain,r),1], [sum(Z,1)+sum(Zcorr,1),0], options);
0121                     Qchain(i,r) = Zcorr(i,r) * Xchain(r) + Lcorr(i,r) * exp(lGar(i,r) - lG);
0122                 <span class="keyword">end</span>
0123             <span class="keyword">end</span>
0124         <span class="keyword">end</span>
0125     <span class="keyword">end</span>
0126     <span class="keyword">if</span> isnan(Xchain)
0127 <span class="comment">%        Z</span>
0128 <span class="comment">%        Zcorr</span>
0129 <span class="comment">%        Lcorr,Nchain,sum(Z,1)+sum(Zcorr,1)</span>
0130 <span class="comment">%        lG</span>
0131 <span class="comment">%        lGr</span>
0132 <span class="comment">%        lGar</span>
0133         error(<span class="string">'Normalizing constant computations produced a floating-point range exception. Model is likely too large.'</span>);
0134     <span class="keyword">end</span>
0135     
0136     Z = sum(Z(1:M,:),1);
0137     
0138     Rchain = Qchain ./ repmat(Xchain,M,1) ./ Vchain;
0139     Rchain(infServers,:) = Lchain(infServers,:) ./ Vchain(infServers,:);
0140     Tchain = repmat(Xchain,M,1) .* Vchain;
0141     Uchain = Tchain .* Lchain;
0142     Cchain = Nchain ./ Xchain - Z;
0143     
0144     Xchain(~isfinite(Xchain))=0;
0145     Uchain(~isfinite(Uchain))=0;
0146     Qchain(~isfinite(Qchain))=0;
0147     Rchain(~isfinite(Rchain))=0;
0148     
0149     Xchain(Nchain==0)=0;
0150     Uchain(:,Nchain==0)=0;
0151     Qchain(:,Nchain==0)=0;
0152     Rchain(:,Nchain==0)=0;
0153     Tchain(:,Nchain==0)=0;
0154     
0155     
0156     <span class="keyword">for</span> c=1:qn.nchains
0157         inchain = find(qn.chains(c,:));
0158         <span class="keyword">for</span> k=inchain(:)'
0159             X(k) = Xchain(c) * alpha(qn.refstat(k),k);
0160             <span class="keyword">for</span> i=1:qn.nstations
0161                 <span class="keyword">if</span> isinf(S(i))
0162                     U(i,k) = ST(i,k) * (Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c)) * alpha(i,k);
0163                 <span class="keyword">else</span>
0164                     U(i,k) = ST(i,k) * (Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c)) * alpha(i,k) / S(i);
0165                 <span class="keyword">end</span>
0166                 <span class="keyword">if</span> Lchain(i,c) &gt; 0
0167                     Q(i,k) = Rchain(i,c) * ST(i,k) / STchain(i,c) * Xchain(c) * Vchain(i,c) / Vchain(qn.refstat(k),c) * alpha(i,k);
0168                     T(i,k) = Tchain(i,c) * alpha(i,k);
0169                     R(i,k) = Q(i,k) / T(i,k);
0170                     <span class="comment">%                R(i,k) = Rchain(i,c) * ST(i,k) / STchain(i,c) * alpha(i,k) / sum(alpha(qn.refstat(k),inchain)');</span>
0171                 <span class="keyword">else</span>
0172                     T(i,k) = 0;
0173                     
0174                     R(i,k)=0;
0175                     Q(i,k)=0;
0176                 <span class="keyword">end</span>
0177             <span class="keyword">end</span>
0178             C(k) = qn.njobs(k) / X(k);
0179         <span class="keyword">end</span>
0180     <span class="keyword">end</span>
0181     
0182     <span class="keyword">for</span> i=1:M
0183         sd = ST0(i,:)&gt;0;
0184         <span class="keyword">switch</span> sched{i}
0185             <span class="keyword">case</span> <span class="string">'fcfs'</span>
0186                 <span class="keyword">if</span> range(ST0(i,sd))&gt;0 <span class="comment">% check if non-product-form</span>
0187                     rho(i) = sum(U(i,:)); <span class="comment">% true utilization of each server</span>
0188                     ca = 0;
0189                     <span class="keyword">for</span> j=1:M
0190                         <span class="keyword">for</span> r=1:K
0191                             <span class="keyword">if</span> ST0(j,r)&gt;0
0192                                 <span class="keyword">for</span> s=1:K
0193                                     <span class="keyword">if</span> ST0(i,s)&gt;0
0194                                         pji_rs = qn.rt((i-1)*qn.nclasses + r, (j-1)*qn.nclasses + s);
0195                                         ca = ca + SCV(j,r)*T(j,r)*pji_rs/sum(T(i,sd));
0196                                     <span class="keyword">end</span>
0197                                 <span class="keyword">end</span>
0198                             <span class="keyword">end</span>
0199                         <span class="keyword">end</span>
0200                     <span class="keyword">end</span>
0201                     cs = (SCV(i,sd)*T(i,sd)')/sum(T(i,sd));
0202                     <span class="comment">% asymptotic decay rate (diffusion approximation, Kobayashi JACM)</span>
0203                     eta(i) = exp(-2*(1-rho(i))/(cs+ca*rho(i)));
0204                 <span class="keyword">end</span>
0205         <span class="keyword">end</span>
0206     <span class="keyword">end</span>
0207     
0208     <span class="keyword">for</span> i=1:M
0209         <span class="keyword">switch</span> sched{i}
0210             <span class="keyword">case</span> <span class="string">'fcfs'</span>
0211                 <span class="keyword">if</span> range(ST0(i,sd))&gt;0 <span class="comment">% check if non-product-form</span>
0212                     <span class="keyword">for</span> k=1:K
0213                         <span class="keyword">if</span> sum(Q(i,ST(i,:)&gt;0)) &lt; S(i)
0214                             <span class="keyword">if</span> ST0(i,k)&gt;0
0215                                 ST(i,k) = ST0(i,k);
0216                             <span class="keyword">end</span>
0217                         <span class="keyword">else</span>
0218                             <span class="keyword">if</span> ST0(i,k)&gt;0
0219                                 ST(i,k) = eta(i)*S(i)/sum(T(i,sd));
0220                             <span class="keyword">end</span>
0221                         <span class="keyword">end</span>
0222                     <span class="keyword">end</span>
0223                 <span class="keyword">end</span>
0224         <span class="keyword">end</span>
0225     <span class="keyword">end</span>
0226 <span class="keyword">end</span>
0227 runtime = toc(Tstart);
0228 Q=abs(Q); R=abs(R); X=abs(X); U=abs(U);
0229 
0230 X(~isfinite(X))=0; U(~isfinite(U))=0; Q(~isfinite(Q))=0; R(~isfinite(R))=0;
0231 <span class="keyword">if</span> options.verbose &gt; 0
0232     fprintf(1,<span class="string">'NC analysis completed in %f sec\n'</span>,runtime);
0233 <span class="keyword">end</span>
0234 <span class="keyword">return</span>
0235 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>