<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SolverLN</title>
  <meta name="keywords" content="SolverLN">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">LN</a> &gt; SolverLN.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\solvers\LN&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>SolverLN
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SolverLN.html" class="code" title="">SolverLN</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="SolverLN.html" class="code" title="">SolverLN</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function self = SolverLN(model,solverFactory,varargin)</a></li><li><a href="#_sub2" class="code">function bool = converged(self, it)</a></li><li><a href="#_sub3" class="code">function init(self)</a></li><li><a href="#_sub4" class="code">function pre(self, it)</a></li><li><a href="#_sub5" class="code">function [result, runtime] = analyze(self, it, e)</a></li><li><a href="#_sub6" class="code">function post(self, it)</a></li><li><a href="#_sub7" class="code">function finish(self)</a></li><li><a href="#_sub8" class="code">function [QN,UN,RN,TN] = getAvg(self,~,~,~,~)</a></li><li><a href="#_sub9" class="code">function [bool, featSupported] = supports(model)</a></li><li><a href="#_sub10" class="code">function options = defaultOptions(self)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="SolverLN.html" class="code" title="">SolverLN</a> &lt; LayeredNetworkSolver &amp; EnsembleSolver
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004     
0005     properties
0006     <span class="keyword">end</span>
0007     
0008     methods
0009         <a name="_sub0" href="#_subfunctions" class="code">function self = SolverLN(model,solverFactory,varargin)</a>
0010             self = self@LayeredNetworkSolver(model, mfilename);
0011             self@EnsembleSolver(model, mfilename);
0012             self.setOptions(Solver.parseOptions(varargin, self.defaultOptions));
0013             self.model.initDefault;
0014             self.ensemble = self.model.getEnsemble();
0015             <span class="keyword">for</span> e=1:self.getNumberOfModels
0016                 self.setSolver(solverFactory(self.ensemble{e}),e);
0017             <span class="keyword">end</span>
0018         <span class="keyword">end</span>
0019         
0020         <a name="_sub1" href="#_subfunctions" class="code">function bool = converged(self, it) </a><span class="comment">% convergence test at iteration it</span>
0021             bool = false;
0022             <span class="keyword">if</span> it&gt;1
0023                 maxIterErr = 0;
0024                 <span class="keyword">for</span> e=1:size(self.results,2)
0025                     maxIterErr = max([maxIterErr, nanmax(abs(1 - self.results{<span class="keyword">end</span>,e}.RespT ./ self.results{end-1,e}.RespT))]);
0026                 <span class="keyword">end</span>
0027                 <span class="comment">%                maxIterErr</span>
0028                 <span class="keyword">if</span> it &gt; 1 &amp;&amp; self.options.verbose == 2
0029                     fprintf(1, sprintf(<span class="string">'\nSolverLN error is: %f'</span>,maxIterErr));
0030                 <span class="keyword">end</span>
0031                 <span class="keyword">if</span> maxIterErr &lt; 1e-5 &amp;&amp; self.options.verbose
0032                     fprintf(1, sprintf(<span class="string">'\nSolverLN completed in %d iterations.\n'</span>,size(self.results,2)));
0033                     bool = true;
0034                 <span class="keyword">end</span>
0035             <span class="keyword">end</span>
0036         <span class="keyword">end</span>
0037         
0038         <a name="_sub2" href="#_subfunctions" class="code">function init(self) </a><span class="comment">% operations before starting to iterate</span>
0039             <span class="comment">%nop</span>
0040         <span class="keyword">end</span>
0041         
0042         <a name="_sub3" href="#_subfunctions" class="code">function pre(self, it) </a><span class="comment">% operations before an iteration</span>
0043             <span class="comment">%nop</span>
0044         <span class="keyword">end</span>
0045         
0046         <a name="_sub4" href="#_subfunctions" class="code">function [result, runtime] = analyze(self, it, e)</a>
0047             T0 = tic;
0048             self.solvers{e}.reset();
0049             result = self.solvers{e}.getAvgTable();
0050             runtime = toc(T0);
0051         <span class="keyword">end</span>
0052         
0053         <a name="_sub5" href="#_subfunctions" class="code">function post(self, it) </a><span class="comment">% operations after an iteration</span>
0054             <span class="keyword">for</span> post_it = 1:2 <span class="comment">% do elevator up and down</span>
0055                 self.model.updateParam({self.results{it,:}});
0056             <span class="keyword">end</span>
0057             self.ensemble = self.model.refreshLayers(); <span class="comment">% update Network objects in ensemble</span>
0058         <span class="keyword">end</span>
0059         
0060         <a name="_sub6" href="#_subfunctions" class="code">function finish(self) </a><span class="comment">% operations after interations are completed</span>
0061             <span class="comment">%nop</span>
0062         <span class="keyword">end</span>
0063         
0064         <a name="_sub7" href="#_subfunctions" class="code">function [QN,UN,RN,TN] = getAvg(self,~,~,~,~)</a>
0065             self.run(); <span class="comment">% run iterations</span>
0066             lqnGraph = self.model.getGraph;
0067             Avg = self.model.param;
0068             <span class="comment">% At this point the Avg data structure includes only the</span>
0069             <span class="comment">% fundamental perf indexes that uniquely determine a valid LQN.</span>
0070             <span class="comment">% We now derive the other perf indexes</span>
0071             <span class="keyword">for</span> edge=1:height(lqnGraph.Edges)
0072                 <span class="keyword">if</span> lqnGraph.Edges.Type(edge) == 1 <span class="comment">% add contribution of sync-calls</span>
0073                     syncSource = lqnGraph.Edges.EndNodes{edge,1};
0074                     aidx = findstring(lqnGraph.Nodes.Name,syncSource);
0075                     <span class="keyword">if</span> lqnGraph.Edges.Weight(edge) &gt;= 1
0076                         Avg.Nodes.RespT(aidx) = Avg.Nodes.RespT(aidx) +  Avg.Edges.RespT(edge) * lqnGraph.Edges.Weight(edge);
0077                     <span class="keyword">else</span>
0078                         Avg.Nodes.RespT(aidx) = Avg.Nodes.RespT(aidx) +  Avg.Edges.RespT(edge);
0079                     <span class="keyword">end</span>
0080                 <span class="keyword">end</span>
0081             <span class="keyword">end</span>
0082             <span class="comment">% - qlen is respT * tput</span>
0083             <span class="comment">% - qlen of task is sum of qlen of its entries</span>
0084             <span class="comment">% - tput of task is sum of tput of its entries</span>
0085             <span class="comment">% - util of entry is sum of util of its activities</span>
0086             Avg.Nodes.QLen = Avg.Nodes.RespT .* Avg.Nodes.Tput;
0087             Avg.Nodes.Util = lqnGraph.Nodes.D .* Avg.Nodes.Tput;
0088             procPos = strcmp(lqnGraph.Nodes.Type,<span class="string">'P'</span>);
0089             Avg.Nodes.QLen(procPos) = NaN;
0090             Avg.Nodes.RespT(procPos) = NaN;
0091             Avg.Nodes.Tput(procPos) = NaN;            
0092             taskPos = strcmp(lqnGraph.Nodes.Type,<span class="string">'R'</span>) | strcmp(lqnGraph.Nodes.Type,<span class="string">'T'</span>);
0093             <span class="keyword">for</span> tidx = find(taskPos)'
0094                 entriesOfTask = self.model.listEntriesOfTask(tidx);
0095                 <span class="keyword">for</span> e = 1:length(entriesOfTask)
0096                     Avg.Nodes.Tput(tidx) = 0;
0097                 <span class="keyword">end</span>
0098                 <span class="keyword">for</span> e = 1:length(entriesOfTask)
0099                     eidx = self.model.getNodeIndex(entriesOfTask{e});
0100                     Avg.Nodes.QLen(tidx) = Avg.Nodes.QLen(tidx) + Avg.Nodes.QLen(eidx);
0101                     Avg.Nodes.Tput(tidx) = Avg.Nodes.Tput(tidx) + Avg.Nodes.Tput(eidx);
0102                     actOfEntry = self.model.listActivitiesOfEntry(entriesOfTask{e});
0103                      Avg.Nodes.Util(eidx) = 0;
0104                      <span class="keyword">for</span> a = 1:length(actOfEntry)
0105                          aidx = self.model.getNodeIndex(actOfEntry{a});
0106                          Avg.Nodes.Util(eidx) = Avg.Nodes.Util(eidx) + Avg.Nodes.Util(aidx);
0107                      <span class="keyword">end</span>
0108                     Avg.Nodes.Util(tidx) = Avg.Nodes.Util(tidx) + Avg.Nodes.Util(eidx);
0109                 <span class="keyword">end</span>
0110                 pidx = self.model.getNodeIndex(lqnGraph.Nodes.Proc{tidx});
0111                 Avg.Nodes.Util(pidx) = Avg.Nodes.Util(pidx) + Avg.Nodes.Util(tidx);
0112             <span class="keyword">end</span>
0113             Avg.Nodes.RespT(taskPos) = NaN;
0114             QN =  Avg.Nodes.QLen;
0115             UN =  Avg.Nodes.Util;
0116             TN =  Avg.Nodes.Tput;
0117             RN =  Avg.Nodes.RespT;
0118         <span class="keyword">end</span>
0119     <span class="keyword">end</span>
0120     
0121     methods (Static)
0122         <a name="_sub8" href="#_subfunctions" class="code">function [bool, featSupported] = supports(model)</a>
0123             <span class="comment">% todo</span>
0124             bool = true;
0125         <span class="keyword">end</span>
0126     <span class="keyword">end</span>
0127     
0128     methods (Static)
0129         <a name="_sub9" href="#_subfunctions" class="code">function options = defaultOptions(self)</a>
0130             options = EnsembleSolver.defaultOptions();
0131             options.timespan = [Inf,Inf];
0132             options.keep = false;
0133             options.verbose = 2;
0134         <span class="keyword">end</span>
0135     <span class="keyword">end</span>
0136 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>