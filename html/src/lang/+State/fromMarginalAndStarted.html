<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fromMarginalAndStarted</title>
  <meta name="keywords" content="fromMarginalAndStarted">
  <meta name="description" content="Copyright (c) 2012-2019, Imperial College London">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">lang</a> &gt; <a href="index.html">+State</a> &gt; fromMarginalAndStarted.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\lang\+State&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fromMarginalAndStarted
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Copyright (c) 2012-2019, Imperial College London</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function space = fromMarginalAndStarted(qn, ind, n, s, options) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function space = fromMarginalAndStarted(qn, ind, n, s, options)</a>
0002 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003 <span class="comment">% All rights reserved.</span>
0004 
0005 <span class="keyword">if</span> ~exist(<span class="string">'options'</span>,<span class="string">'var'</span>)
0006     options.force = false;
0007 <span class="keyword">end</span>
0008 <span class="keyword">if</span> isa(qn,<span class="string">'Network'</span>)
0009     qn=qn.getStruct();
0010 <span class="keyword">end</span>
0011 <span class="comment">% generate one initial state such that the marginal queue-lengths are as in vector n</span>
0012 <span class="comment">% n(r): number of jobs at the station in class r</span>
0013 <span class="comment">% s(r): jobs of class r that are running</span>
0014 R = qn.nclasses;
0015 S = qn.nservers;
0016 
0017 <span class="comment">% ind: node index</span>
0018 ist = qn.nodeToStation(ind);
0019 isf = qn.nodeToStateful(ind);
0020 
0021 K = zeros(1,R);
0022 <span class="keyword">for</span> r=1:R
0023     K(r) = length(qn.mu{ist,r});
0024 <span class="keyword">end</span>
0025 state = [];
0026 space = [];
0027 <span class="keyword">if</span> any(n&gt;qn.classcap(ist,:))
0028     exceeded = n&gt;qn.classcap(ist,:);
0029     <span class="keyword">if</span> any(cellfun(@(c) isnan(c),{qn.mu{ist,find(exceeded)}}))
0030         warning(<span class="string">'State vector at station %d (n=%s) exceeds the class capacity (classcap=%s). Some service classes are disabled.\n'</span>,ist,mat2str(n(ist,:)),mat2str(qn.classcap(ist,:)));
0031     <span class="keyword">else</span>
0032         warning(<span class="string">'State vector at station %d (n=%s) exceeds the class capacity (classcap=%s).\n'</span>,ist,mat2str(n(ist,:)),mat2str(qn.classcap(ist,:)));
0033     <span class="keyword">end</span>
0034     <span class="keyword">return</span>
0035 <span class="keyword">end</span>
0036 <span class="keyword">if</span> (qn.nservers(ist)&gt;0 &amp;&amp; sum(s) &gt; qn.nservers(ist))
0037     <span class="keyword">return</span>
0038 <span class="keyword">end</span>
0039 <span class="comment">% generate local-state space</span>
0040 <span class="keyword">switch</span> qn.nodetype(ind)
0041     <span class="keyword">case</span> {NodeType.Queue, NodeType.Delay, NodeType.Source}
0042         <span class="keyword">switch</span> qn.sched{ist}
0043             <span class="keyword">case</span> SchedStrategy.EXT
0044                 <span class="keyword">for</span> r=1:R
0045                     init = State.spaceClosedSingle(K(r),0);
0046                     <span class="keyword">if</span> isinf(qn.njobs(r))
0047                         <span class="keyword">if</span> isnan(qn.mu{ist,r})
0048                             init(1) = 0; <span class="comment">% class is not processed at this source</span>
0049                         <span class="keyword">else</span>
0050                             <span class="comment">% init the job generation</span>
0051                             init(1) = 1;
0052                         <span class="keyword">end</span>
0053                     <span class="keyword">end</span>
0054                     state = State.decorate(state,init);
0055                 <span class="keyword">end</span>
0056                 space = State.decorate(space,state);
0057                 space = [Inf*ones(size(space,1),1),space];
0058             <span class="keyword">case</span> {SchedStrategy.INF, SchedStrategy.PS, SchedStrategy.DPS, SchedStrategy.GPS}
0059                 <span class="comment">% in these policies we only track the jobs in the servers</span>
0060                 <span class="keyword">for</span> r=1:R
0061                     init = State.spaceClosedSingle(K(r),0);
0062                     init(1) = n(r);
0063                     state = State.decorate(state,init);
0064                 <span class="keyword">end</span>
0065                 space = State.decorate(space,state);
0066             <span class="keyword">case</span> {SchedStrategy.RAND, SchedStrategy.LEPT, SchedStrategy.SEPT}
0067                 <span class="comment">% in these policies we track an un-ordered buffer and</span>
0068                 <span class="comment">% the jobs in the servers</span>
0069                 <span class="comment">% build list of job classes in the node, with repetition</span>
0070                 <span class="keyword">if</span> sum(n) &lt;= S(ist)
0071                     <span class="keyword">for</span> r=1:R
0072                         init = State.spaceClosedSingle(K(r),0);
0073                         init(1) = n(r);
0074                         state = State.decorate(state,init);
0075                     <span class="keyword">end</span>
0076                     space = State.decorate(space,[zeros(size(state,1),R),state]);
0077                 <span class="keyword">else</span>
0078                     <span class="comment">%            si = multichoosecon(n,S(i)); % jobs of class r that are running</span>
0079                     si = s;
0080                     mi_buf = repmat(n,size(si,1),1) - si; <span class="comment">% jobs of class r in buffer</span>
0081                     <span class="keyword">for</span> k=1:size(si,1)
0082                         <span class="comment">% determine number of classes r jobs running in phase j</span>
0083                         kstate=[];
0084                         <span class="keyword">for</span> r=1:R
0085                             init = State.spaceClosedSingle(K(r),0);
0086                             init(1) = si(k,r);
0087                             kstate = State.decorate(kstate,init);
0088                         <span class="keyword">end</span>
0089                         state = [repmat(mi_buf(k,:),size(kstate,1),1), kstate];
0090                         space = [space; state];
0091                     <span class="keyword">end</span>
0092                 <span class="keyword">end</span>
0093             <span class="keyword">case</span> {SchedStrategy.FCFS, SchedStrategy.HOL, SchedStrategy.LCFS}
0094                 sizeEstimator = multinomialln(n);
0095                 sizeEstimator = round(sizeEstimator/log(10));
0096                 <span class="keyword">if</span> sizeEstimator &gt; 2
0097                     <span class="keyword">if</span> ~isfield(options,<span class="string">'force'</span>) || options.force == false
0098                         error(sprintf(<span class="string">'State space size is very large: 1e%d states. Stopping execution. Set options.force=true to bypass this control.\n'</span>,sizeEstimator));
0099                     <span class="keyword">end</span>
0100                 <span class="keyword">end</span>
0101                 <span class="keyword">if</span> sum(n) == 0
0102                     space = zeros(1,1+sum(K));
0103                     <span class="keyword">return</span>
0104                 <span class="keyword">end</span>
0105                 <span class="comment">% in these policies we track an ordered buffer and</span>
0106                 <span class="comment">% the jobs in the servers</span>
0107                 
0108                 <span class="comment">% build list of job classes in the buffer, with repetition</span>
0109                 vi = [];
0110                 <span class="keyword">for</span> r=1:R
0111                     <span class="keyword">if</span> n(r)&gt;0
0112                         vi=[vi, r*ones(1,n(r))];
0113                     <span class="keyword">end</span>
0114                 <span class="keyword">end</span>
0115                 
0116                 <span class="comment">% gen permutation of their positions in the fcfs buffer</span>
0117                 mi = uniqueperms(vi);
0118                 <span class="keyword">if</span> isempty(mi)
0119                     mi_buf = zeros(1,max(1,sum(n)-S(ist)));
0120                     state = zeros(1,R);
0121                     state = State.decorate(state,[mi_buf,state]);
0122                 <span class="keyword">else</span>
0123                     <span class="comment">% mi_buf: class of job in buffer position i (0=empty)</span>
0124                     <span class="keyword">if</span> sum(n)&gt;sum(s)
0125                         mi_buf = mi(:,1:(sum(n)-sum(s)));
0126                     <span class="keyword">else</span> <span class="comment">% set an empty buffer</span>
0127                         mi_buf = 0;
0128                     <span class="keyword">end</span>
0129                 <span class="keyword">end</span>
0130                 <span class="comment">% mi_srv: class of jobs running in the server of i</span>
0131                 mi_srv = [];
0132                 <span class="keyword">for</span> r=1:R
0133                     mi_srv = [mi_srv, r*ones(1,s(r))];
0134                 <span class="keyword">end</span>
0135                 <span class="comment">% si: number of class r jobs that are running</span>
0136                 si = s;
0137                 <span class="comment">%si = unique(si,'rows');</span>
0138                 <span class="keyword">for</span> b=1:size(mi_buf,1)
0139                     <span class="keyword">for</span> k=1:size(si,1)
0140                         <span class="comment">% determine number of classs r jobs running in phase</span>
0141                         <span class="comment">% j in server state mi_srv(kjs,:) and build</span>
0142                         <span class="comment">% state</span>
0143                         kstate=[];
0144                         <span class="keyword">for</span> r=1:R
0145                             <span class="comment">% kstate = State.decorate(kstate,State.spaceClosedSingle(K(r),si(k,r)));</span>
0146                             init = State.spaceClosedSingle(K(r),0);
0147                             init(1) = si(k,r);
0148                             kstate = State.decorate(kstate,init);
0149                         <span class="keyword">end</span>
0150                         state = [state; repmat(mi_buf(b,:),size(kstate,1),1), kstate];
0151                     <span class="keyword">end</span>
0152                 <span class="keyword">end</span>
0153                 space = state;
0154             <span class="keyword">case</span> {SchedStrategy.SJF, SchedStrategy.LJF}
0155                 <span class="comment">% in these policies the state space includes continuous</span>
0156                 <span class="comment">% random variables for the service times</span>
0157                 <span class="comment">% in these policies we only track the jobs in the servers</span>
0158                 
0159                 <span class="keyword">for</span> r=1:R
0160                     init = State.spaceClosedSingle(K(r),0);
0161                     init(1) = n(r);
0162                     state = State.decorate(state,init);
0163                 <span class="keyword">end</span>
0164                 space = State.decorate(space,state);
0165                 <span class="comment">% this is not casted as an error since this function is</span>
0166                 <span class="comment">% called to initial models with SJF and LJF</span>
0167                 warning(<span class="string">'The scheduling policy does not admit a discrete state space.\n'</span>);
0168         <span class="keyword">end</span>
0169     <span class="keyword">case</span> NodeType.Cache
0170         <span class="keyword">switch</span> qn.sched{ist}
0171             <span class="keyword">case</span> SchedStrategy.INF
0172                 <span class="comment">% in this policies we only track the jobs in the servers</span>
0173                 <span class="keyword">for</span> r=1:R
0174                     init = State.spaceClosedSingle(K(r),n(r));
0175                     state = State.decorate(state,init);
0176                 <span class="keyword">end</span>
0177                 space = State.decorate(space,state);
0178         <span class="keyword">end</span>
0179     <span class="keyword">case</span> NodeType.Join
0180         space = 0;
0181 <span class="keyword">end</span>
0182 space = unique(space,<span class="string">'rows'</span>); <span class="comment">% do not comment, required to sort empty state as first</span>
0183 space = space(end:-1:1,:); <span class="comment">% this ensures that states where jobs start in phase 1 are first, which is used eg in SSA</span>
0184 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>