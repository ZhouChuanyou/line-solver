<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of Network</title>
  <meta name="keywords" content="Network">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">lang</a> &gt; <a href="index.html">@Network</a> &gt; Network.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\lang\@Network&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>Network
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="Network.html" class="code" title="">Network</a>	</li><li><a href="addJobClass.html" class="code" title="function addJobClass(self, customerClass)">addJobClass</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="addLink.html" class="code" title="function addLink(self, nodeA, nodeB)">addLink</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="addLinks.html" class="code" title="function addLinks(self, nodesList)">addLinks</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="addMetric.html" class="code" title="function addMetric(self, perfIndex)">addMetric</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="addNode.html" class="code" title="function addNode(self, node)">addNode</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="disableMetric.html" class="code" title="function self = disableMetric(self, Y)">disableMetric</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="enableMetric.html" class="code" title="function self = enableMetric(self, Y)">enableMetric</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getAvgHandles.html" class="code" title="function [Q,U,R,T] = getAvgHandles(self)">getAvgHandles</a>	% getAvgHandles: add all mean performance indexes</li><li><a href="getAvgQLenHandles.html" class="code" title="function [Q] = getAvgQLenHandles(self)">getAvgQLenHandles</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getAvgRespTHandles.html" class="code" title="function R = getAvgRespTHandles(self)">getAvgRespTHandles</a>	R(i,r): mean response time of class r at node i (summed across visits)</li><li><a href="getAvgTputHandles.html" class="code" title="function [T] = getAvgTputHandles(self)">getAvgTputHandles</a>	T(i,r): mean throughput of class r at node i</li><li><a href="getAvgUtilHandles.html" class="code" title="function [U] = getAvgUtilHandles(self)">getAvgUtilHandles</a>	U(i,r): mean utilization of class r at node i</li><li><a href="getChains.html" class="code" title="function [qnchains,chains] = getChains(self, rt)">getChains</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getForks.html" class="code" title="function ft = getForks(self, rt)">getForks</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getIndexSinkNode.html" class="code" title="function index = getIndexSinkNode(self)">getIndexSinkNode</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getIndexSourceNode.html" class="code" title="function index = getIndexSourceNode(self)">getIndexSourceNode</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getIndexSourceStation.html" class="code" title="function index = getIndexSourceStation(self)">getIndexSourceStation</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getNumberOfJobs.html" class="code" title="function N = getNumberOfJobs(self)">getNumberOfJobs</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getReferenceStations.html" class="code" title="function refstat = getReferenceStations(self)">getReferenceStations</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getRoutingMatrix.html" class="code" title="function [rt,rtNodes,rtNodesByClass,rtNodesByStation,connMatrix] = getRoutingMatrix(self, arvRates)">getRoutingMatrix</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getSink.html" class="code" title="function node = getSink(self)">getSink</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getSource.html" class="code" title="function node = getSource(self)">getSource</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getStationScheduling.html" class="code" title="function sched = getStationScheduling(self)">getStationScheduling</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getStationServers.html" class="code" title="function S = getStationServers(self)">getStationServers</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="getStruct.html" class="code" title="function qn = getStruct(self, wantState)">getStruct</a>	</li><li><a href="getTranHandles.html" class="code" title="function [Qt,Ut,Tt] = getTranHandles(self)">getTranHandles</a>	% getTranHandles: add all transient mean performance indexes</li><li><a href="getUsedLangFeatures.html" class="code" title="function used = getUsedLangFeatures(self)">getUsedLangFeatures</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="link.html" class="code" title="function self = link(self, P)">link</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="linkAndLog.html" class="code" title="function [loggerBefore,loggerAfter] = linkAndLog(self, P, isNodeLogged, logPath)">linkAndLog</a>	this macro will need refactoring to decouple the observation from the Model class</li><li><a href="refreshAG.html" class="code" title="function genAG(self)">refreshAG</a>	getAG : export model in agent representation</li><li><a href="refreshCapacity.html" class="code" title="function [capacity, classcap] = refreshCapacity(self)">refreshCapacity</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshChains.html" class="code" title="function [chains, visits, rt] = refreshChains(self, rates, wantVisits)">refreshChains</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshCoxService.html" class="code" title="function [mu, phi, phases] = refreshCoxService(self)">refreshCoxService</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshLocalVars.html" class="code" title="function nvars = refreshLocalVars(self)">refreshLocalVars</a>	</li><li><a href="refreshPriorities.html" class="code" title="function classprio = refreshPriorities(self)">refreshPriorities</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshRates.html" class="code" title="function [rates, scv] = refreshRates(self)">refreshRates</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshRoutingMatrix.html" class="code" title="function [rt, rtfun, csmask, rtnodes] = refreshRoutingMatrix(self, rates)">refreshRoutingMatrix</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshScheduling.html" class="code" title="function [sched, schedid, schedparam] = refreshScheduling(self, rates)">refreshScheduling</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshService.html" class="code" title="function [rates,scv, mu,phi,phases] = refreshService(self)">refreshService</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshStruct.html" class="code" title="function refreshStruct(self)">refreshStruct</a>	Copyright (c) 2012-2019, Imperial College London</li><li><a href="refreshSync.html" class="code" title="function sync = refreshSync(self)">refreshSync</a>	</li><li><a href="resetNetwork.html" class="code" title="function nodes = resetNetwork(self, deleteCSNodes) % resets network topology">resetNetwork</a>	</li><li><a href="sanitize.html" class="code" title="function sanitize(self)">sanitize</a>	Copyright (c) 2012-2019, Imperial College London</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="Network.html" class="code" title="">Network</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function self = linkNetwork(self, P)</a></li><li><a href="#_sub2" class="code">function [loggerBefore,loggerAfter] = linkNetworkAndLog(self, nodes, classes, P, wantLogger, logPath)</a></li><li><a href="#_sub3" class="code">function [rates, mu, phi, phases] = refreshArrival(self)</a></li><li><a href="#_sub4" class="code">function self = Network(modelName)</a></li><li><a href="#_sub5" class="code">function nodes = getNodes(self)</a></li><li><a href="#_sub6" class="code">function P = getLinkedRoutingMatrix(self)</a></li><li><a href="#_sub7" class="code">function logPath = getLogPath(self)</a></li><li><a href="#_sub8" class="code">function setLogPath(self, logPath)</a></li><li><a href="#_sub9" class="code">function bool = hasInitState(self)</a></li><li><a href="#_sub10" class="code">function reset(self)</a></li><li><a href="#_sub11" class="code">function [M,R] = getSize(self)</a></li><li><a href="#_sub12" class="code">function bool = hasOpenClasses(self)</a></li><li><a href="#_sub13" class="code">function bool = hasClassSwitch(self)</a></li><li><a href="#_sub14" class="code">function bool = hasClosedClasses(self)</a></li><li><a href="#_sub15" class="code">function index = getIndexOpenClasses(self)</a></li><li><a href="#_sub16" class="code">function index = getIndexClosedClasses(self)</a></li><li><a href="#_sub17" class="code">function c = getClassChain(self, className)</a></li><li><a href="#_sub18" class="code">function classnames = getClassNames(self)</a></li><li><a href="#_sub19" class="code">function nodeNames = getNodeNames(self)</a></li><li><a href="#_sub20" class="code">function nodeTypes = getNodeTypes(self)</a></li><li><a href="#_sub21" class="code">function rtTypes = getRoutingStrategies(self)</a></li><li><a href="#_sub22" class="code">function nodeIndex = getNodeIndex(self, name)</a></li><li><a href="#_sub23" class="code">function stationIndex = getStationIndex(self, name)</a></li><li><a href="#_sub24" class="code">function classIndex = getClassIndex(self, name)</a></li><li><a href="#_sub25" class="code">function stationnames = getStationNames(self)</a></li><li><a href="#_sub26" class="code">function statefulnames = getStatefulNodeNames(self)</a></li><li><a href="#_sub27" class="code">function M = getNumberOfNodes(self)</a></li><li><a href="#_sub28" class="code">function S = getNumberOfStatefulNodes(self)</a></li><li><a href="#_sub29" class="code">function M = getNumberOfStations(self)</a></li><li><a href="#_sub30" class="code">function R = getNumberOfClasses(self)</a></li><li><a href="#_sub31" class="code">function C = getNumberOfChains(self)</a></li><li><a href="#_sub32" class="code">function Dchain = getDemandsChain(self)</a></li><li><a href="#_sub33" class="code">function self = setUsedFeatures(self,className)</a></li><li><a href="#_sub34" class="code">function list = getIndexStations(self)</a></li><li><a href="#_sub35" class="code">function list = getIndexStatefulNodes(self)</a></li><li><a href="#_sub36" class="code">function jsimwView(self)</a></li><li><a href="#_sub37" class="code">function jsimgView(self)</a></li><li><a href="#_sub38" class="code">function [ni, nir, sir, kir] = initToMarginal(self)</a></li><li><a href="#_sub39" class="code">function [isvalid] = isStateValid(self)</a></li><li><a href="#_sub40" class="code">function [initialState, priorInitialState] = getState(self)</a></li><li><a href="#_sub41" class="code">function initFromAvgQLen(self, AvgQLen)</a></li><li><a href="#_sub42" class="code">function initDefault(self)</a></li><li><a href="#_sub43" class="code">function initFromMarginal(self, n, options)</a></li><li><a href="#_sub44" class="code">function initFromMarginalAndRunning(self, n, s, options)</a></li><li><a href="#_sub45" class="code">function initFromMarginalAndStarted(self, n, s, options)</a></li><li><a href="#_sub46" class="code">function [H,G] = getGraph(self)</a></li><li><a href="#_sub47" class="code">function mask = getClassSwitchingMask(self)</a></li><li><a href="#_sub48" class="code">function printRoutingMatrix(self)</a></li><li><a href="#_sub49" class="code">function self = update(self)</a></li><li><a href="#_sub50" class="code">function self = refresh(self)</a></li><li><a href="#_sub51" class="code">function out = getModelNameExtension(self)</a></li><li><a href="#_sub52" class="code">function self = initUsedFeatures(self)</a></li><li><a href="#_sub53" class="code">function clone = copyElement(self)</a></li><li><a href="#_sub54" class="code">function bool = hasFCFS(self)</a></li><li><a href="#_sub55" class="code">function bool = hasHomogeneousScheduling(self, strategy)</a></li><li><a href="#_sub56" class="code">function bool = hasDPS(self)</a></li><li><a href="#_sub57" class="code">function bool = hasGPS(self)</a></li><li><a href="#_sub58" class="code">function bool = hasINF(self)</a></li><li><a href="#_sub59" class="code">function bool = hasPS(self)</a></li><li><a href="#_sub60" class="code">function bool = hasRAND(self)</a></li><li><a href="#_sub61" class="code">function bool = hasHOL(self)</a></li><li><a href="#_sub62" class="code">function bool = hasLCFS(self)</a></li><li><a href="#_sub63" class="code">function bool = hasSEPT(self)</a></li><li><a href="#_sub64" class="code">function bool = hasLEPT(self)</a></li><li><a href="#_sub65" class="code">function bool = hasSJF(self)</a></li><li><a href="#_sub66" class="code">function bool = hasLJF(self)</a></li><li><a href="#_sub67" class="code">function bool = hasMultiClassFCFS(self)</a></li><li><a href="#_sub68" class="code">function bool = hasMultiServer(self)</a></li><li><a href="#_sub69" class="code">function bool = hasSingleChain(self)</a></li><li><a href="#_sub70" class="code">function bool = hasMultiChain(self)</a></li><li><a href="#_sub71" class="code">function bool = hasSingleClass(self)</a></li><li><a href="#_sub72" class="code">function bool = hasMultiClass(self)</a></li><li><a href="#_sub73" class="code">function bool = hasProductFormSolution(self)</a></li><li><a href="#_sub74" class="code">function addItemSet(self, itemSet)</a></li><li><a href="#_sub75" class="code">function model = tandemPs(lambda,D)</a></li><li><a href="#_sub76" class="code">function model = tandemPsInf(lambda,D,Z)</a></li><li><a href="#_sub77" class="code">function model = tandemFcfs(lambda,D)</a></li><li><a href="#_sub78" class="code">function model = tandemFcfsInf(lambda,D,Z)</a></li><li><a href="#_sub79" class="code">function model = tandem(lambda,S,strategy)</a></li><li><a href="#_sub80" class="code">function model = cyclicPs(N,D)</a></li><li><a href="#_sub81" class="code">function model = cyclicPsInf(N,D,Z)</a></li><li><a href="#_sub82" class="code">function model = cyclicFcfs(N,D)</a></li><li><a href="#_sub83" class="code">function model = cyclicFcfsInf(N,D,Z)</a></li><li><a href="#_sub84" class="code">function model = cyclic(N,D,strategy)</a></li><li><a href="#_sub85" class="code">function P = serialRouting(varargin)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="Network.html" class="code" title="">Network</a> &lt; Model
0002     <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003     <span class="comment">% All rights reserved.</span>
0004     
0005     properties (GetAccess = <span class="string">'private'</span>, SetAccess=<span class="string">'private'</span>)
0006         usedFeatures; <span class="comment">% structure of booleans listing the used classes</span>
0007         <span class="comment">% it must be accessed via getUsedLangFeatures that updates</span>
0008         <span class="comment">% the Distribution classes dynamically</span>
0009         isInitialized;
0010         logPath;
0011         linkedP;
0012     <span class="keyword">end</span>
0013     
0014     properties (Access=protected)
0015         items;
0016     <span class="keyword">end</span>
0017     
0018     properties (Hidden)
0019         qn;
0020         ag;
0021         handles;
0022         perfIndex;
0023         links;
0024     <span class="keyword">end</span>
0025     
0026     properties
0027         classes;
0028         stations;
0029         nodes;
0030     <span class="keyword">end</span>
0031     
0032     methods <span class="comment">% public methods in class folder</span>
0033         <a href="refreshAG.html" class="code" title="function genAG(self)">refreshAG</a>(self) <span class="comment">% get agent representation</span>
0034         
0035         sa = <a href="getStruct.html" class="code" title="function qn = getStruct(self, wantState)">getStruct</a>(self, structType, wantState) <span class="comment">% get abritrary representation</span>
0036         <span class="comment">%        cn = getCN(self, wantState) % wrapper of getStruct for cache network representation</span>
0037         <span class="comment">%        ag = getAG(self) % get agent representation</span>
0038         
0039         used = <a href="getUsedLangFeatures.html" class="code" title="function used = getUsedLangFeatures(self)">getUsedLangFeatures</a>(self) <span class="comment">% get used features</span>
0040         
0041         ft = <a href="getForks.html" class="code" title="function ft = getForks(self, rt)">getForks</a>(self, rt) <span class="comment">% get fork table</span>
0042         [chainsObj,chainsMatrix] = <a href="getChains.html" class="code" title="function [qnchains,chains] = getChains(self, rt)">getChains</a>(self, rt) <span class="comment">% get chain table</span>
0043         
0044         [P,Pnodes,myPc,myPs,links] = <a href="getRoutingMatrix.html" class="code" title="function [rt,rtNodes,rtNodesByClass,rtNodesByStation,connMatrix] = getRoutingMatrix(self, arvRates)">getRoutingMatrix</a>(self, arvRates) <span class="comment">% get routing matrix</span>
0045         
0046         nodes = <a href="resetNetwork.html" class="code" title="function nodes = resetNetwork(self, deleteCSNodes) % resets network topology">resetNetwork</a>(self)
0047         self = <a href="link.html" class="code" title="function self = link(self, P)">link</a>(self, P)
0048         [loggerBefore,loggerAfter] = <a href="linkAndLog.html" class="code" title="function [loggerBefore,loggerAfter] = linkAndLog(self, P, isNodeLogged, logPath)">linkAndLog</a>(self, nodes, classes, P, wantLogger, logPath)
0049         <a name="_sub0" href="#_subfunctions" class="code">function self = linkNetwork(self, P) </a><span class="comment">% obsolete - old name</span>
0050             self = <a href="link.html" class="code" title="function self = link(self, P)">link</a>(self,  P); 
0051         <span class="keyword">end</span> 
0052         <a name="_sub1" href="#_subfunctions" class="code">function [loggerBefore,loggerAfter] = linkNetworkAndLog(self, nodes, classes, P, wantLogger, logPath)</a><span class="comment">% obsolete - old name</span>
0053             [loggerBefore,loggerAfter] = <a href="linkAndLog.html" class="code" title="function [loggerBefore,loggerAfter] = linkAndLog(self, P, isNodeLogged, logPath)">linkAndLog</a>(self, nodes, classes, P, wantLogger, logPath); 
0054         <span class="keyword">end</span> 
0055         
0056         [Q,U,R,T] = <a href="getAvgHandles.html" class="code" title="function [Q,U,R,T] = getAvgHandles(self)">getAvgHandles</a>(self)
0057         T = <a href="getAvgTputHandles.html" class="code" title="function [T] = getAvgTputHandles(self)">getAvgTputHandles</a>(self);
0058         Q = <a href="getAvgQLenHandles.html" class="code" title="function [Q] = getAvgQLenHandles(self)">getAvgQLenHandles</a>(self);
0059         R = <a href="getAvgRespTHandles.html" class="code" title="function R = getAvgRespTHandles(self)">getAvgRespTHandles</a>(self);
0060         U = <a href="getAvgUtilHandles.html" class="code" title="function [U] = getAvgUtilHandles(self)">getAvgUtilHandles</a>(self);
0061         [Qt,Ut,Tt] = <a href="getTranHandles.html" class="code" title="function [Qt,Ut,Tt] = getTranHandles(self)">getTranHandles</a>(self)
0062     <span class="keyword">end</span>
0063     
0064     methods (Access = protected)
0065         [rates, scv] = <a href="refreshRates.html" class="code" title="function [rates, scv] = refreshRates(self)">refreshRates</a>(self);
0066         [mu, phi, phases] = <a href="refreshCoxService.html" class="code" title="function [mu, phi, phases] = refreshCoxService(self)">refreshCoxService</a>(self);
0067         [rt, rtfun, csmask, rtnodes] = <a href="refreshRoutingMatrix.html" class="code" title="function [rt, rtfun, csmask, rtnodes] = refreshRoutingMatrix(self, rates)">refreshRoutingMatrix</a>(self, rates);
0068         sync = <a href="refreshSync.html" class="code" title="function sync = refreshSync(self)">refreshSync</a>(self);
0069         <a href="sanitize.html" class="code" title="function sanitize(self)">sanitize</a>(self);
0070     <span class="keyword">end</span>
0071     
0072     methods
0073         classprio = <a href="refreshPriorities.html" class="code" title="function classprio = refreshPriorities(self)">refreshPriorities</a>(self);
0074         [sched, schedid, schedparam] = <a href="refreshScheduling.html" class="code" title="function [sched, schedid, schedparam] = refreshScheduling(self, rates)">refreshScheduling</a>(self, rates);
0075         <a name="_sub2" href="#_subfunctions" class="code">function [rates, mu, phi, phases] = refreshArrival(self) </a><span class="comment">% LINE treats arrival distributions as service distributions of the Source object</span>
0076             [rates, mu, phi, phases] = self.refreshService();
0077         <span class="keyword">end</span>
0078         [rates, scv, mu, phi, phases] = <a href="refreshService.html" class="code" title="function [rates,scv, mu,phi,phases] = refreshService(self)">refreshService</a>(self);
0079         [chains, visits, rt] = <a href="refreshChains.html" class="code" title="function [chains, visits, rt] = refreshChains(self, rates, wantVisits)">refreshChains</a>(self, rates, wantVisits)
0080         [cap, classcap] = <a href="refreshCapacity.html" class="code" title="function [capacity, classcap] = refreshCapacity(self)">refreshCapacity</a>(self);
0081         nvars = <a href="refreshLocalVars.html" class="code" title="function nvars = refreshLocalVars(self)">refreshLocalVars</a>(self);
0082     <span class="keyword">end</span>
0083     
0084     <span class="comment">% PUBLIC METHODS</span>
0085     methods
0086         <span class="comment">%Constructor</span>
0087         <a name="_sub3" href="#_subfunctions" class="code">function self = Network(modelName)</a>
0088             self = self@Model(modelName);
0089             self.nodes = {};
0090             self.stations = {};
0091             self.classes = {};
0092             self.perfIndex = struct();
0093             self.perfIndex.(<span class="string">'Avg'</span>) = {};
0094             self.perfIndex.(<span class="string">'Tran'</span>) = {};
0095             self.links = {};
0096             self.initUsedFeatures();
0097             self.qn = [];
0098             self.linkedP = {};
0099             self.ag = [];
0100             self.isInitialized = false;
0101             self.logPath = <span class="string">''</span>;
0102             self.items = {};
0103         <span class="keyword">end</span>
0104         
0105         <a name="_sub4" href="#_subfunctions" class="code">function nodes = getNodes(self)</a>
0106             nodes = self.nodes;
0107         <span class="keyword">end</span>
0108         
0109         <a name="_sub5" href="#_subfunctions" class="code">function P = getLinkedRoutingMatrix(self)</a>
0110             <span class="keyword">if</span> isempty(self.linkedP)
0111                 error(<span class="string">'Unsupported. To use this function the model topology must have been linked with the link method.'</span>);
0112             <span class="keyword">else</span>
0113                 P = self.linkedP;
0114             <span class="keyword">end</span>
0115         <span class="keyword">end</span>
0116         
0117         <a name="_sub6" href="#_subfunctions" class="code">function logPath = getLogPath(self)</a>
0118             logPath = self.logPath;
0119         <span class="keyword">end</span>
0120         
0121         <a name="_sub7" href="#_subfunctions" class="code">function setLogPath(self, logPath)</a>
0122             self.logPath = logPath;
0123         <span class="keyword">end</span>
0124         
0125         <a name="_sub8" href="#_subfunctions" class="code">function bool = hasInitState(self)</a>
0126             bool = true;
0127             <span class="keyword">if</span> ~self.isInitialized <span class="comment">% check if all stations are initialized</span>
0128                 <span class="keyword">for</span> ind=1:self.getNumberOfNodes
0129                     <span class="keyword">if</span> isa(self.nodes{ind},<span class="string">'StatefulNode'</span>) &amp;&amp; isempty(self.nodes{ind}.state)
0130                         bool = false;
0131                     <span class="keyword">end</span>
0132                 <span class="keyword">end</span>
0133             <span class="keyword">end</span>
0134         <span class="keyword">end</span>
0135         
0136         <a name="_sub9" href="#_subfunctions" class="code">function reset(self)</a>
0137             self.perfIndex.Avg = {};
0138             self.perfIndex.Tran = {};
0139             self.handles = {};
0140             self.qn = [];
0141             self.ag = [];
0142         <span class="keyword">end</span>
0143         
0144         <a href="refreshStruct.html" class="code" title="function refreshStruct(self)">refreshStruct</a>(self);
0145         
0146         <a name="_sub10" href="#_subfunctions" class="code">function [M,R] = getSize(self)</a>
0147             M = self.getNumberOfNodes;
0148             R = self.getNumberOfClasses;
0149         <span class="keyword">end</span>
0150         
0151         <a name="_sub11" href="#_subfunctions" class="code">function bool = hasOpenClasses(self)</a>
0152             bool = any(isinf(self.getNumberOfJobs()));
0153         <span class="keyword">end</span>
0154         
0155         <a name="_sub12" href="#_subfunctions" class="code">function bool = hasClassSwitch(self)</a>
0156             bool = any(cellfun(@(c) isa(c,<span class="string">'ClassSwitch'</span>), self.nodes));
0157         <span class="keyword">end</span>
0158         
0159         <a name="_sub13" href="#_subfunctions" class="code">function bool = hasClosedClasses(self)</a>
0160             bool = any(isfinite(self.getNumberOfJobs()));
0161         <span class="keyword">end</span>
0162         
0163         <a name="_sub14" href="#_subfunctions" class="code">function index = getIndexOpenClasses(self)</a>
0164             index = find(isinf(self.getNumberOfJobs()))';
0165         <span class="keyword">end</span>
0166         
0167         <a name="_sub15" href="#_subfunctions" class="code">function index = getIndexClosedClasses(self)</a>
0168             index = find(isfinite(self.getNumberOfJobs()))';
0169         <span class="keyword">end</span>
0170         
0171         <a name="_sub16" href="#_subfunctions" class="code">function c = getClassChain(self, className)</a>
0172             chains = self.getChains;
0173             <span class="keyword">if</span> ischar(className)
0174                 <span class="keyword">for</span> c = 1:length(chains)
0175                     <span class="keyword">if</span> any(cell2mat(strfind(chains{c}.classnames,className)))
0176                         <span class="keyword">return</span>
0177                     <span class="keyword">end</span>
0178                 <span class="keyword">end</span>
0179             <span class="keyword">else</span>
0180                 <span class="keyword">for</span> c = 1:length(chains)
0181                     <span class="keyword">if</span> any(cell2mat(chains{c}.index==1))
0182                         <span class="keyword">return</span>
0183                     <span class="keyword">end</span>
0184                 <span class="keyword">end</span>
0185             <span class="keyword">end</span>
0186             c = -1;
0187         <span class="keyword">end</span>
0188         
0189         <a name="_sub17" href="#_subfunctions" class="code">function classnames = getClassNames(self)</a>
0190             <span class="keyword">for</span> r=1:<a href="#_sub30" class="code" title="subfunction R = getNumberOfClasses(self)">getNumberOfClasses</a>(self)
0191                 classnames{r,1}=self.classes{r}.name;
0192             <span class="keyword">end</span>
0193         <span class="keyword">end</span>
0194         
0195         <a name="_sub18" href="#_subfunctions" class="code">function nodeNames = getNodeNames(self)</a>
0196             <span class="keyword">for</span> i=1:<a href="#_sub27" class="code" title="subfunction M = getNumberOfNodes(self)">getNumberOfNodes</a>(self)
0197                 nodeNames{i,1} = self.nodes{i}.name;
0198             <span class="keyword">end</span>
0199         <span class="keyword">end</span>
0200         
0201         <a name="_sub19" href="#_subfunctions" class="code">function nodeTypes = getNodeTypes(self)</a>
0202             nodeTypes = zeros(self.getNumberOfNodes,1);
0203             <span class="keyword">for</span> i=1:self.getNumberOfNodes
0204                 <span class="keyword">switch</span> class(self.nodes{i})
0205                     <span class="keyword">case</span> <span class="string">'Cache'</span>
0206                         nodeTypes(i) = NodeType.Cache;
0207                     <span class="keyword">case</span> <span class="string">'Logger'</span>
0208                         nodeTypes(i) = NodeType.Logger;
0209                     <span class="keyword">case</span> <span class="string">'ClassSwitch'</span>
0210                         nodeTypes(i) = NodeType.ClassSwitch;
0211                     <span class="keyword">case</span> {<span class="string">'Queue'</span>,<span class="string">'QueueingStation'</span>}
0212                         nodeTypes(i) = NodeType.Queue;
0213                     <span class="keyword">case</span> <span class="string">'Router'</span>
0214                         nodeTypes(i) = NodeType.Router;
0215                     <span class="keyword">case</span> {<span class="string">'Delay'</span>,<span class="string">'DelayStation'</span>}
0216                         nodeTypes(i) = NodeType.Delay;
0217                     <span class="keyword">case</span> <span class="string">'Sink'</span>
0218                         nodeTypes(i) = NodeType.Sink;
0219                     <span class="keyword">case</span> <span class="string">'Fork'</span>
0220                         nodeTypes(i) = NodeType.Fork;
0221                     <span class="keyword">case</span> <span class="string">'Join'</span>
0222                         nodeTypes(i) = NodeType.Join;
0223                     <span class="keyword">case</span> <span class="string">'Source'</span>
0224                         nodeTypes(i) = NodeType.Source;
0225                 <span class="keyword">end</span>
0226             <span class="keyword">end</span>
0227         <span class="keyword">end</span>
0228 
0229         <a name="_sub20" href="#_subfunctions" class="code">function rtTypes = getRoutingStrategies(self)</a>
0230             rtTypes = zeros(self.getNumberOfNodes,self.getNumberOfClasses);
0231             <span class="keyword">for</span> ind=1:self.getNumberOfNodes
0232                 <span class="keyword">for</span> r=1:self.getNumberOfClasses
0233                     <span class="keyword">switch</span> self.nodes{ind}.output.outputStrategy{r}{2}
0234                         <span class="keyword">case</span> RoutingStrategy.RAND
0235                             rtTypes(ind,r) = RoutingStrategy.ID_RAND;
0236                         <span class="keyword">case</span> RoutingStrategy.PROB
0237                             rtTypes(ind,r) = RoutingStrategy.ID_PROB;
0238                         <span class="keyword">case</span> RoutingStrategy.RR
0239                             rtTypes(ind,r) = RoutingStrategy.ID_RR;
0240                         <span class="keyword">case</span> RoutingStrategy.JSQ
0241                             rtTypes(ind,r) = RoutingStrategy.ID_JSQ;
0242                     <span class="keyword">end</span>
0243                 <span class="keyword">end</span>
0244             <span class="keyword">end</span>
0245         <span class="keyword">end</span>
0246         
0247         <a name="_sub21" href="#_subfunctions" class="code">function nodeIndex = getNodeIndex(self, name)</a>
0248             nodeIndex = find(cellfun(@(c) strcmp(c,name),self.getNodeNames));
0249         <span class="keyword">end</span>
0250         
0251         <a name="_sub22" href="#_subfunctions" class="code">function stationIndex = getStationIndex(self, name)</a>
0252             stationIndex = find(cellfun(@(c) strcmp(c,name),self.getStationNames));
0253         <span class="keyword">end</span>
0254         
0255         <a name="_sub23" href="#_subfunctions" class="code">function classIndex = getClassIndex(self, name)</a>
0256             classIndex = find(cellfun(@(c) strcmp(c,name),self.getClassNames));
0257         <span class="keyword">end</span>
0258         
0259         <a name="_sub24" href="#_subfunctions" class="code">function stationnames = getStationNames(self)</a>
0260             stationnames = {};
0261             <span class="keyword">for</span> i=self.getIndexStations
0262                 stationnames{end+1,1} = self.nodes{i}.name;
0263             <span class="keyword">end</span>
0264         <span class="keyword">end</span>
0265         
0266         <a name="_sub25" href="#_subfunctions" class="code">function statefulnames = getStatefulNodeNames(self)</a>
0267             statefulnames = {};
0268             <span class="keyword">for</span> i=1:self.getNumberOfNodes
0269                 <span class="keyword">if</span> self.nodes{i}.isStateful
0270                     statefulnames{end+1,1} = self.nodes{i}.name;
0271                 <span class="keyword">end</span>
0272             <span class="keyword">end</span>
0273         <span class="keyword">end</span>
0274         
0275         <a name="_sub26" href="#_subfunctions" class="code">function M = getNumberOfNodes(self)</a>
0276             M = length(self.nodes);
0277         <span class="keyword">end</span>
0278         
0279         <a name="_sub27" href="#_subfunctions" class="code">function S = getNumberOfStatefulNodes(self)</a>
0280             S = sum(cellisa(self.nodes,<span class="string">'StatefulNodes'</span>));
0281         <span class="keyword">end</span>
0282         
0283         <a name="_sub28" href="#_subfunctions" class="code">function M = getNumberOfStations(self)</a>
0284             M = length(self.stations);
0285         <span class="keyword">end</span>
0286         
0287         <a name="_sub29" href="#_subfunctions" class="code">function R = getNumberOfClasses(self)</a>
0288             R = length(self.classes);
0289         <span class="keyword">end</span>
0290         
0291         <a name="_sub30" href="#_subfunctions" class="code">function C = getNumberOfChains(self)</a>
0292             qn = self.getStruct;
0293             C = qn.nchains;
0294         <span class="keyword">end</span>
0295         
0296         <a name="_sub31" href="#_subfunctions" class="code">function Dchain = getDemandsChain(self)</a>
0297             qn = self.getStruct;
0298             M = qn.nstations;    <span class="comment">%number of stations</span>
0299             K = qn.nclasses;    <span class="comment">%number of classes</span>
0300             mu = qn.mu;
0301             phi = qn.phi;
0302             C = qn.nchains;
0303             
0304             PH=cell(M,K);
0305             <span class="keyword">for</span> i=1:M
0306                 <span class="keyword">for</span> k=1:K
0307                     <span class="keyword">if</span> length(mu{i,k})==1
0308                         PH{i,k} = map_exponential(1/mu{i,k});
0309                     <span class="keyword">else</span>
0310                         D0 = diag(-mu{i,k})+diag(mu{i,k}(1:end-1).*(1-phi{i,k}(1:end-1)),1);
0311                         D1 = zeros(size(D0));
0312                         D1(:,1)=(phi{i,k}.*mu{i,k});
0313                         PH{i,k} = map_normalize({D0,D1});
0314                     <span class="keyword">end</span>
0315                 <span class="keyword">end</span>
0316             <span class="keyword">end</span>
0317             
0318             <span class="comment">% determine service times</span>
0319             ST = zeros(M,K);
0320             <span class="keyword">for</span> k = 1:K
0321                 <span class="keyword">for</span> i=1:M
0322                     ST(i,k) = 1 ./ map_lambda(PH{i,k});
0323                 <span class="keyword">end</span>
0324             <span class="keyword">end</span>
0325             ST(isnan(ST))=0;
0326             
0327             alpha = zeros(qn.nstations,qn.nclasses);
0328             Vchain = zeros(qn.nstations,qn.nchains);
0329             <span class="keyword">for</span> c=1:qn.nchains
0330                 inchain = find(qn.chains(c,:));
0331                 <span class="keyword">for</span> i=1:qn.nstations
0332                     Vchain(i,c) = sum(qn.visits{c}(i,inchain)) / sum(qn.visits{c}(qn.refstat(inchain(1)),inchain));
0333                     <span class="keyword">for</span> k=inchain
0334                         alpha(i,k) = alpha(i,k) + qn.visits{c}(i,k) / sum(qn.visits{c}(i,inchain));
0335                     <span class="keyword">end</span>
0336                 <span class="keyword">end</span>
0337             <span class="keyword">end</span>
0338             Vchain(~isfinite(Vchain))=0;
0339             alpha(~isfinite(alpha))=0;
0340             
0341             Dchain = zeros(M,C);
0342             STchain = zeros(M,C);
0343             
0344             refstatchain = zeros(C,1);
0345             <span class="keyword">for</span> c=1:qn.nchains
0346                 inchain = find(qn.chains(c,:));
0347                 isOpenChain = any(isinf(qn.njobs(inchain)));
0348                 <span class="keyword">for</span> i=1:qn.nstations
0349                     <span class="comment">% we assume that the visits in L(i,inchain) are equal to 1</span>
0350                     STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0351                     <span class="keyword">if</span> isOpenChain &amp;&amp; i == qn.refstat(inchain(1)) <span class="comment">% if this is a source ST = 1 / arrival rates</span>
0352                         STchain(i,c) = 1 / sumfinite(qn.rates(i,inchain)); <span class="comment">% ignore degenerate classes with zero arrival rates</span>
0353                     <span class="keyword">else</span>
0354                         STchain(i,c) = ST(i,inchain) * alpha(i,inchain)';
0355                     <span class="keyword">end</span>
0356                     Dchain(i,c) = Vchain(i,c) * STchain(i,c);
0357                 <span class="keyword">end</span>
0358                 refstatchain(c) = qn.refstat(inchain(1));
0359                 <span class="keyword">if</span> any((qn.refstat(inchain(1))-refstatchain(c))~=0)
0360                     error(sprintf(<span class="string">'Classes in chain %d have different reference station.'</span>,c));
0361                 <span class="keyword">end</span>
0362             <span class="keyword">end</span>
0363             Dchain(~isfinite(Dchain))=0;
0364         <span class="keyword">end</span>
0365                
0366         <span class="comment">% setUsedFeatures : records that a certain language feature has been used</span>
0367         <a name="_sub32" href="#_subfunctions" class="code">function self = setUsedFeatures(self,className)</a>
0368             self.usedFeatures.setTrue(className);
0369         <span class="keyword">end</span>
0370         
0371         <span class="comment">%% Add the components to the model</span>
0372         <a href="addJobClass.html" class="code" title="function addJobClass(self, customerClass)">addJobClass</a>(self, customerClass);
0373         <a href="addNode.html" class="code" title="function addNode(self, node)">addNode</a>(self, node);
0374         <a href="addLink.html" class="code" title="function addLink(self, nodeA, nodeB)">addLink</a>(self, nodeA, nodeB);
0375         <a href="addLinks.html" class="code" title="function addLinks(self, nodesList)">addLinks</a>(self, nodeList);
0376         
0377         <a href="addMetric.html" class="code" title="function addMetric(self, perfIndex)">addMetric</a>(self, performanceIndex);
0378         self = <a href="disableMetric.html" class="code" title="function self = disableMetric(self, Y)">disableMetric</a>(self, Y);
0379         self = <a href="enableMetric.html" class="code" title="function self = enableMetric(self, Y)">enableMetric</a>(self, Y);
0380         
0381         node = <a href="getSource.html" class="code" title="function node = getSource(self)">getSource</a>(self);
0382         node = <a href="getSink.html" class="code" title="function node = getSink(self)">getSink</a>(self);
0383         
0384         <a name="_sub33" href="#_subfunctions" class="code">function list = getIndexStations(self)</a>
0385             <span class="comment">% returns the ids of nodes that are stations</span>
0386             list = find(cellisa(self.nodes, <span class="string">'Station'</span>))';
0387         <span class="keyword">end</span>
0388         
0389         <a name="_sub34" href="#_subfunctions" class="code">function list = getIndexStatefulNodes(self)</a>
0390             <span class="comment">% returns the ids of nodes that are stations</span>
0391             list = find(cellisa(self.nodes, <span class="string">'StatefulNode'</span>))';
0392         <span class="keyword">end</span>
0393         
0394         <span class="comment">%% Analysis of model features and available solvers</span>
0395         
0396         <span class="comment">%         function listAvailableSolvers(self)</span>
0397         <span class="comment">%             fprintf(1,'This model can be analyzed by the following solvers:\n');</span>
0398         <span class="comment">%             if SolverMVA.supports(self)</span>
0399         <span class="comment">%                 fprintf(1,'SolverMVA\n');</span>
0400         <span class="comment">%             end</span>
0401         <span class="comment">%             if SolverCTMC.supports(self)</span>
0402         <span class="comment">%                 fprintf(1,'SolverCTMC\n');</span>
0403         <span class="comment">%             end</span>
0404         <span class="comment">%             if SolverFluid.supports(self)</span>
0405         <span class="comment">%                 fprintf(1,'SolverFluid\n');</span>
0406         <span class="comment">%             end</span>
0407         <span class="comment">%             if SolverJMT.supports(self)</span>
0408         <span class="comment">%                 fprintf(1,'SolverJMT\n');</span>
0409         <span class="comment">%             end</span>
0410         <span class="comment">%             if SolverSSA.supports(self)</span>
0411         <span class="comment">%                 fprintf(1,'SolverSSA\n');</span>
0412         <span class="comment">%             end</span>
0413         <span class="comment">%         end</span>
0414         
0415         index = <a href="getIndexSourceStation.html" class="code" title="function index = getIndexSourceStation(self)">getIndexSourceStation</a>(self);
0416         index = <a href="getIndexSourceNode.html" class="code" title="function index = getIndexSourceNode(self)">getIndexSourceNode</a>(self);
0417         index = <a href="getIndexSinkNode.html" class="code" title="function index = getIndexSinkNode(self)">getIndexSinkNode</a>(self);
0418         
0419         N = <a href="getNumberOfJobs.html" class="code" title="function N = getNumberOfJobs(self)">getNumberOfJobs</a>(self);
0420         refstat = <a href="getReferenceStations.html" class="code" title="function refstat = getReferenceStations(self)">getReferenceStations</a>(self);
0421         sched = <a href="getStationScheduling.html" class="code" title="function sched = getStationScheduling(self)">getStationScheduling</a>(self);
0422         S = <a href="getStationServers.html" class="code" title="function S = getStationServers(self)">getStationServers</a>(self);
0423         
0424         <a name="_sub35" href="#_subfunctions" class="code">function jsimwView(self)</a>
0425             s=SolverJMT(self,struct(),jmtGetPath); s.jsimwView;
0426         <span class="keyword">end</span>
0427         
0428         <a name="_sub36" href="#_subfunctions" class="code">function jsimgView(self)</a>
0429             s=SolverJMT(self,struct(),jmtGetPath); s.jsimgView;
0430         <span class="keyword">end</span>
0431         
0432         <a name="_sub37" href="#_subfunctions" class="code">function [ni, nir, sir, kir] = initToMarginal(self)</a>
0433             ni = {}; nir = {}; sir = {}; kir = {};
0434             qn = self.getStruct;
0435             <span class="keyword">for</span> ist=1:length(self.stations)
0436                 <span class="keyword">if</span> ~isempty(self.stations{ist}.getState())
0437                     [ni{ist,1}, nir{ist,1}, sir{ist,1}, kir{ist,1}] = State.toMarginal(qn,qn.stationToNode(ist),state);
0438                 <span class="keyword">end</span>
0439             <span class="keyword">end</span>
0440         <span class="keyword">end</span>
0441         
0442         <a name="_sub38" href="#_subfunctions" class="code">function [isvalid] = isStateValid(self)</a>
0443             qn = self.getStruct;
0444             nir = [];
0445             sir = [];
0446             <span class="keyword">for</span> ist=1:qn.nstations
0447                 isf = qn.stationToStateful(ist);
0448                 [~, nir(ist,:), sir(ist,:), ~] = State.toMarginal(qn, qn.stationToNode(ist), qn.state{isf});
0449             <span class="keyword">end</span>
0450             isvalid = State.isValid(qn, nir, sir);
0451         <span class="keyword">end</span>
0452         
0453         <a name="_sub39" href="#_subfunctions" class="code">function [initialState, priorInitialState] = getState(self) </a><span class="comment">% get initial state</span>
0454             <span class="keyword">if</span> ~self.hasInitState
0455                 self.initDefault;
0456             <span class="keyword">end</span>
0457             initialState = {};
0458             priorInitialState = {};
0459             <span class="keyword">for</span> ind=1:length(self.nodes)
0460                 <span class="keyword">if</span> self.nodes{ind}.isStateful
0461                     initialState{end+1,1} = self.nodes{ind}.getState();
0462                     priorInitialState{end+1,1} = self.nodes{ind}.getStatePrior();
0463                 <span class="keyword">end</span>
0464             <span class="keyword">end</span>
0465         <span class="keyword">end</span>
0466         
0467         <a name="_sub40" href="#_subfunctions" class="code">function initFromAvgQLen(self, AvgQLen)</a>
0468             n = round(AvgQLen);
0469             njobs = sum(n,1);
0470             <span class="comment">% we now address the problem that round([0.5,0.5]) = [1,1] so</span>
0471             <span class="comment">% different from the total initial population</span>
0472             <span class="keyword">for</span> r=1:size(AvgQLen,2)
0473                 <span class="keyword">if</span> njobs(r) &gt; sum(AvgQLen,1) <span class="comment">% error at most by 1</span>
0474                     i = maxpos(n(:,r));
0475                     n(i,r) = n(i,r) - 1;
0476                     njobs = sum(n,1)';
0477                 <span class="keyword">end</span>
0478             <span class="keyword">end</span>
0479             self.initFromMarginal(n);
0480         <span class="keyword">end</span>
0481         
0482         <a name="_sub41" href="#_subfunctions" class="code">function initDefault(self)</a>
0483             <span class="comment">% open classes empty</span>
0484             <span class="comment">% closed classes initialized at ref station</span>
0485             <span class="comment">% running jobs are allocated in class id order until all</span>
0486             <span class="comment">% servers are busy</span>
0487             self.refreshStruct();  <span class="comment">% we force update of the model before we initialize</span>
0488             qn = self.getStruct(false);
0489             N = qn.njobs';
0490             <span class="keyword">for</span> i=1:self.getNumberOfNodes
0491                 <span class="keyword">if</span> qn.isstation(i)
0492                     n0 = zeros(1,length(N));
0493                     s0 = zeros(1,length(N));
0494                     s = qn.nservers(qn.nodeToStation(i)); <span class="comment">% allocate</span>
0495                     <span class="keyword">for</span> r=find(isfinite(N))' <span class="comment">% for all closed classes</span>
0496                         <span class="keyword">if</span> qn.nodeToStation(i) == qn.refstat(r)
0497                             n0(r) = N(r);
0498                         <span class="keyword">end</span>
0499                         s0(r) = min(n0(r),s);
0500                         s = s - s0(r);
0501                     <span class="keyword">end</span>
0502                     state_i = State.fromMarginalAndStarted(qn,i,n0(:)',s0(:)');
0503                     <span class="keyword">switch</span> qn.nodetype(i)
0504                         <span class="keyword">case</span> NodeType.Cache
0505                             state_i = [state_i, 1:qn.nvars(i)];
0506                     <span class="keyword">end</span>
0507                     <span class="keyword">switch</span> qn.routing(i)
0508                         <span class="keyword">case</span> RoutingStrategy.ID_RR
0509                             <span class="comment">% start from first connected queue</span>
0510                             state_i = [state_i, find(qn.rt(i,:),1)];
0511                     <span class="keyword">end</span>
0512                     <span class="keyword">if</span> isempty(state_i)
0513                         error(<span class="string">'Default initialization failed on station %d.'</span>,i);
0514                     <span class="keyword">else</span>
0515                         self.nodes{i}.setState(state_i);
0516                         prior_state_i = zeros(1,size(state_i,1)); prior_state_i(1) = 1;
0517                         self.nodes{i}.setStatePrior(prior_state_i);
0518                     <span class="keyword">end</span>
0519                 <span class="keyword">elseif</span> qn.isstateful(i) <span class="comment">% not a station</span>
0520                     <span class="keyword">switch</span> class(self.nodes{i})
0521                         <span class="keyword">case</span> <span class="string">'Cache'</span>
0522                             state_i = zeros(1,self.getNumberOfClasses);
0523                             state_i = [state_i, 1:sum(self.nodes{i}.itemLevelCap)];
0524                             self.nodes{i}.setState(state_i);
0525                         <span class="keyword">otherwise</span>
0526                             self.nodes{i}.setState([]);
0527                     <span class="keyword">end</span>
0528                     <span class="comment">%error('Default initialization not available on stateful node %d.',i);</span>
0529                 <span class="keyword">end</span>
0530             <span class="keyword">end</span>
0531             <span class="comment">%if self.isStateValid % problem with example_initState_2</span>
0532             self.isInitialized = true;
0533             <span class="comment">%else</span>
0534             <span class="comment">%    error('Default initialization failed.');</span>
0535             <span class="comment">%end</span>
0536         <span class="keyword">end</span>
0537         
0538         <a name="_sub42" href="#_subfunctions" class="code">function initFromMarginal(self, n, options) </a><span class="comment">% n(i,r) : number of jobs of class r in node i</span>
0539             qn = self.getStruct();
0540             <span class="keyword">if</span> ~exist(<span class="string">'options'</span>,<span class="string">'var'</span>)
0541                 options = Solver.defaultOptions;
0542             <span class="keyword">end</span>
0543             [isvalidn] = State.isValid(qn, n, [], options);
0544             <span class="keyword">if</span> ~isvalidn
0545                 error(<span class="string">'The specified state does not have the correct number of jobs.'</span>);
0546             <span class="keyword">end</span>
0547             <span class="keyword">for</span> ind=1:qn.nnodes
0548                 <span class="keyword">if</span> qn.isstateful(ind)
0549                     ist = qn.nodeToStation(ind);
0550                     self.nodes{ind}.setState(State.fromMarginal(qn,ind,n(ist,:)));
0551                     <span class="keyword">if</span> isempty(self.nodes{ind}.getState)
0552                         error(sprintf(<span class="string">'Invalid state assignment for station %d.'</span>,ind));
0553                     <span class="keyword">end</span>
0554                 <span class="keyword">end</span>
0555             <span class="keyword">end</span>
0556             self.isInitialized = true;
0557         <span class="keyword">end</span>
0558         
0559         <a name="_sub43" href="#_subfunctions" class="code">function initFromMarginalAndRunning(self, n, s, options) </a><span class="comment">% n(i,r) : number of jobs of class r in node i</span>
0560             qn = self.getStruct();
0561             [isvalidn] = State.isValid(qn, n, s);
0562             <span class="keyword">if</span> ~isvalidn
0563                 error(<span class="string">'Initial state is not valid.'</span>);
0564             <span class="keyword">end</span>
0565             <span class="keyword">for</span> i=1:self.getNumberOfNodes
0566                 <span class="keyword">if</span> self.nodes{i}.isStateful
0567                     self.nodes{i}.setState(State.fromMarginalAndRunning(qn,i,n(i,:),s(i,:)));
0568                     <span class="keyword">if</span> isempty(self.nodes{i}.getState)
0569                         error(sprintf(<span class="string">'Invalid state assignment for station %d\n'</span>,i));
0570                     <span class="keyword">end</span>
0571                 <span class="keyword">end</span>
0572             <span class="keyword">end</span>
0573             self.isInitialized = true;
0574         <span class="keyword">end</span>
0575         
0576         <a name="_sub44" href="#_subfunctions" class="code">function initFromMarginalAndStarted(self, n, s, options) </a><span class="comment">% n(i,r) : number of jobs of class r in node i</span>
0577             qn = self.getStruct();
0578             [isvalidn] = State.isValid(qn, n, s);
0579             <span class="keyword">if</span> ~isvalidn
0580                 error(<span class="string">'Initial state is not valid.'</span>);
0581             <span class="keyword">end</span>
0582             <span class="keyword">for</span> ind=1:self.getNumberOfNodes
0583                 <span class="keyword">if</span> self.nodes{ind}.isStateful
0584                     ist = qn.nodeToStation(ind);
0585                     self.nodes{ind}.setState(State.fromMarginalAndStarted(qn,ind,n(ist,:),s(ist,:)));
0586                     <span class="keyword">if</span> isempty(self.nodes{ind}.getState)
0587                         error(sprintf(<span class="string">'Invalid state assignment for station %d\n'</span>,ind));
0588                     <span class="keyword">end</span>
0589                 <span class="keyword">end</span>
0590             <span class="keyword">end</span>
0591             self.isInitialized = true;
0592         <span class="keyword">end</span>
0593         
0594         <a name="_sub45" href="#_subfunctions" class="code">function [H,G] = getGraph(self)</a>
0595             G = digraph(); TG = Table();
0596             M = self.getNumberOfNodes;
0597             K = self.getNumberOfClasses;
0598             qn = self.getStruct;
0599             [P,Pnodes] = self.getRoutingMatrix();
0600             name = {}; sched = {}; type = {};
0601             <span class="keyword">for</span> i=1:M
0602                 name{end+1} = self.nodes{i}.name;
0603                 type{end+1} = class(self.nodes{i});
0604                 sched{end+1} = self.nodes{i}.schedStrategy;
0605             <span class="keyword">end</span>
0606             TG.Name = name(:);
0607             TG.Type = type(:);
0608             TG.Sched = sched(:);
0609             G = G.addnode(TG);
0610             <span class="keyword">for</span> i=1:M
0611                 <span class="keyword">for</span> j=1:M
0612                     <span class="keyword">for</span> k=1:K
0613                         <span class="keyword">if</span> Pnodes((i-1)*K+k,(j-1)*K+k) &gt; 0
0614                             G = G.addedge(self.nodes{i}.name,self.nodes{j}.name, Pnodes((i-1)*K+k,(j-1)*K+k));
0615                         <span class="keyword">end</span>
0616                     <span class="keyword">end</span>
0617                 <span class="keyword">end</span>
0618             <span class="keyword">end</span>
0619             H = digraph(); TH = Table();
0620             I = self.getNumberOfStations;
0621             name = {}; sched = {}; type = {}; jobs = zeros(I,1);
0622             <span class="keyword">for</span> i=1:I
0623                 name{end+1} = self.stations{i}.name;
0624                 type{end+1} = class(self.stations{i});
0625                 sched{end+1} = self.stations{i}.schedStrategy;
0626                 <span class="keyword">for</span> k=1:K
0627                     <span class="keyword">if</span> qn.refstat(k)==i
0628                         jobs(i) = jobs(i) + qn.njobs(k);
0629                     <span class="keyword">end</span>
0630                 <span class="keyword">end</span>
0631             <span class="keyword">end</span>
0632             TH.Name = name(:);
0633             TH.Type = type(:);
0634             TH.Sched = sched(:);
0635             TH.Jobs = jobs(:);
0636             H = H.addnode(TH);
0637             rate = [];
0638             classes = {};
0639             <span class="keyword">for</span> i=1:I
0640                 <span class="keyword">for</span> j=1:I
0641                     <span class="keyword">for</span> k=1:K
0642                         <span class="keyword">if</span> P((i-1)*K+k,(j-1)*K+k) &gt; 0
0643                             rate(end+1) = qn.rates(i,k);
0644                             classes{end+1} = self.classes{k}.name;
0645                             H = H.addedge(self.stations{i}.name, self.stations{j}.name, P((i-1)*K+k,(j-1)*K+k));
0646                         <span class="keyword">end</span>
0647                     <span class="keyword">end</span>
0648                 <span class="keyword">end</span>
0649             <span class="keyword">end</span>
0650             H.Edges.Rate = rate(:);
0651             H.Edges.Class = classes(:);
0652             H = H.rmedge(find(isnan(H.Edges.Rate)));
0653             sourceObj = self.getSource;
0654             <span class="keyword">if</span> ~isempty(sourceObj)
0655                 <span class="comment">%                 sink = self.getSink;</span>
0656                 <span class="comment">%                 H=H.addnode(sink.name);</span>
0657                 <span class="comment">%                 H.Nodes.Type{end}='Sink';</span>
0658                 <span class="comment">%                 H.Nodes.Sched{end}='ext';</span>
0659                 <span class="comment">%H = H.rmedge(find(isnan(H.Edges.Rate)));</span>
0660                 <span class="comment">%sourceIdx = model.getIndexSourceNode;</span>
0661                 <span class="comment">%                toDel = findstring(H.Edges.EndNodes(:,2),sourceObj.name);</span>
0662                 <span class="comment">%                for j=toDel(:)'</span>
0663                 <span class="comment">%                    H = H.rmedge(j);</span>
0664                 <span class="comment">%                end</span>
0665             <span class="keyword">end</span>
0666         <span class="keyword">end</span>
0667         
0668         <a name="_sub46" href="#_subfunctions" class="code">function mask = getClassSwitchingMask(self)</a>
0669             mask = self.getStruct.csmask;
0670         <span class="keyword">end</span>
0671         
0672         <a name="_sub47" href="#_subfunctions" class="code">function printRoutingMatrix(self)</a>
0673             node_names = self.getNodeNames;
0674             classnames = self.getClassNames;
0675             [~,Pnodes] = self.getRoutingMatrix(); <span class="comment">% get routing matrix</span>
0676             M = self.getNumberOfNodes;
0677             K = self.getNumberOfClasses;
0678             <span class="keyword">for</span> i=1:M
0679                 <span class="keyword">for</span> r=1:K
0680                     <span class="keyword">for</span> j=1:M
0681                         <span class="keyword">for</span> s=1:K
0682                             <span class="keyword">if</span> Pnodes((i-1)*K+r,(j-1)*K+s)&gt;0
0683                                 fprintf(<span class="string">'%s [class: %s] =&gt; %s [class: %s] : Pr=%f\n'</span>,node_names{i}, classnames{r}, node_names{j}, classnames{s},Pnodes((i-1)*K+r,(j-1)*K+s));
0684                             <span class="keyword">end</span>
0685                         <span class="keyword">end</span>
0686                     <span class="keyword">end</span>
0687                 <span class="keyword">end</span>
0688             <span class="keyword">end</span>
0689         <span class="keyword">end</span>
0690         
0691         <span class="comment">%        function self = isValid(self)</span>
0692         <span class="comment">%% todo</span>
0693         <span class="comment">%        end</span>
0694         
0695         <a name="_sub48" href="#_subfunctions" class="code">function self = update(self)</a>
0696             self.refreshStruct();
0697         <span class="keyword">end</span>
0698         
0699         <a name="_sub49" href="#_subfunctions" class="code">function self = refresh(self)</a>
0700             self.refreshStruct();
0701         <span class="keyword">end</span>
0702         
0703     <span class="keyword">end</span>
0704     
0705     <span class="comment">% Private methods</span>
0706     methods (Access = <span class="string">'private'</span>)
0707         
0708         <a name="_sub50" href="#_subfunctions" class="code">function out = getModelNameExtension(self)</a>
0709             out = [getModelName(self), [<span class="string">'.'</span>, self.fileFormat]];
0710         <span class="keyword">end</span>
0711         
0712         <a name="_sub51" href="#_subfunctions" class="code">function self = initUsedFeatures(self)</a>
0713             <span class="comment">% The list includes all classes but Model and Hidden or</span>
0714             <span class="comment">% Constant or Abstract or Solvers</span>
0715             self.usedFeatures = SolverFeatureSet;
0716         <span class="keyword">end</span>
0717     <span class="keyword">end</span>
0718     
0719     methods(Access = protected)
0720         <span class="comment">% Override copyElement method:</span>
0721         <a name="_sub52" href="#_subfunctions" class="code">function clone = copyElement(self)</a>
0722             <span class="comment">% Make a shallow copy of all properties</span>
0723             clone = <a href="#_sub53" class="code" title="subfunction clone = copyElement(self)">copyElement</a>@Copyable(self);
0724             <span class="comment">% Make a deep copy of each handle</span>
0725             <span class="keyword">for</span> i=1:length(self.classes)
0726                 clone.classes{i} = self.classes{i}.copy;
0727             <span class="keyword">end</span>
0728             <span class="comment">% Make a deep copy of each handle</span>
0729             <span class="keyword">for</span> i=1:length(self.nodes)
0730                 clone.nodes{i} = self.nodes{i}.copy;
0731                 <span class="keyword">if</span> isa(clone.nodes{i},<span class="string">'Station'</span>)
0732                     clone.stations{i} = clone.nodes{i};
0733                 <span class="keyword">end</span>
0734                 <span class="keyword">for</span> l=1:length(self.links)
0735                     <span class="keyword">for</span> j=1:length(self.links{l})
0736                         <span class="keyword">if</span> strcmp(self.links{l}{1}.name, self.nodes{i}.name)
0737                             clone.links{l}{1} = clone.nodes{i};
0738                         <span class="keyword">end</span>
0739                         <span class="keyword">if</span> strcmp(self.links{l}{2}.name, self.nodes{i}.name)
0740                             clone.links{l}{2} = clone.nodes{i};
0741                         <span class="keyword">end</span>
0742                     <span class="keyword">end</span>
0743                 <span class="keyword">end</span>
0744             <span class="keyword">end</span>
0745             
0746             <span class="comment">% Metric objects do not contain object handles</span>
0747             <span class="keyword">for</span> i=1:length(self.perfIndex.Avg)
0748                 clone.perfIndex.Avg{i} = self.perfIndex.Avg{i}.copy;
0749             <span class="keyword">end</span>
0750             <span class="keyword">for</span> i=1:length(self.perfIndex.Tran)
0751                 clone.perfIndex.Tran{i} = self.perfIndex.Tran{i}.copy;
0752             <span class="keyword">end</span>
0753         <span class="keyword">end</span>
0754     <span class="keyword">end</span>
0755     
0756     methods
0757         <a name="_sub53" href="#_subfunctions" class="code">function bool = hasFCFS(self)</a>
0758             bool = false;
0759             i = findstring(self.getStruct.sched,SchedStrategy.FCFS);
0760             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0761         <span class="keyword">end</span>
0762         
0763         <a name="_sub54" href="#_subfunctions" class="code">function bool = hasHomogeneousScheduling(self, strategy)</a>
0764             bool = length(findstring(self.getStruct.sched,strategy)) == self.getStruct.nstations;
0765         <span class="keyword">end</span>
0766         
0767         <a name="_sub55" href="#_subfunctions" class="code">function bool = hasDPS(self)</a>
0768             bool = false;
0769             i = findstring(self.getStruct.sched,SchedStrategy.DPS);
0770             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0771         <span class="keyword">end</span>
0772         
0773         <a name="_sub56" href="#_subfunctions" class="code">function bool = hasGPS(self)</a>
0774             bool = false;
0775             i = findstring(self.getStruct.sched,SchedStrategy.GPS);
0776             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0777         <span class="keyword">end</span>
0778         
0779         <a name="_sub57" href="#_subfunctions" class="code">function bool = hasINF(self)</a>
0780             bool = false;
0781             i = findstring(self.getStruct.sched,SchedStrategy.INF);
0782             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0783         <span class="keyword">end</span>
0784         
0785         <a name="_sub58" href="#_subfunctions" class="code">function bool = hasPS(self)</a>
0786             bool = false;
0787             i = findstring(self.getStruct.sched,SchedStrategy.PS);
0788             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0789         <span class="keyword">end</span>
0790         
0791         <a name="_sub59" href="#_subfunctions" class="code">function bool = hasRAND(self)</a>
0792             bool = false;
0793             i = findstring(self.getStruct.sched,SchedStrategy.RAND);
0794             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0795         <span class="keyword">end</span>
0796         
0797         <a name="_sub60" href="#_subfunctions" class="code">function bool = hasHOL(self)</a>
0798             bool = false;
0799             i = findstring(self.getStruct.sched,SchedStrategy.HOL);
0800             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0801         <span class="keyword">end</span>
0802         
0803         <a name="_sub61" href="#_subfunctions" class="code">function bool = hasLCFS(self)</a>
0804             bool = false;
0805             i = findstring(self.getStruct.sched,SchedStrategy.LCFS);
0806             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0807         <span class="keyword">end</span>
0808         
0809         <a name="_sub62" href="#_subfunctions" class="code">function bool = hasSEPT(self)</a>
0810             bool = false;
0811             i = findstring(self.getStruct.sched,SchedStrategy.SEPT);
0812             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0813         <span class="keyword">end</span>
0814         
0815         <a name="_sub63" href="#_subfunctions" class="code">function bool = hasLEPT(self)</a>
0816             bool = false;
0817             i = findstring(self.getStruct.sched,SchedStrategy.LEPT);
0818             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0819         <span class="keyword">end</span>
0820         
0821         <a name="_sub64" href="#_subfunctions" class="code">function bool = hasSJF(self)</a>
0822             bool = false;
0823             i = findstring(self.getStruct.sched,SchedStrategy.SJF);
0824             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0825         <span class="keyword">end</span>
0826         
0827         <a name="_sub65" href="#_subfunctions" class="code">function bool = hasLJF(self)</a>
0828             bool = false;
0829             i = findstring(self.getStruct.sched,SchedStrategy.LJF);
0830             <span class="keyword">if</span> i &gt; 0, bool = true; <span class="keyword">end</span>
0831         <span class="keyword">end</span>
0832         
0833         <a name="_sub66" href="#_subfunctions" class="code">function bool = hasMultiClassFCFS(self)</a>
0834             i = findstring(self.getStruct.sched,SchedStrategy.FCFS);
0835             <span class="keyword">if</span> i &gt; 0
0836                 bool = range([self.getStruct.rates(i,:)])&gt;0;
0837             <span class="keyword">else</span>
0838                 bool = false;
0839             <span class="keyword">end</span>
0840         <span class="keyword">end</span>
0841         
0842         <a name="_sub67" href="#_subfunctions" class="code">function bool = hasMultiServer(self)</a>
0843             bool = any(self.getStruct.nservers(isfinite(self.getStruct.nservers)) &gt; 1);
0844         <span class="keyword">end</span>
0845         
0846         <a name="_sub68" href="#_subfunctions" class="code">function bool = hasSingleChain(self)</a>
0847             bool = self.getNumberOfChains == 1;
0848         <span class="keyword">end</span>
0849         
0850         <a name="_sub69" href="#_subfunctions" class="code">function bool = hasMultiChain(self)</a>
0851             bool = self.getNumberOfChains &gt; 1;
0852         <span class="keyword">end</span>
0853         
0854         <a name="_sub70" href="#_subfunctions" class="code">function bool = hasSingleClass(self)</a>
0855             bool = self.getNumberOfClasses == 1;
0856         <span class="keyword">end</span>
0857         
0858         <a name="_sub71" href="#_subfunctions" class="code">function bool = hasMultiClass(self)</a>
0859             bool = self.getNumberOfClasses &gt; 1;
0860         <span class="keyword">end</span>
0861         
0862         <a name="_sub72" href="#_subfunctions" class="code">function bool = hasProductFormSolution(self)</a>
0863             bool = true;
0864             <span class="comment">% language features</span>
0865             featUsed = self.getUsedLangFeatures().list;
0866             <span class="keyword">if</span> featUsed.Fork, bool = false; <span class="keyword">end</span>
0867             <span class="keyword">if</span> featUsed.Join, bool = false; <span class="keyword">end</span>
0868             <span class="keyword">if</span> featUsed.MMPP2, bool = false; <span class="keyword">end</span>
0869             <span class="keyword">if</span> featUsed.Normal, bool = false; <span class="keyword">end</span>
0870             <span class="keyword">if</span> featUsed.Pareto, bool = false; <span class="keyword">end</span>
0871             <span class="keyword">if</span> featUsed.Replayer, bool = false; <span class="keyword">end</span>
0872             <span class="keyword">if</span> featUsed.Uniform, bool = false; <span class="keyword">end</span>
0873             <span class="keyword">if</span> featUsed.Fork, bool = false; <span class="keyword">end</span>
0874             <span class="keyword">if</span> featUsed.Join, bool = false; <span class="keyword">end</span>
0875             <span class="keyword">if</span> featUsed.SchedStrategy_LCFS, bool = false; <span class="keyword">end</span> <span class="comment">% must be LCFS-PR</span>
0876             <span class="keyword">if</span> featUsed.SchedStrategy_SJF, bool = false; <span class="keyword">end</span>
0877             <span class="keyword">if</span> featUsed.SchedStrategy_LJF, bool = false; <span class="keyword">end</span>
0878             <span class="keyword">if</span> featUsed.SchedStrategy_DPS, bool = false; <span class="keyword">end</span>
0879             <span class="keyword">if</span> featUsed.SchedStrategy_GPS, bool = false; <span class="keyword">end</span>
0880             <span class="keyword">if</span> featUsed.SchedStrategy_SEPT, bool = false; <span class="keyword">end</span>
0881             <span class="keyword">if</span> featUsed.SchedStrategy_LEPT, bool = false; <span class="keyword">end</span>
0882             <span class="keyword">if</span> featUsed.SchedStrategy_HOL, bool = false; <span class="keyword">end</span>
0883             <span class="comment">% modelling features</span>
0884             <span class="keyword">if</span> self.hasMultiClassFCFS, bool = false; <span class="keyword">end</span>
0885         <span class="keyword">end</span>
0886         
0887         
0888         <a name="_sub73" href="#_subfunctions" class="code">function addItemSet(self, itemSet)</a>
0889             <span class="keyword">if</span> sum(cellfun(@(x) strcmp(x.name, itemSet.name), self.items))&gt;0
0890                 error(<span class="string">'An item type with name %s already exists.\n'</span>, itemSet.name);
0891             <span class="keyword">end</span>            
0892             nItemSet = size(self.items,1);
0893             itemSet.index = nItemSet+1;
0894             self.items{end+1,1} = itemSet;
0895             self.setUsedFeatures(class(itemSet)); 
0896         <span class="keyword">end</span>        
0897     <span class="keyword">end</span>
0898     
0899     methods (Static)
0900         <a name="_sub74" href="#_subfunctions" class="code">function model = tandemPs(lambda,D)</a>
0901             model = Network.tandemPsInf(lambda,D,[]);
0902         <span class="keyword">end</span>
0903         
0904         <a name="_sub75" href="#_subfunctions" class="code">function model = tandemPsInf(lambda,D,Z)</a>
0905             <span class="keyword">if</span> ~exist(<span class="string">'Z'</span>,<span class="string">'var'</span>)
0906                 Z = [];
0907             <span class="keyword">end</span>
0908             M  = size(D,1);
0909             Mz = size(Z,1);
0910             strategy = {};
0911             <span class="keyword">for</span> i=1:Mz
0912                 strategy{i} = SchedStrategy.INF;
0913             <span class="keyword">end</span>
0914             <span class="keyword">for</span> i=1:M
0915                 strategy{Mz+i} = SchedStrategy.PS;
0916             <span class="keyword">end</span>
0917             model = Network.tandem(lambda,[D;Z],strategy);
0918         <span class="keyword">end</span>
0919         
0920         <a name="_sub76" href="#_subfunctions" class="code">function model = tandemFcfs(lambda,D)</a>
0921             model = Network.tandemFcfsInf(lambda,D,[]);
0922         <span class="keyword">end</span>
0923         
0924         <a name="_sub77" href="#_subfunctions" class="code">function model = tandemFcfsInf(lambda,D,Z)</a>
0925             <span class="keyword">if</span> ~exist(<span class="string">'Z'</span>,<span class="string">'var'</span>)
0926                 Z = [];
0927             <span class="keyword">end</span>
0928             M  = size(D,1);
0929             Mz = size(Z,1);
0930             strategy = {};
0931             <span class="keyword">for</span> i=1:Mz
0932                 strategy{i} = SchedStrategy.INF;
0933             <span class="keyword">end</span>
0934             <span class="keyword">for</span> i=1:M
0935                 strategy{Mz+i} = SchedStrategy.FCFS;
0936             <span class="keyword">end</span>
0937             model = Network.tandem(lambda,[D;Z],strategy);
0938         <span class="keyword">end</span>
0939         
0940         <a name="_sub78" href="#_subfunctions" class="code">function model = tandem(lambda,S,strategy)</a>
0941             <span class="comment">% S(i,r) - mean service time of class r at station i</span>
0942             <span class="comment">% lambda(r) - number of jobs of class r</span>
0943             <span class="comment">% station(i) - scheduling strategy at station i</span>
0944             model = <a href="Network.html" class="code" title="">Network</a>(<span class="string">'Model'</span>);
0945             [M,R] = size(S);
0946             node{1} = Source(model, <span class="string">'Source'</span>);
0947             <span class="keyword">for</span> i=1:M
0948                 <span class="keyword">switch</span> strategy{i}
0949                     <span class="keyword">case</span> SchedStrategy.INF
0950                         node{end+1} = DelayStation(model, [<span class="string">'Station'</span>,num2str(i)]);
0951                     <span class="keyword">otherwise</span>
0952                         node{end+1} = Queue(model, [<span class="string">'Station'</span>,num2str(i)], strategy{i});
0953                 <span class="keyword">end</span>
0954             <span class="keyword">end</span>
0955             node{end+1} = Sink(model, <span class="string">'Sink'</span>);
0956             P = {};
0957             <span class="keyword">for</span> r=1:R
0958                 jobclass{r} = OpenClass(model, [<span class="string">'Class'</span>,num2str(r)], 0);
0959                 P{r} = circul(length(node)); P{r}(<span class="keyword">end</span>,:) = 0;
0960             <span class="keyword">end</span>
0961             <span class="keyword">for</span> r=1:R
0962                 node{1}.setArrival(jobclass{r}, Exp.fitMeanAndSCV(1/lambda(r)));
0963                 <span class="keyword">for</span> i=1:M
0964                     node{1+i}.setService(jobclass{r}, Exp.fitMeanAndSCV(S(i,r)));
0965                 <span class="keyword">end</span>
0966             <span class="keyword">end</span>
0967             model.link(P);
0968         <span class="keyword">end</span>
0969         
0970         <a name="_sub79" href="#_subfunctions" class="code">function model = cyclicPs(N,D)</a>
0971             model = Network.cyclicPsInf(N,D,[]);
0972         <span class="keyword">end</span>
0973         
0974         <a name="_sub80" href="#_subfunctions" class="code">function model = cyclicPsInf(N,D,Z)</a>
0975             <span class="keyword">if</span> ~exist(<span class="string">'Z'</span>,<span class="string">'var'</span>)
0976                 Z = [];
0977             <span class="keyword">end</span>
0978             M  = size(D,1);
0979             Mz = size(Z,1);
0980             strategy = {};
0981             <span class="keyword">for</span> i=1:Mz
0982                 strategy{i} = SchedStrategy.INF;
0983             <span class="keyword">end</span>
0984             <span class="keyword">for</span> i=1:M
0985                 strategy{Mz+i} = SchedStrategy.PS;
0986             <span class="keyword">end</span>
0987             model = Network.cyclic(N,[D;Z],strategy);
0988         <span class="keyword">end</span>
0989         
0990         <a name="_sub81" href="#_subfunctions" class="code">function model = cyclicFcfs(N,D)</a>
0991             model = Network.cyclicFcfsInf(N,D,[]);
0992         <span class="keyword">end</span>
0993         
0994         <a name="_sub82" href="#_subfunctions" class="code">function model = cyclicFcfsInf(N,D,Z)</a>
0995             <span class="keyword">if</span> ~exist(<span class="string">'Z'</span>,<span class="string">'var'</span>)
0996                 Z = [];
0997             <span class="keyword">end</span>
0998             M  = size(D,1);
0999             Mz = size(Z,1);
1000             strategy = {};
1001             <span class="keyword">for</span> i=1:Mz
1002                 strategy{i} = SchedStrategy.INF;
1003             <span class="keyword">end</span>
1004             <span class="keyword">for</span> i=1:M
1005                 strategy{Mz+i} = SchedStrategy.FCFS;
1006             <span class="keyword">end</span>
1007             model = Network.cyclic(N,[D;Z],strategy);
1008         <span class="keyword">end</span>
1009         
1010         <a name="_sub83" href="#_subfunctions" class="code">function model = cyclic(N,D,strategy)</a>
1011             <span class="comment">% L(i,r) - demand of class r at station i</span>
1012             <span class="comment">% N(r) - number of jobs of class r</span>
1013             <span class="comment">% strategy(i) - scheduling strategy at station i</span>
1014             model = <a href="Network.html" class="code" title="">Network</a>(<span class="string">'Model'</span>);
1015             options = Solver.defaultOptions;
1016             [M,R] = size(D);
1017             node = {};
1018             <span class="keyword">for</span> i=1:M
1019                 <span class="keyword">switch</span> strategy{i}
1020                     <span class="keyword">case</span> SchedStrategy.INF
1021                         node{end+1} = DelayStation(model, [<span class="string">'Station'</span>,num2str(i)]);
1022                     <span class="keyword">otherwise</span>
1023                         node{end+1} = Queue(model, [<span class="string">'Station'</span>,num2str(i)], strategy{i});
1024                 <span class="keyword">end</span>
1025             <span class="keyword">end</span>
1026             <span class="keyword">for</span> r=1:R
1027                 jobclass{r} = ClosedClass(model, [<span class="string">'Class'</span>,num2str(r)], N(r), node{1}, 0);
1028                 P{r} = circul(M);
1029             <span class="keyword">end</span>
1030             <span class="keyword">for</span> i=1:M
1031                 <span class="keyword">for</span> r=1:R
1032                     node{i}.setService(jobclass{r}, Exp.fitMeanAndSCV(D(i,r)));
1033                 <span class="keyword">end</span>
1034             <span class="keyword">end</span>
1035             model.link(P);
1036         <span class="keyword">end</span>
1037         
1038         <a name="_sub84" href="#_subfunctions" class="code">function P = serialRouting(varargin)</a>
1039             P = zeros(length(varargin));
1040             <span class="keyword">for</span> i=1:length(varargin)-1
1041                 P(varargin{i},varargin{i+1})=1;
1042             <span class="keyword">end</span>
1043             <span class="keyword">if</span> ~isa(varargin{end},<span class="string">'Sink'</span>)
1044                 P(varargin{end},varargin{1})=1;
1045             <span class="keyword">end</span>
1046             P = P ./ repmat(sum(P,2),1,length(P));
1047             P(isnan(P)) = 0;
1048         <span class="keyword">end</span>
1049 
1050         
1051     <span class="keyword">end</span>
1052 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>