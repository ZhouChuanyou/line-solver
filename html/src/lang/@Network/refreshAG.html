<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of refreshAG</title>
  <meta name="keywords" content="refreshAG">
  <meta name="description" content="getAG : export model in agent representation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="../index.html">lang</a> &gt; <a href="index.html">@Network</a> &gt; refreshAG.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\lang\@Network&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>refreshAG
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>getAG : export model in agent representation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function genAG(self) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> getAG : export model in agent representation
 Copyright (c) 2012-2019, Imperial College London
 All rights reserved.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="Network.html" class="code" title="">Network</a>	</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% getAG : export model in agent representation</span>
0002 <a name="_sub0" href="#_subfunctions" class="code">function genAG(self)</a>
0003 <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0004 <span class="comment">% All rights reserved.</span>
0005 
0006 <span class="comment">% We now generate the global state space</span>
0007 <span class="comment">% parses all but the service processes</span>
0008 M = self.getNumberOfStations();
0009 K = self.getNumberOfClasses();
0010 NK = self.getNumberOfJobs(); NK = NK(:);
0011 classnames = self.getClassNames();
0012 stationnames = self.getStationNames();
0013 S = self.getStationServers();
0014 sched = self.getStationScheduling();
0015 refstat = self.getReferenceStations();
0016 N = sum(NK(isfinite(NK)));
0017 classprio = zeros(1,K);
0018 schedparam = zeros(M,K);
0019 <span class="keyword">for</span> r=1:K
0020     classprio(r) = self.classes{r}.priority;
0021 <span class="keyword">end</span>
0022 
0023 type = zeros(self.getNumberOfStations,1);
0024 <span class="keyword">for</span> i=1:self.getNumberOfStations
0025     <span class="keyword">switch</span> class(self.nodes{i})
0026         <span class="keyword">case</span> <span class="string">'Queue'</span>
0027             type(i) = NodeType.Queue;
0028             <span class="keyword">for</span> k=(length(self.nodes{i}.server.serviceProcess)+1):K
0029                 self.nodes{i}.server.serviceProcess{k} = {[],ServiceStrategy.LI,Disabled()};
0030             <span class="keyword">end</span>
0031         <span class="keyword">case</span> <span class="string">'DelayStation'</span>
0032             type(i) = NodeType.Delay;
0033             <span class="keyword">for</span> k=(length(self.nodes{i}.server.serviceProcess)+1):K
0034                 self.nodes{i}.server.serviceProcess{k} = {[],ServiceStrategy.LI,Disabled()};
0035             <span class="keyword">end</span>
0036             <span class="comment">%                    case 'Sink'</span>
0037             <span class="comment">%                    type(i) = NodeType.Sink;</span>
0038         <span class="keyword">case</span> <span class="string">'Source'</span>
0039             type(i) = NodeType.Source;
0040             <span class="keyword">for</span> k=(length(self.nodes{i}.input.sourceClasses)+1):K
0041                 self.nodes{i}.input.sourceClasses{k} = {[],ServiceStrategy.LI,Disabled()};
0042             <span class="keyword">end</span>
0043     <span class="keyword">end</span>
0044 <span class="keyword">end</span>
0045 
0046 <span class="keyword">for</span> i=1:M
0047     <span class="keyword">for</span> r=1:K
0048         <span class="keyword">if</span> isempty(self.getIndexSourceStation) || i ~= self.getIndexSourceStation
0049             <span class="keyword">if</span> isempty(self.stations{i}.server.serviceProcess{r})
0050                 self.stations{i}.server.serviceProcess{r} = {[],ServiceStrategy.LI,Disabled()};
0051             <span class="keyword">end</span>
0052         <span class="keyword">end</span>
0053     <span class="keyword">end</span>
0054 <span class="keyword">end</span>
0055 
0056 <span class="keyword">for</span> i=1:M
0057     <span class="keyword">for</span> r=1:K
0058         <span class="keyword">if</span> isempty(self.getIndexSourceStation) || i ~= self.getIndexSourceStation
0059             <span class="keyword">if</span> isempty(self.stations{i}.server.serviceProcess{r}) || self.stations{i}.server.serviceProcess{r}{end}.isDisabled || self.stations{i}.server.serviceProcess{r}{end}.isImmediate
0060                 rates(i,r) = NaN;
0061             <span class="keyword">else</span>
0062                 rates(i,r) = 1/self.stations{i}.server.serviceProcess{r}{end}.getMean();
0063             <span class="keyword">end</span>
0064         <span class="keyword">else</span>
0065             <span class="keyword">if</span> isempty(self.stations{i}.input.sourceClasses{r}) || self.stations{i}.input.sourceClasses{r}{end}.isDisabled || self.stations{i}.input.sourceClasses{r}{end}.isImmediate 
0066                 rates(i,r) = NaN;
0067             <span class="keyword">else</span>
0068                 rates(i,r) = 1/self.stations{i}.input.sourceClasses{r}{end}.getMean();
0069             <span class="keyword">end</span>
0070         <span class="keyword">end</span>
0071     <span class="keyword">end</span>
0072     
0073     <span class="keyword">if</span> isempty(self.getIndexSourceStation) || i ~= self.getIndexSourceStation
0074         <span class="keyword">if</span> ~isempty(self.stations{i}.schedStrategyPar)
0075             schedparam(i,:)=self.stations{i}.schedStrategyPar;
0076         <span class="keyword">else</span>
0077             <span class="keyword">switch</span> sched{i}
0078                 <span class="keyword">case</span> SchedStrategy.SEPT
0079                     [~,~,rnk] = unique(1./rates(i,:));
0080                     schedparam(i,:)=rnk';
0081                 <span class="keyword">case</span> SchedStrategy.LEPT
0082                     [~,~,rnk] = unique(rates(i,:));
0083                     schedparam(i,:)=rnk';
0084             <span class="keyword">end</span>
0085         <span class="keyword">end</span>
0086     <span class="keyword">end</span>
0087 <span class="keyword">end</span>
0088 
0089 qn = NetworkStruct(M, K, N, S, rates, sched, rt, NK, eye(K), refstat,nodenames, stationnames, classnames);
0090 <span class="comment">% set zero bufffers for classes that are disabled</span>
0091 <span class="keyword">for</span> i=1:qn.nstations
0092     <span class="keyword">for</span> r=1:qn.nclasses
0093         c = find(qn.chains(:,r)); <span class="comment">% chain of class r</span>
0094         <span class="keyword">if</span> isempty(qn.rates(i,r)) || qn.rates(i,r)==0 || any(~isfinite(qn.rates(i,r)))
0095             qn.classcap(i,r) = 0;
0096         <span class="keyword">else</span>
0097             qn.classcap(i,r) = sum(qn.njobs(find(qn.chains(c,:))));
0098         <span class="keyword">end</span>
0099     <span class="keyword">end</span>
0100     qn.cap(i,1) = sum(qn.classcap(i,:));
0101 <span class="keyword">end</span>
0102 qn.schedparam = schedparam;
0103 [~,~,qn.classprio] = unique(classprio); qn.classprio = qn.classprio';
0104 
0105 M = qn.nstations;
0106 R = qn.nclasses;
0107 N = qn.njobs';
0108 rt = qn.rt;
0109 
0110 <span class="comment">% Then we analyse the queue in isolation with *constant* arrival</span>
0111 <span class="comment">% rate equal to the average arrival rate</span>
0112 <span class="keyword">for</span> i=1:qn.nnodes
0113     isf = qn.nodeToStateful(i);
0114     qn.space{isf} = State.fromMarginalBounds(qn, i, [], qn.classcap(i,:));
0115     <span class="keyword">if</span> isinf(qn.nservers(i))
0116         qn.nservers(i) = sum(N);
0117     <span class="keyword">end</span>
0118 <span class="keyword">end</span>
0119 
0120 <span class="comment">%%</span>
0121 active = 1; <span class="comment">% column of active actions</span>
0122 passive = 2; <span class="comment">% columns of passive actions</span>
0123 eps = M+1; <span class="comment">% row of local actions</span>
0124 sync = {};
0125 actionTable=[];
0126 <span class="keyword">for</span> i=1:M
0127     <span class="keyword">for</span> r=1:R
0128         <span class="keyword">if</span> length(qn.mu{i,r})&gt;1
0129             sync{end+1} = struct(<span class="string">'active'</span>,cell(1),<span class="string">'passive'</span>,cell(1));
0130             sync{end}.active{1} = struct(<span class="string">'node'</span>,NaN,<span class="string">'class'</span>,NaN,<span class="string">'event'</span>,NaN);
0131             sync{end}.passive{1} = struct(<span class="string">'node'</span>,NaN,<span class="string">'class'</span>,NaN,<span class="string">'event'</span>,NaN);
0132             sync{end}.active{1}.(<span class="string">'node'</span>) = i;
0133             sync{end}.passive{1}.(<span class="string">'node'</span>) = eps;
0134             sync{end}.active{1}.(<span class="string">'class'</span>) = r;
0135             sync{end}.active{1}.(<span class="string">'event'</span>) = Event.PHASE;
0136             sync{end}.passive{1}.(<span class="string">'class'</span>) = r;
0137             sync{end}.passive{1}.(<span class="string">'event'</span>) = [];
0138             sync{end}.passive{1}.(<span class="string">'prob'</span>) = 1; <span class="comment">% probability to sync</span>
0139         <span class="keyword">end</span>
0140         <span class="comment">%L(end+1,:) = [i, r, eps, r, Event.PHASE, 0 ];</span>
0141         <span class="keyword">for</span> j=1:M
0142             <span class="keyword">for</span> s=1:R
0143                 state_prob = rt((i-1)*R+r,(j-1)*R+s);
0144                 <span class="keyword">if</span> state_prob &gt; 0
0145                     sync{end+1} = struct(<span class="string">'active'</span>,cell(1),<span class="string">'passive'</span>,cell(1));
0146                     sync{end}.active{1} = struct(<span class="string">'node'</span>,NaN,<span class="string">'class'</span>,NaN,<span class="string">'event'</span>,NaN);
0147                     sync{end}.passive{1} = struct(<span class="string">'node'</span>,NaN,<span class="string">'class'</span>,NaN,<span class="string">'event'</span>,NaN);
0148                     sync{end}.active{1}.(<span class="string">'node'</span>) = i;
0149                     sync{end}.passive{1}.(<span class="string">'node'</span>) = j;
0150                     sync{end}.active{1}.(<span class="string">'class'</span>) = r;
0151                     sync{end}.active{1}.(<span class="string">'event'</span>) = Event.DEP;
0152                     sync{end}.passive{1}.(<span class="string">'class'</span>) = s;
0153                     sync{end}.passive{1}.(<span class="string">'event'</span>) = Event.ARV;
0154                     sync{end}.passive{1}.(<span class="string">'prob'</span>) = state_prob; <span class="comment">% probability to sync</span>
0155                     actionTable(end+1,:) = [i, r, j, s, Event.DEP, Event.ARV];
0156                 <span class="keyword">end</span>
0157             <span class="keyword">end</span>
0158         <span class="keyword">end</span>
0159     <span class="keyword">end</span>
0160 <span class="keyword">end</span>
0161 actionTable = unique(actionTable,<span class="string">'rows'</span>);
0162 <span class="comment">%%</span>
0163 SSh=[];
0164 Q = sparse([]);
0165 A = length(sync);
0166 AP = []; <span class="comment">% AP(a,1)= id of active agent for action a, AP(a,passive) = passive for action a</span>
0167 RL = cell(size(actionTable,1)+1,M); <span class="comment">% RL{a,1}(s1,s2) rate from state s1 to s2 for action a in active agent, RL{a,2}(s1p,s2p) accept probability of passive</span>
0168 <span class="keyword">for</span> j=1:M
0169     jsf = qn.stationToStateful(j);
0170     RL{<span class="keyword">end</span>,j}=zeros(size(qn.space{jsf},1));
0171 <span class="keyword">end</span>
0172 <span class="keyword">for</span> a=1:A
0173     node_a = sync{a}.active{1}.node;
0174     class_a = sync{a}.active{1}.class;
0175     event_a = sync{a}.active{1}.event;
0176     
0177     node_p = sync{a}.passive{1}.node;
0178     class_p = sync{a}.passive{1}.class;
0179     event_p = sync{a}.passive{1}.event; <span class="keyword">if</span> isempty(event_p), event_p=0; <span class="keyword">end</span>
0180     prob_p = sync{a}.passive{1}.prob;
0181     
0182     <span class="keyword">if</span> node_p ~= eps
0183         <span class="keyword">if</span> prob_p &gt; 0
0184             l = matchrow(actionTable,[node_a, class_a, node_p, class_p, event_a, event_p]);
0185             AP(l,active) = node_a; <span class="comment">% active</span>
0186             AP(l,passive) = node_p;
0187             RL{l,active} = zeros(size(qn.space{node_a},1));
0188             RL{l,passive} = zeros(size(qn.space{node_p},1));
0189             <span class="keyword">for</span> s=1:size(SSh,1)
0190                 state = SSh(s,:);
0191                 state_a = state(node_a);
0192                 [new_state_a, rate_a] = stateAfterEventHashed( qn, node_a, state_a, event_a,class_a);
0193                 <span class="keyword">if</span> new_state_a&gt;0
0194                     RL{l,active}(state_a,new_state_a)=rate_a;
0195                     
0196                     node_p = sync{a}.passive{1}.node;
0197                     state_p = state(node_p);
0198                     <span class="keyword">if</span> node_p == node_a <span class="comment">%self-loop</span>
0199                         [new_state_p, ~] = stateAfterEventHashed( qn, node_p, new_state_a, event_p, class_p);
0200                     <span class="keyword">else</span>
0201                         [new_state_p, ~] = stateAfterEventHashed( qn, node_p, state_p, event_p, class_p);
0202                     <span class="keyword">end</span>
0203                     RL{l,passive}(state_p,new_state_p)=prob_p;
0204                 <span class="keyword">end</span>
0205             <span class="keyword">end</span>
0206         <span class="keyword">end</span>
0207     <span class="keyword">else</span> <span class="comment">% local transitions</span>
0208         <span class="keyword">for</span> s=1:size(SSh,1)
0209             state = SSh(s,:);
0210             state_a = state(node_a);
0211             [new_state_a, rate_a] = stateAfterEventHashed(qn, node_a, state_a, event_a, class_a);
0212             <span class="keyword">if</span> new_state_a &gt; 0
0213                 RL{<span class="keyword">end</span>,node_a}(state_a,new_state_a)=RL{<span class="keyword">end</span>,node_a}(state_a,new_state_a)+rate_a;
0214             <span class="keyword">end</span>
0215         <span class="keyword">end</span>
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 todelete = [];
0219 <span class="keyword">for</span> l=1:size(RL,1)-1 <span class="comment">% don't delete local events row</span>
0220     <span class="keyword">if</span> ~any(RL{l,1}(:))
0221         todelete = [todelete l];
0222     <span class="keyword">end</span>
0223 <span class="keyword">end</span>
0224 RL(todelete,:)=[];
0225 AP(todelete,:)=[];
0226 self.ag = struct(<span class="string">'rate'</span>,RL,<span class="string">'role'</span>,AP);
0227 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 14:07:48 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>