<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of NetworkStruct</title>
  <meta name="keywords" content="NetworkStruct">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">src</a> &gt; <a href="index.html">lang</a> &gt; NetworkStruct.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for src\lang&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>NetworkStruct
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="NetworkStruct.html" class="code" title="">NetworkStruct</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="NetworkStruct.html" class="code" title="">NetworkStruct</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function self = NetworkStruct(nodetype, nodenames, classnames, numservers, njobs, refstat, routing)</a></li><li><a href="#_sub2" class="code">function reindex(self)</a></li><li><a href="#_sub3" class="code">function setChains(self, chains, visits, rt, nodes_visits)</a></li><li><a href="#_sub4" class="code">function setSched(self, sched, schedparam)</a></li><li><a href="#_sub5" class="code">function setService(self, rates, scv)</a></li><li><a href="#_sub6" class="code">function setCoxService(self, mu, phi, phases)</a></li><li><a href="#_sub7" class="code">function setCapacity(self, cap, classcap)</a></li><li><a href="#_sub8" class="code">function setPrio(self, prio)</a></li><li><a href="#_sub9" class="code">function setSync(self, sync)</a></li><li><a href="#_sub10" class="code">function setLocalVars(self, nvars, varsparam)</a></li><li><a href="#_sub11" class="code">function setRoutingFunction(self, rtfun, csmask)</a></li><li><a href="#_sub12" class="code">function stat_idx = nd2st(self, node_idx)</a></li><li><a href="#_sub13" class="code">function node_idx = st2nd(self,stat_idx)</a></li><li><a href="#_sub14" class="code">function sful_idx = st2sf(self,stat_idx)</a></li><li><a href="#_sub15" class="code">function sful_idx = nd2sf(self, node_idx)</a></li><li><a href="#_sub16" class="code">function node_idx = sf2nd(self,stat_idx)</a></li><li><a href="#_sub17" class="code">function newObj = copy(obj)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="NetworkStruct.html" class="code" title="">NetworkStruct</a> &lt;handle
0002     <span class="comment">% Copyright (c) 2012-2019, Imperial College London</span>
0003     <span class="comment">% All rights reserved.</span>
0004     
0005     properties
0006         cap;     <span class="comment">% total buffer size</span>
0007         chains;     <span class="comment">% binary CxK matrix where 1 in entry (i,j) indicates that class j is in chain i.</span>
0008         classcap;    <span class="comment">% buffer size for each class</span>
0009         classnames;  <span class="comment">% name of each job class</span>
0010         classprio;       <span class="comment">% scheduling priorities in each class (optional)</span>
0011         csmask; <span class="comment">% (r,s) entry if class r can switch into class s somewhere</span>
0012         <span class="comment">%forks;      % forks table from each station</span>
0013         <span class="comment">% (MKxMK matrix with integer entries), indexed first by</span>
0014         <span class="comment">% station, then by class</span>
0015         isstatedep; <span class="comment">% state dependent routing</span>
0016         isstation; <span class="comment">% element i is true if node i is a station</span>
0017         isstateful; <span class="comment">% element i is true if node i is stateful</span>
0018         mu;          <span class="comment">% service rate in each service phase, for each job class in each station</span>
0019         <span class="comment">% (MxK cell with n_{i,k}x1 double entries)</span>
0020         nchains;           <span class="comment">% number of chains (int)</span>
0021         nclasses;          <span class="comment">% number of classes (int)</span>
0022         nclosedjobs;          <span class="comment">% total population (int)</span>
0023         njobs;             <span class="comment">% initial distribution of jobs in classes (Kx1 int)</span>
0024         nnodes; <span class="comment">% number of nodes (Mn int)</span>
0025         nservers;   <span class="comment">% number of servers per station (Mx1 int)</span>
0026         nstations;  <span class="comment">% number of stations (int)</span>
0027         nstateful;  <span class="comment">% number of stations (int)</span>
0028         nvars; <span class="comment">% number of local variables</span>
0029         nodenames;   <span class="comment">% name of each node</span>
0030         nodevisits;  <span class="comment">% visits placed by classes at the nodes</span>
0031         nodetype; <span class="comment">% server type in each node</span>
0032         phases; <span class="comment">% number of phases in each service or arrival process</span>
0033         phasessz; <span class="comment">% shift for number of phases</span>
0034         phaseshift; <span class="comment">% shift for number of phases</span>
0035         phi;         <span class="comment">% probability of service completion in each service phase,</span>
0036         <span class="comment">% for each job class in each station</span>
0037         <span class="comment">% (MxK cell with n_{i,k}x1 double entries)</span>
0038         rates;       <span class="comment">% service rate for each job class in each station</span>
0039         refstat;    <span class="comment">% index of the reference node for each request class (Kx1 int)</span>
0040         routing;     <span class="comment">% routing strategy type</span>
0041         rt;         <span class="comment">% routing table with class switching</span>
0042         <span class="comment">% (M*K)x(M*K) matrix with double entries), indexed first by</span>
0043         <span class="comment">% station, then by class</span>
0044         rtnodes;         <span class="comment">% routing table with class switching</span>
0045         <span class="comment">% (Mn*K)x(Mn*K) matrix with double entries), indexed first by</span>
0046         <span class="comment">% node, then by class</span>
0047         rtfun; <span class="comment">% local routing functions</span>
0048         <span class="comment">% (Mn*K)x(Mn*K) matrix with double entries), indexed first by</span>
0049         <span class="comment">% station, then by class</span>
0050         sched;       <span class="comment">% scheduling strategy in each station</span>
0051         schedid;       <span class="comment">% scheduling strategy id in each station (optional)</span>
0052         schedparam;       <span class="comment">% scheduling weights in each station and class (optional)</span>
0053         sync;
0054         space;    <span class="comment">% state space</span>
0055         state;    <span class="comment">% initial or current state</span>
0056         scv; <span class="comment">% squared coefficient of variation of service times (MxK)</span>
0057         visits;           <span class="comment">% visits placed by classes at the resources</span>
0058         varsparam;     <span class="comment">% parameters for local variables</span>
0059     <span class="keyword">end</span>
0060     
0061     methods
0062         <span class="comment">%constructor</span>
0063         <a name="_sub0" href="#_subfunctions" class="code">function self = NetworkStruct(nodetype, nodenames, classnames, numservers, njobs, refstat, routing)</a>
0064             self.nnodes = numel(nodenames);
0065             self.nclasses = length(classnames);
0066             self.nclosedjobs = sum(njobs(isfinite(njobs)));
0067             self.nservers = numservers;
0068             self.nodetype = -1*ones(self.nstations,1);
0069             self.scv = ones(self.nstations,self.nclasses);
0070             <span class="comment">%self.forks = zeros(M,K);</span>
0071             self.njobs = njobs(:)';
0072             self.refstat = refstat;
0073             self.space = cell(self.nstations,1);
0074             self.routing = routing;
0075             self.chains = [];
0076             <span class="keyword">if</span> exist(<span class="string">'nvars'</span>,<span class="string">'var'</span>) &amp;&amp; ~isempty(nvars)
0077                 self.nvars = nvars;
0078             <span class="keyword">end</span>
0079             <span class="keyword">if</span> exist(<span class="string">'nodetype'</span>,<span class="string">'var'</span>) &amp;&amp; ~isempty(nodetype)
0080                 self.nodetype = nodetype;
0081                 self.isstation = NodeType.isStation(nodetype);
0082                 self.nstations = sum(self.isstation);
0083                 self.isstateful = NodeType.isStateful(nodetype);
0084                 self.isstatedep = false(self.nnodes,3); <span class="comment">% col 1: buffer, col 2: srv, col 3: routing</span>
0085                 <span class="keyword">for</span> ind=1:self.nnodes
0086                     <span class="keyword">switch</span> self.nodetype(ind)
0087                         <span class="keyword">case</span> NodeType.Cache
0088                             self.isstatedep(ind,2) = true; <span class="comment">% state dependent service</span>
0089                     <span class="keyword">end</span>
0090                     <span class="keyword">for</span> r=1:self.nclasses
0091                         <span class="keyword">switch</span> self.routing(ind,r)
0092                             <span class="keyword">case</span> {RoutingStrategy.ID_RR, RoutingStrategy.ID_JSQ}
0093                                 self.isstatedep(ind,3) = true; <span class="comment">% state dependent routing</span>
0094                         <span class="keyword">end</span>
0095                     <span class="keyword">end</span>
0096                 <span class="keyword">end</span>
0097                 self.nstateful = sum(self.isstateful);
0098                 self.state = cell(self.nstations,1); <span class="keyword">for</span> i=1:self.nstateful self.state{i} = []; <span class="keyword">end</span>
0099             <span class="keyword">end</span>
0100             <span class="keyword">if</span> exist(<span class="string">'nodenames'</span>,<span class="string">'var'</span>)
0101                 self.nodenames = nodenames;
0102             <span class="keyword">else</span>
0103                 self.nodenames = cell(self.nnodes,1);
0104                 <span class="keyword">for</span> j = 1:self.nstations
0105                     self.nodenames{j,1} = int2str(j);
0106                 <span class="keyword">end</span>
0107             <span class="keyword">end</span>
0108             <span class="keyword">if</span> exist(<span class="string">'classnames'</span>,<span class="string">'var'</span>)
0109                 self.classnames = classnames;
0110             <span class="keyword">else</span>
0111                 self.classnames = cell(self.nclasses,1);
0112                 <span class="keyword">for</span> j = 1:self.nclasses
0113                     self.classnames{j,1} = int2str(j);
0114                 <span class="keyword">end</span>
0115             <span class="keyword">end</span>            
0116             self.reindex();
0117         <span class="keyword">end</span>
0118         
0119         <a name="_sub1" href="#_subfunctions" class="code">function reindex(self)</a>
0120             <span class="keyword">for</span> ind=1:self.nnodes
0121                 self.nodeToStateful(ind) = self.nd2sf(ind);
0122                 self.nodeToStation(ind) = self.nd2st(ind);
0123             <span class="keyword">end</span>
0124             <span class="keyword">for</span> ist=1:self.nstations
0125                 self.stationToNode(ist) = self.st2nd(ist);
0126                 self.stationToStateful(ist) = self.st2sf(ist);
0127             <span class="keyword">end</span>
0128             <span class="keyword">for</span> isf=1:self.nstateful
0129                 self.statefulToNode(isf) = self.sf2nd(isf);
0130             <span class="keyword">end</span>            
0131         <span class="keyword">end</span>
0132         
0133         <a name="_sub2" href="#_subfunctions" class="code">function setChains(self, chains, visits, rt, nodes_visits)</a>
0134             self.chains = logical(chains);
0135             self.visits = visits;
0136             self.rt = rt;
0137             self.nchains = size(chains,1);
0138             self.nodevisits = nodes_visits;
0139         <span class="keyword">end</span>
0140         
0141         <a name="_sub3" href="#_subfunctions" class="code">function setSched(self, sched, schedparam)</a>
0142             self.sched = sched;
0143             self.schedparam = schedparam;
0144             self.schedid = zeros(self.nstations,1);
0145             <span class="keyword">for</span> i=1:self.nstations
0146                 self.schedid(i) = SchedStrategy.toId(sched{i});
0147             <span class="keyword">end</span>
0148         <span class="keyword">end</span>
0149         
0150         <a name="_sub4" href="#_subfunctions" class="code">function setService(self, rates, scv)</a>
0151             self.rates = rates;
0152             self.scv = scv;
0153         <span class="keyword">end</span>
0154         
0155         <a name="_sub5" href="#_subfunctions" class="code">function setCoxService(self, mu, phi, phases)</a>
0156             self.mu = mu;
0157             self.phi = phi;
0158             self.phases = phases;
0159             self.phasessz = max(self.phases,ones(size(self.phases)));
0160             self.phaseshift = [zeros(size(phases,1),1),cumsum(self.phasessz,2)];
0161         <span class="keyword">end</span>
0162         
0163         <a name="_sub6" href="#_subfunctions" class="code">function setCapacity(self, cap, classcap)</a>
0164             self.cap = cap;
0165             self.classcap = classcap;
0166         <span class="keyword">end</span>
0167         
0168         <a name="_sub7" href="#_subfunctions" class="code">function setPrio(self, prio)</a>
0169             self.classprio = prio;
0170         <span class="keyword">end</span>
0171         
0172         <a name="_sub8" href="#_subfunctions" class="code">function setSync(self, sync)</a>
0173             self.sync = sync;
0174         <span class="keyword">end</span>
0175         
0176         <a name="_sub9" href="#_subfunctions" class="code">function setLocalVars(self, nvars, varsparam)</a>
0177             self.nvars = nvars;
0178             self.varsparam = varsparam;
0179         <span class="keyword">end</span>
0180         
0181         <a name="_sub10" href="#_subfunctions" class="code">function setRoutingFunction(self, rtfun, csmask)</a>
0182             self.rtfun = rtfun;
0183             self.csmask = csmask;
0184         <span class="keyword">end</span>
0185     <span class="keyword">end</span>
0186     
0187     properties (Access = public)
0188         nodeToStateful;
0189         nodeToStation;
0190         stationToNode;
0191         stationToStateful;
0192         statefulToNode;
0193     <span class="keyword">end</span>
0194     
0195     methods <span class="comment">% index conversion</span>
0196         <a name="_sub11" href="#_subfunctions" class="code">function stat_idx = nd2st(self, node_idx)</a>
0197             <span class="keyword">if</span> self.isstation(node_idx)
0198                 stat_idx = at(cumsum(self.isstation),node_idx);
0199             <span class="keyword">else</span>
0200                 stat_idx = NaN;
0201             <span class="keyword">end</span>
0202         <span class="keyword">end</span>
0203         
0204         <a name="_sub12" href="#_subfunctions" class="code">function node_idx = st2nd(self,stat_idx)</a>
0205             v = cumsum(self.isstation) == stat_idx;
0206             <span class="keyword">if</span> any(v)
0207                 node_idx =  find(v, 1);
0208             <span class="keyword">else</span>
0209                 node_idx = NaN;
0210             <span class="keyword">end</span>
0211         <span class="keyword">end</span>
0212         
0213         <a name="_sub13" href="#_subfunctions" class="code">function sful_idx = st2sf(self,stat_idx)</a>
0214             sful_idx = <a href="#_sub15" class="code" title="subfunction sful_idx = nd2sf(self, node_idx)">nd2sf</a>(self,<a href="#_sub13" class="code" title="subfunction node_idx = st2nd(self,stat_idx)">st2nd</a>(self,stat_idx));
0215         <span class="keyword">end</span>
0216         
0217         <a name="_sub14" href="#_subfunctions" class="code">function sful_idx = nd2sf(self, node_idx)</a>
0218             <span class="keyword">if</span> self.isstateful(node_idx)
0219                 sful_idx = at(cumsum(self.isstateful),node_idx);
0220             <span class="keyword">else</span>
0221                 sful_idx = NaN;
0222             <span class="keyword">end</span>
0223         <span class="keyword">end</span>
0224         
0225         <a name="_sub15" href="#_subfunctions" class="code">function node_idx = sf2nd(self,stat_idx)</a>
0226             v = cumsum(self.isstateful) == stat_idx;
0227             <span class="keyword">if</span> any(v)
0228                 node_idx =  find(v, 1);
0229             <span class="keyword">else</span>
0230                 node_idx = NaN;
0231             <span class="keyword">end</span>
0232         <span class="keyword">end</span>
0233         
0234         <a name="_sub16" href="#_subfunctions" class="code">function newObj = copy(obj)</a>
0235         newObj = <a href="NetworkStruct.html" class="code" title="">NetworkStruct</a>(obj.nodetype, obj.nodenames, obj.classnames, obj.nservers, obj.njobs, obj.refstat, obj.routing);
0236         newObj.cap = obj.cap;     <span class="comment">% total buffer size</span>
0237         newObj.chains = obj.chains;     <span class="comment">% binary CxK matrix where 1 in entry (i,j) indicates that class j is in chain i.</span>
0238         newObj.classcap = obj.classcap;    <span class="comment">% buffer size for each class</span>
0239         newObj.classnames = obj.classnames;  <span class="comment">% name of each job class</span>
0240         newObj.classprio = obj.classprio;       <span class="comment">% scheduling priorities in each class (optional)</span>
0241         newObj.csmask = obj.csmask; <span class="comment">% (r,s) entry if class r can switch into class s somewhere</span>
0242         newObj.isstatedep = obj.isstatedep; <span class="comment">% state dependent routing</span>
0243         newObj.isstation = obj.isstation; <span class="comment">% element i is true if node i is a station</span>
0244         newObj.isstateful = obj.isstateful; <span class="comment">% element i is true if node i is stateful</span>
0245         newObj.mu = obj.mu;          <span class="comment">% service rate in each service phase, for each job class in each station</span>
0246         newObj.nchains = obj.nchains;           <span class="comment">% number of chains (int)</span>
0247         newObj.nclasses = obj.nclasses;          <span class="comment">% number of classes (int)</span>
0248         newObj.nclosedjobs = obj.nclosedjobs;          <span class="comment">% total population (int)</span>
0249         newObj.njobs = obj.njobs;             <span class="comment">% initial distribution of jobs in classes (Kx1 int)</span>
0250         newObj.nnodes = obj.nnodes; <span class="comment">% number of nodes (Mn int)</span>
0251         newObj.nservers = obj.nservers;   <span class="comment">% number of servers per station (Mx1 int)</span>
0252         newObj.nstations = obj.nstations;  <span class="comment">% number of stations (int)</span>
0253         newObj.nstateful = obj.nstateful;  <span class="comment">% number of stations (int)</span>
0254         newObj.nvars = obj.nvars; <span class="comment">% number of local variables</span>
0255         newObj.nodenames = obj.nodenames;   <span class="comment">% name of each node</span>
0256         newObj.nodetype = obj.nodetype; <span class="comment">% server type in each node</span>
0257         newObj.phases = obj.phases; <span class="comment">% number of phases in each service or arrival process</span>
0258         newObj.phasessz = obj.phasessz; <span class="comment">% number of phases in each service or arrival process</span>
0259         newObj.phaseshift = obj.phaseshift; <span class="comment">% number of phases in each service or arrival process</span>
0260         newObj.phi = obj.phi;         <span class="comment">% probability of service completion in each service phase,</span>
0261         newObj.rates = obj.rates;       <span class="comment">% service rate for each job class in each station</span>
0262         newObj.refstat = obj.refstat;    <span class="comment">% index of the reference node for each request class (Kx1 int)</span>
0263         newObj.routing = obj.routing;     <span class="comment">% routing strategy type</span>
0264         newObj.rt = obj.rt;         <span class="comment">% routing table with class switching</span>
0265         newObj.rtnodes = obj.rtnodes;         <span class="comment">% routing table with class switching</span>
0266         newObj.rtfun = obj.rtfun; <span class="comment">% local routing functions</span>
0267         newObj.sched = obj.sched;       <span class="comment">% scheduling strategy in each station</span>
0268         newObj.schedid = obj.schedid;       <span class="comment">% scheduling strategy id in each station (optional)</span>
0269         newObj.schedparam = obj.schedparam;       <span class="comment">% scheduling weights in each station and class (optional)</span>
0270         newObj.sync = obj.sync;
0271         newObj.space = obj.space;    <span class="comment">% state space</span>
0272         newObj.state = obj.state;    <span class="comment">% initial or current state</span>
0273         newObj.scv = obj.scv; <span class="comment">% squared coefficient of variation of service times (MxK)</span>
0274         newObj.visits = obj.visits;           <span class="comment">% visits placed by classes at the resources</span>
0275         newObj.varsparam = obj.varsparam;     <span class="comment">% parameters for local variables</span>
0276         <span class="keyword">end</span>
0277     <span class="keyword">end</span> <span class="comment">% getIndex</span>
0278 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 19-Mar-2019 19:15:18 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>