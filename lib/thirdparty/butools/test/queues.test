// inputmsg: indicates the beginning of input parameters. Just prints a message, nothing else. For doc examples it is ignored.
// testmsg: indicates the beginning of input parameters. Just prints a message, nothing else. For doc examples it is ignored.
// defvec/defmat/defrange/defvar: define a parameter. If it is followed by @, it is printed to the screen, except for doc examples
// code: some source code. !: announce execution of code (except for doc examples), @: print output after executing the code

package Queues

test QBDQueue

inputmsg
defmat@ B # {{6., 1., 0.},{0., 4., 1.},{2., 0., 0.}}
defmat@ F # {{0., 1., 1.},{5., 0., 0.},{1., 3., 0.}} 
defmat@ L # {{-14., 3., 2.},{0., -14., 4.},{3., 1., -10.}} 
code@ L0 = L+B
code$ BuTools`Verbose = False
code$ {pi0, R} = QBDSolve [B, L, F, L0]
code$ lambd = Sum[pi0.Inv[Eye[Dim1[R]]-R].F]
code$ BuTools`Verbose = True
testmsg
code!@ {ncd,ncm} = QBDQueue[B, L, F, L0, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = QBDQueue[B, L, F, L0, "ncDistrDPH"]
code!@ {alpha,A} = QBDQueue[B, L, F, L0, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = QBDQueue[B, L, F, L0, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = QBDQueue[B, L, F, L0, "stDistrPH"]
code!@ {beta, B} = QBDQueue[B, L, F, L0, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "QBDQueue: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "QBDQueue: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "QBDQueue: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "QBDQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "QBDQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "QBDQueue: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "QBDQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "QBDQueue: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "QBDQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "QBDQueue: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "QBDQueue: stMoms returns wrong sojourn time moments!"

enddocex

inputmsg
defmat@ B # {{6., 1., 0.},{0., 4., 1.},{2., 0., 0.}}
defmat@ F # {{0., 0., 0.},{5., 0., 0.},{1., 3., 0.}} 
defmat@ L # {{-12., 3., 2.},{0., -14., 4.},{3., 1., -10.}} 
code@ L0 = L+B
code$ BuTools`Verbose = False
code$ {pi0, R} = QBDSolve [B, L, F, L0]
code$ lambd = Sum[pi0.Inv[Eye[Dim1[R]]-R].F]
code$ BuTools`Verbose = True
testmsg
code!@ {ncd,ncm} = QBDQueue[B, L, F, L0, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = QBDQueue[B, L, F, L0, "ncDistrDPH"]
code!@ {alpha,A} = QBDQueue[B, L, F, L0, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = QBDQueue[B, L, F, L0, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = QBDQueue[B, L, F, L0, "stDistrPH"]
code!@ {beta, B} = QBDQueue[B, L, F, L0, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "QBDQueue: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "QBDQueue: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "QBDQueue: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "QBDQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "QBDQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "QBDQueue: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "QBDQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "QBDQueue: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "QBDQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "QBDQueue: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "QBDQueue: stMoms returns wrong sojourn time moments!"

inputmsg
defmat@ B # {{6., 1., 0.},{0., 5., 0.},{0., 0., 0.}}
defmat@ F # {{0., 3., 1.},{0., 5., 0.},{0., 0., 0.}} 
defmat@ L # {{-16., 3., 2.},{0., -14., 4.},{3., 1., -4.}} 
defmat@ L0 # {{-14., 10., 0.},{5., -10., 0.},{3., 1., -4.}}
code$ BuTools`Verbose = False
code$ {pi0, R} = QBDSolve [B, L, F, L0]
code$ lambd = Sum[pi0.Inv[Eye[Dim1[R]]-R].F]
code$ BuTools`Verbose = True
testmsg
code!@ {ncd,ncm} = QBDQueue[B, L, F, L0, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = QBDQueue[B, L, F, L0, "ncDistrDPH"]
code!@ {alpha,A} = QBDQueue[B, L, F, L0, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = QBDQueue[B, L, F, L0, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = QBDQueue[B, L, F, L0, "stDistrPH"]
code!@ {beta, B} = QBDQueue[B, L, F, L0, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "QBDQueue: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "QBDQueue: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "QBDQueue: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "QBDQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "QBDQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "QBDQueue: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "QBDQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "QBDQueue: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "QBDQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "QBDQueue: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "QBDQueue: stMoms returns wrong sojourn time moments!"

inputmsg
defmat@ B # {{0., 0.},{3., 4.}}
defmat@ F # {{1., 0.},{2., 0.}} 
defmat@ L # {{-6., 5.},{3., -12.}} 
defmat@ L0 # {{-6., 5.},{6., -8.}}
code$ BuTools`Verbose = False
code$ {pi0, R} = QBDSolve [B, L, F, L0]
code$ lambd = Sum[pi0.Inv[Eye[Dim1[R]]-R].F]
code$ BuTools`Verbose = True
testmsg
code!@ {ncd,ncm} = QBDQueue[B, L, F, L0, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = QBDQueue[B, L, F, L0, "ncDistrDPH"]
code!@ {alpha,A} = QBDQueue[B, L, F, L0, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = QBDQueue[B, L, F, L0, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = QBDQueue[B, L, F, L0, "stDistrPH"]
code!@ {beta, B} = QBDQueue[B, L, F, L0, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "QBDQueue: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "QBDQueue: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "QBDQueue: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "QBDQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "QBDQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "QBDQueue: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "QBDQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "QBDQueue: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "QBDQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "QBDQueue: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "QBDQueue: stMoms returns wrong sojourn time moments!"


test MAPMAP1

inputmsg
defmat@ D0 # {{-8., 1., 2.},{0., -6., 4.},{3., 0., -3.}}
defmat@ D1 # {{4., 1., 0.},{0., 2., 0.},{0., 0., 0.}}
defmat@ S0 # {{-10., 4.},{0., -7.}}
defmat@ S1 # {{5., 1.},{4., 3.}}
code$ lambd = 1./MarginalMomentsFromMAP[D0,D1,1][[1]]
testmsg
code!@ {ncd,ncm} = MAPMAP1[D0,D1,S0,S1, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = MAPMAP1[D0,D1,S0,S1, "ncDistrDPH"]
code!@ {alpha,A} = MAPMAP1[D0,D1,S0,S1, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = MAPMAP1[D0,D1,S0,S1, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = MAPMAP1[D0,D1,S0,S1, "stDistrPH"]
code!@ {beta, B} = MAPMAP1[D0,D1,S0,S1, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "MAPMAP1: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "MAPMAP1: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "MAPMAP1: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "MAPMAP1: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "MAPMAP1: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "MAPMAP1: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "MAPMAP1: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "MAPMAP1: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "MAPMAP1: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "MAPMAP1: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "MAPMAP1: stMoms returns wrong sojourn time moments!"
// cross-check
code$ IA = Eye[Dim1[D0]]
code$ IS = Eye[Dim1[S0]]
code$ BuTools`Verbose = False
code$ {gamma, G} = QBDQueue [Kron[IA,S1], Kron[D0,IS]+Kron[IA,S0], Kron[D1,IS], Kron[D0,IS], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "MAPMAP1: Large and small model does not give the same results!"

inputmsg
defvec@ delta # {0.5, 0.1, 0.4}
defmat@ Dm # {{-8., 1., 2.},{0., -6., 4.},{3., 0., -3.}}
defvec@ sigma # {0.2, 0.7, 0.1}
defmat@ S # {{-10., 4., 0.},{5., -7., 2.},{1., 2., -8.}}
code! D0 = Dm
code! D1 = DyadProd[RowSum[-Dm],delta]
code! S0 = S
code! S1 = DyadProd[RowSum[-S],sigma]
code$ lambd = 1./MarginalMomentsFromMAP[D0,D1,1][[1]]
testmsg
code!@ {ncd,ncm} = MAPMAP1[D0,D1,S0,S1, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = MAPMAP1[D0,D1,S0,S1, "ncDistrDPH"]
code!@ {alpha,A} = MAPMAP1[D0,D1,S0,S1, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = MAPMAP1[D0,D1,S0,S1, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = MAPMAP1[D0,D1,S0,S1, "stDistrPH"]
code!@ {beta, B} = MAPMAP1[D0,D1,S0,S1, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "MAPMAP1: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "MAPMAP1: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "MAPMAP1: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "MAPMAP1: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "MAPMAP1: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "MAPMAP1: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "MAPMAP1: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "MAPMAP1: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "MAPMAP1: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "MAPMAP1: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "MAPMAP1: stMoms returns wrong sojourn time moments!"
// cross-check
code$ IA = Eye[Dim1[D0]]
code$ IS = Eye[Dim1[S0]]
code$ BuTools`Verbose = False
code$ {gamma, G} = QBDQueue [Kron[IA,S1], Kron[D0,IS]+Kron[IA,S0], Kron[D1,IS], Kron[D0,IS], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "MAPMAP1: Large and small model does not give the same results!"

enddocex

inputmsg
defmat@ D0 # {{-8., 2.},{1., -3.}}
defmat@ D1 # {{1., 5.},{0., 2.}}
defmat@ S0 # {{-10., 4.},{0., -7.}}
defmat@ S1 # {{5., 1.},{4., 3.}}
code$ lambd = 1./MarginalMomentsFromMAP[D0,D1,1][[1]]
testmsg
code!@ {ncd,ncm} = MAPMAP1[D0,D1,S0,S1, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = MAPMAP1[D0,D1,S0,S1, "ncDistrDPH"]
code!@ {alpha,A} = MAPMAP1[D0,D1,S0,S1, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = MAPMAP1[D0,D1,S0,S1, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = MAPMAP1[D0,D1,S0,S1, "stDistrPH"]
code!@ {beta, B} = MAPMAP1[D0,D1,S0,S1, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "MAPMAP1: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "MAPMAP1: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "MAPMAP1: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "MAPMAP1: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "MAPMAP1: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "MAPMAP1: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "MAPMAP1: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "MAPMAP1: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "MAPMAP1: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "MAPMAP1: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "MAPMAP1: stMoms returns wrong sojourn time moments!"
// cross-check
code$ IA = Eye[Dim1[D0]]
code$ IS = Eye[Dim1[S0]]
code$ BuTools`Verbose = False
code$ {gamma, G} = QBDQueue [Kron[IA,S1], Kron[D0,IS]+Kron[IA,S0], Kron[D1,IS], Kron[D0,IS], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "MAPMAP1: Large and small model does not give the same results!"

inputmsg
defmat@ S0 # {{-10., 4., 0.},{5., -7., 2.},{1., 2., -8.}}
defmat@ S1 # {{0., 0., 6.},{0., 0., 0.},{0., 3., 2.}}
defmat@ D0 # {{-8., 1., 2.},{0., -6., 4.},{3., 0., -3.}}
defmat@ D1 # {{4., 1., 0.},{0., 0., 2.},{0., 0., 0.}}
code$ lambd = 1./MarginalMomentsFromMAP[D0,D1,1][[1]]
testmsg
code!@ {ncd,ncm} = MAPMAP1[D0,D1,S0,S1, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = MAPMAP1[D0,D1,S0,S1, "ncDistrDPH"]
code!@ {alpha,A} = MAPMAP1[D0,D1,S0,S1, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = MAPMAP1[D0,D1,S0,S1, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = MAPMAP1[D0,D1,S0,S1, "stDistrPH"]
code!@ {beta, B} = MAPMAP1[D0,D1,S0,S1, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "MAPMAP1: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "MAPMAP1: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "MAPMAP1: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "MAPMAP1: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "MAPMAP1: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "MAPMAP1: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "MAPMAP1: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "MAPMAP1: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "MAPMAP1: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "MAPMAP1: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "MAPMAP1: stMoms returns wrong sojourn time moments!"
// cross-check
code$ IA = Eye[Dim1[D0]]
code$ IS = Eye[Dim1[S0]]
code$ BuTools`Verbose = False
code$ {gamma, G} = QBDQueue [Kron[IA,S1], Kron[D0,IS]+Kron[IA,S0], Kron[D1,IS], Kron[D0,IS], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "MAPMAP1: Large and small model does not give the same results!"

inputmsg
defmat@ D0 # {{-8., 1., 2.},{0., -6., 4.},{3., 0., -3.}}
defmat@ D1 # {{4., 1., 0.},{0., 0., 2.},{0., 0., 0.}}
defvec@ sigma # {0.2, 0.7, 0.1}
defmat@ S # {{-10., 4., 0.},{5., -7., 2.},{1., 2., -8.}}
code! S0 = S
code! S1 = DyadProd[RowSum[-S],sigma]
code$ lambd = 1./MarginalMomentsFromMAP[D0,D1,1][[1]]
testmsg
code!@ {ncd,ncm} = MAPMAP1[D0,D1,S0,S1, "ncDistr", 11, "ncMoms", 5]
code!@ {alphap,Ap} = MAPMAP1[D0,D1,S0,S1, "ncDistrDPH"]
code!@ {alpha,A} = MAPMAP1[D0,D1,S0,S1, "ncDistrMG"]
code!@ ncdFromDPH = PmfFromDPH[alphap,Ap,Range[0,10,1]]
code!@ ncmFromMG = MomentsFromMG[alpha,A,5]
code!@ {std, stm} = MAPMAP1[D0,D1,S0,S1, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = MAPMAP1[D0,D1,S0,S1, "stDistrPH"]
code!@ {beta, B} = MAPMAP1[D0,D1,S0,S1, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMGRepresentation[alpha,A] # "MAPMAP1: invalid MG representation of the queue length!"
assert CheckMERepresentation[beta,B] # "MAPMAP1: invalid ME representation of the sojourn time!"
assert CheckDPHRepresentation[alphap,Ap] # "MAPMAP1: invalid DPH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "MAPMAP1: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[ncm[[1]]-stm[[1]]*lambd]<10^-12 # "MAPMAP1: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromDPH[alphap,Ap,5]]-ToArray[ncmFromMG])./ToArray[ncmFromMG]]<10^-12 # "MAPMAP1: the MG and DPH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "MAPMAP1: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[ncd-PmfFromMG[alpha,A,Range[0,10,1]]]<10^-12 # "MAPMAP1: ncdistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "MAPMAP1: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[ncm]-ToArray[ncmFromMG])./ToArray[ncm]]<10^-12 # "MAPMAP1: ncmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "MAPMAP1: stMoms returns wrong sojourn time moments!"
// cross-check
code$ IA = Eye[Dim1[D0]]
code$ IS = Eye[Dim1[S0]]
code$ BuTools`Verbose = False
code$ {gamma, G} = QBDQueue [Kron[IA,S1], Kron[D0,IS]+Kron[IA,S0], Kron[D1,IS], Kron[D0,IS], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "MAPMAP1: Large and small model do not give the same results!"


test MMAPPH1PRPR

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.83333, 0.11404, 0.05263}
defmat@ S3 # {{-3., 0., 0.},{0.73077, -0.73077, 0.},{0., 0.5, -0.5}}
defvec@ sigma2 # {1.}
defmat@ S2 # {{-2.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1PRPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1PRPR: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1PRPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1PRPR: invalid sojourn time distribution!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 3!"

enddocex

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.16667, 0.83333}
defmat@ S3 # {{-0.5, 0.5},{0., -3.}}
defvec@ sigma2 # {0.58824, 0.41176}
defmat@ S2 # {{-2.3529, 2.3529},{0., -4.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1PRPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1PRPR: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1PRPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1PRPR: invalid sojourn time distribution!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1PRPR: Little formula does not hold for class 3!"

test MMAPPH1NPPR

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.83333, 0.11404, 0.05263}
defmat@ S3 # {{-3., 0., 0.},{0.73077, -0.73077, 0.},{0., 0.5, -0.5}}
defvec@ sigma2 # {1.}
defmat@ S2 # {{-2.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1NPPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1NPPR: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1NPPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1NPPR: invalid sojourn time distribution!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 3!"

enddocex

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.16667, 0.83333}
defmat@ S3 # {{-0.5, 0.5},{0., -3.}}
defvec@ sigma2 # {0.58824, 0.41176}
defmat@ S2 # {{-2.3529, 2.3529},{0., -4.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1NPPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1NPPR: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1NPPR[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1NPPR: invalid sojourn time distribution!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1NPPR: Little formula does not hold for class 3!"

test MMAPPH1FCFS

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.83333, 0.11404, 0.05263}
defmat@ S3 # {{-3., 0., 0.},{0.73077, -0.73077, 0.},{0., 0.5, -0.5}}
defvec@ sigma2 # {1.}
defmat@ S2 # {{-2.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1FCFS: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
code! {betap1,Bp1, betap2, Bp2, betap3, Bp3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stDistrPH"]
code! {beta1, B1, beta2, B2, beta3, B3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stDistrME"]
code!@ stdFromPH1 = CdfFromPH[betap1,Bp1,distrPoints]
code!@ stmFromME1 = MomentsFromME[beta1,B1,3]
code!@ stdFromPH2 = CdfFromPH[betap2,Bp2,distrPoints]
code!@ stmFromME2 = MomentsFromME[beta2,B2,3]
code!@ stdFromPH3 = CdfFromPH[betap3,Bp3,distrPoints]
code!@ stmFromME3 = MomentsFromME[beta3,B3,3]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1FCFS: invalid sojourn time distribution!"
assert Norm[(ToArray[MomentsFromPH[betap1,Bp1,3]]-ToArray[stmFromME1])./ToArray[stmFromME1]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 1 are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap2,Bp2,3]]-ToArray[stmFromME2])./ToArray[stmFromME2]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 2 are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap3,Bp3,3]]-ToArray[stmFromME3])./ToArray[stmFromME3]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 3 are not equal!"
// check moment and distribution calculation
assert Norm[std1-CdfFromME[beta1,B1,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 1!"
assert Norm[std2-CdfFromME[beta2,B2,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 2!"
assert Norm[std3-CdfFromME[beta3,B3,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 3!"
assert Norm[(ToArray[stm1]-ToArray[stmFromME1])./ToArray[stm1]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 1!"
assert Norm[(ToArray[stm2]-ToArray[stmFromME2])./ToArray[stm2]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 2!"
assert Norm[(ToArray[stm3]-ToArray[stmFromME3])./ToArray[stm3]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 3!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 3!"

enddocex

inputmsg
defmat@ D0 # {{-5.49, 0., 1.15, 0.},{0., -2.29, 0., 0.},{0., 0.08, -1.32, 0.},{0.72, 1.17, 0.7, -7.07}}
defmat@ D1 # {{0.25, 0.38, 0.64, 0.},{0., 0., 0., 1.09},{0., 1.24, 0., 0.},{0.37, 0., 0., 0.}}
defmat@ D2 # {{0.3, 1.0, 0., 0.48},{0., 0.2, 0., 0.},{0., 0., 0., 0.},{0.61, 0., 0., 0.2}}
defmat@ D3 # {{0., 0.98, 0., 0.31},{0., 0., 1.0, 0.},{0., 0., 0., 0.},{1.1, 0.84, 0.33, 1.03}}
defvec@ sigma3 # {0.16667, 0.83333}
defmat@ S3 # {{-0.5, 0.5},{0., -3.}}
defvec@ sigma2 # {0.58824, 0.41176}
defmat@ S2 # {{-2.3529, 2.3529},{0., -4.}}
defvec@ sigma1 # {0.25, 0.75}
defmat@ S1 # {{-2.5, 2.5},{0., -10.}}
testmsg
code! {ncm1, ncd1, ncm2, ncd2, ncm3, ncd3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "ncMoms", 3, "ncDistr", 500]
code$ momFromDistr1 = ncd1.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr2 = ncd2.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
code$ momFromDistr3 = ncd3.Transpose[VCat[Range[0,499,1], Range[0,499,1].^2, Range[0,499,1].^3]]
assert Norm[(momFromDistr1-ncm1)./ncm1]<0.001 && Norm[(momFromDistr2-ncm2)./ncm2]<0.001 && Norm[(momFromDistr3-ncm3)./ncm3]<0.001 # "MMAPPH1FCFS: queue length moments and queue length distribution are not consistent!"
deflist distrPoints # {1.,5.,10.}
code!@ {stm1, std1, stm2, std2, stm3, std3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stMoms", 3, "stDistr", distrPoints]
code! {betap1,Bp1, betap2, Bp2, betap3, Bp3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stDistrPH"]
code! {beta1, B1, beta2, B2, beta3, B3} = MMAPPH1FCFS[<-D0,D1,D2,D3->, <-sigma1,sigma2,sigma3->,<-S1,S2,S3->, "stDistrME"]
code!@ stdFromPH1 = CdfFromPH[betap1,Bp1,distrPoints]
code!@ stmFromME1 = MomentsFromME[beta1,B1,3]
code!@ stdFromPH2 = CdfFromPH[betap2,Bp2,distrPoints]
code!@ stmFromME2 = MomentsFromME[beta2,B2,3]
code!@ stdFromPH3 = CdfFromPH[betap3,Bp3,distrPoints]
code!@ stmFromME3 = MomentsFromME[beta3,B3,3]
assert Min[std1]>=0 && Max[std1]<=1 && AllNonNegative[Diff[std1]] && Min[std2]>=0 && Max[std2]<=1 && AllNonNegative[Diff[std2]] && Min[std3]>=0 && Max[std3]<=1 && AllNonNegative[Diff[std3]]# "MMAPPH1FCFS: invalid sojourn time distribution!"
assert Norm[(ToArray[MomentsFromPH[betap1,Bp1,3]]-ToArray[stmFromME1])./ToArray[stmFromME1]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 1 are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap2,Bp2,3]]-ToArray[stmFromME2])./ToArray[stmFromME2]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 2 are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap3,Bp3,3]]-ToArray[stmFromME3])./ToArray[stmFromME3]]<10^-10 # "MMAPPH1FCFS: the ME and PH representations for class 3 are not equal!"
// check moment and distribution calculation
assert Norm[std1-CdfFromME[beta1,B1,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 1!"
assert Norm[std2-CdfFromME[beta2,B2,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 2!"
assert Norm[std3-CdfFromME[beta3,B3,distrPoints]]<10^-12 # "MMAPPH1FCFS: stDistr returns wrong sojourn time distribution for class 3!"
assert Norm[(ToArray[stm1]-ToArray[stmFromME1])./ToArray[stm1]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 1!"
assert Norm[(ToArray[stm2]-ToArray[stmFromME2])./ToArray[stm2]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 2!"
assert Norm[(ToArray[stm3]-ToArray[stmFromME3])./ToArray[stm3]]<10^-10 # "MMAPPH1FCFS: stMoms returns wrong sojourn time moments for class 3!"
// check Little formula for every traffic class
code$ lambda1 = 1./MarginalMomentsFromMAP[D0+D2+D3,D1,1][[1]]
code$ lambda2 = 1./MarginalMomentsFromMAP[D0+D1+D3,D2,1][[1]]
code$ lambda3 = 1./MarginalMomentsFromMAP[D0+D1+D2,D3,1][[1]]
assert Abs[ncm1[[1]]-stm1[[1]]*lambda1]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 1!"
assert Abs[ncm2[[1]]-stm2[[1]]*lambda2]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 2!"
assert Abs[ncm3[[1]]-stm3[[1]]*lambda3]<10^-12 # "MMAPPH1FCFS: Little formula does not hold for class 3!"



test FluidQueue

inputmsg
defmat@ Q # {{-9., 2., 4., 0., 1., 2.},{6., -25., 5., 3., 7., 4.},{1., 3., -4., 0., 0., 0.},{0., 0., 0., -8., 3., 5.},{7., 3., 0., 2., -13., 1.},{7., 8., 0., 3., 8., -26.}}
defvec@ vRin # {4., 2., 1., 0., 0., 3.}
defvec@ vRout # {6., 2., 0., 0., 3., 2.}
code! Rin = Diag[vRin]
code! Rout = Diag[vRout]
code$ lambd = Sum[CTMCSolve[Q].Rin]
testmsg
code!@ {fld,flm} = FluidQueue[Q, Rin, Rout, "flDistr", Range[0.,1.,0.1], "flMoms", 5]
code!@ {alphap,Ap} = FluidQueue[Q, Rin, Rout, "flDistrPH"]
code!@ {alpha,A} = FluidQueue[Q, Rin, Rout, "flDistrME"]
code!@ fldFromPH = CdfFromPH[alphap,Ap,Range[0.,1.,0.1]]
code!@ flmFromME = MomentsFromME[alpha,A,5]
code!@ {std, stm} = FluidQueue[Q, Rin, Rout, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = FluidQueue[Q, Rin, Rout, "stDistrPH"]
code!@ {beta, B} = FluidQueue[Q, Rin, Rout, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMERepresentation[alpha,A] # "FluidQueue: invalid ME representation of the queue length!"
assert CheckMERepresentation[beta,B] # "FluidQueue: invalid ME representation of the sojourn time!"
assert CheckPHRepresentation[alphap,Ap] # "FluidQueue: invalid PH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "FluidQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[flm[[1]]-stm[[1]]*lambd]<10^-12 # "FluidQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromPH[alphap,Ap,5]]-ToArray[flmFromME])./ToArray[flmFromME]]<10^-12 # "FluidQueue: the ME and PH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "FluidQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[fld-CdfFromME[alpha,A,Range[0.,1.,0.1]]]<10^-12 # "FluidQueue: flDistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "FluidQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[flm]-ToArray[flmFromME])./ToArray[flm]]<10^-12 # "FluidQueue: flmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "FluidQueue: stMoms returns wrong sojourn time moments!"

test FluFluQueue

inputmsg
defmat@ Qin # {{-2., 1., 1.},{2., -5., 3.},{4., 0., -4.}}
defvec@ vRin # {3., 7., 0.}
code! Rin = Diag[vRin]
defmat@ Qout # {{-4., 1., 3.},{6., -8., 2.},{3., 7., -10.}}
defvec@ vRout # {1., 7., 15.}
code! Rout = Diag[vRout]
code$ lambd = Sum[CTMCSolve[Qin].Rin]
testmsg
code!@ {fld,flm} = FluFluQueue[Qin, Rin, Qout, Rout, False, "flDistr", Range[0.,1.,0.1], "flMoms", 5]
code!@ {alphap,Ap} = FluFluQueue[Qin, Rin, Qout, Rout, False, "flDistrPH"]
code!@ {alpha,A} = FluFluQueue[Qin, Rin, Qout, Rout, False, "flDistrME"]
code!@ fldFromPH = CdfFromPH[alphap,Ap,Range[0.,1.,0.1]]
code!@ flmFromME = MomentsFromME[alpha,A,5]
code!@ {std, stm} = FluFluQueue[Qin, Rin, Qout, Rout, False, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = FluFluQueue[Qin, Rin, Qout, Rout, False, "stDistrPH"]
code!@ {beta, B} = FluFluQueue[Qin, Rin, Qout, Rout, False, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMERepresentation[alpha,A] # "FluFluQueue: invalid ME representation of the queue length!"
assert CheckMERepresentation[beta,B] # "FluFluQueue: invalid ME representation of the sojourn time!"
assert CheckPHRepresentation[alphap,Ap] # "FluFluQueue: invalid PH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "FluFluQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[flm[[1]]-stm[[1]]*lambd]<10^-12 # "FluFluQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromPH[alphap,Ap,5]]-ToArray[flmFromME])./ToArray[flmFromME]]<10^-12 # "FluFluQueue: the ME and PH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "FluFluQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[fld-CdfFromME[alpha,A,Range[0.,1.,0.1]]]<10^-12 # "FluFluQueue: flDistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "FluFluQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[flm]-ToArray[flmFromME])./ToArray[flm]]<10^-12 # "FluFluQueue: flmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "FluFluQueue: stMoms returns wrong sojourn time moments!"
// cross-check
code$ Iin = Eye[Dim1[Qin]]
code$ Iout = Eye[Dim1[Qout]]
code$ BuTools`Verbose = False
code$ {gamma, G} = FluidQueue [Kron[Qin,Iout]+Kron[Iin,Qout], Kron[Rin,Iout], Kron[Iin,Rout], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "FluFluQueue: Large and small model do not give the same results!"

testmsg
code!@ {fld,flm} = FluFluQueue[Qin, Rin, Qout, Rout, True, "flDistr", Range[0.,1.,0.1], "flMoms", 5]
code!@ {alphap,Ap} = FluFluQueue[Qin, Rin, Qout, Rout, True, "flDistrPH"]
code!@ {alpha,A} = FluFluQueue[Qin, Rin, Qout, Rout, True, "flDistrME"]
code!@ fldFromPH = CdfFromPH[alphap,Ap,Range[0.,1.,0.1]]
code!@ flmFromME = MomentsFromME[alpha,A,5]
code!@ {std, stm} = FluFluQueue[Qin, Rin, Qout, Rout, True, "stDistr", Range[0.,1.,0.1], "stMoms", 5]
code!@ {betap,Bp} = FluFluQueue[Qin, Rin, Qout, Rout, True, "stDistrPH"]
code!@ {beta, B} = FluFluQueue[Qin, Rin, Qout, Rout, True, "stDistrME"]
code!@ stdFromPH = CdfFromPH[betap,Bp,Range[0.,1.,0.1]]
code!@ stmFromME = MomentsFromME[beta,B,5]
assert CheckMERepresentation[alpha,A] # "FluFluQueue: invalid ME representation of the queue length!"
assert CheckMERepresentation[beta,B] # "FluFluQueue: invalid ME representation of the sojourn time!"
assert CheckPHRepresentation[alphap,Ap] # "FluFluQueue: invalid PH representation of the queue length!"
assert CheckPHRepresentation[betap,Bp] # "FluFluQueue: invalid PH representation of the sojourn time!"
// check Little formula
assert Abs[flm[[1]]-stm[[1]]*lambd]<10^-12 # "FluFluQueue: Little formula does not hold!"
// check PH representations
assert Norm[(ToArray[MomentsFromPH[alphap,Ap,5]]-ToArray[flmFromME])./ToArray[flmFromME]]<10^-12 # "FluFluQueue: the ME and PH representations are not equal!"
assert Norm[(ToArray[MomentsFromPH[betap,Bp,5]]-ToArray[stmFromME])./ToArray[stmFromME]]<10^-12 # "FluFluQueue: the ME and PH representations are not equal!"
// check moment and distribution calculation
assert Norm[fld-CdfFromME[alpha,A,Range[0.,1.,0.1]]]<10^-12 # "FluFluQueue: flDistr returns wrong queue length distribution!"
assert Norm[std-CdfFromME[beta,B,Range[0.,1.,0.1]]]<10^-12 # "FluFluQueue: stDistr returns wrong sojourn time distribution!"
assert Norm[(ToArray[flm]-ToArray[flmFromME])./ToArray[flm]]<10^-12 # "FluFluQueue: flmoms returns wrong queue length moments!"
assert Norm[(ToArray[stm]-ToArray[stmFromME])./ToArray[stm]]<10^-12 # "FluFluQueue: stMoms returns wrong sojourn time moments!"
// cross-check
code$ Iin = Eye[Dim1[Qin]]
code$ Iout = Eye[Dim1[Qout]]
code$ BuTools`Verbose = False
code$ {gamma, G} = FluidQueue [Kron[Qin,Iout]+Kron[Iin,Qout], Kron[Rin,Iout], Kron[Iin,Rout], "Q0", Kron[Qin,Iout]+Kron[Rin,Pinv[Rout].Qout], "stDistrME"]
code$ BuTools`Verbose = True
code$ msmall = MomentsFromME[beta,B,5]
code$ mlarge = MomentsFromME[gamma,G,5]
assert Norm[(ToArray[msmall]-ToArray[mlarge])./ToArray[msmall]]<10^-12 # "FluFluQueue: Large and small model do not give the same results!"


