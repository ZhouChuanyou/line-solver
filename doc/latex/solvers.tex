\chapter{Network solvers}
\label{Network-solvers}
\section{Overview}
Solvers analyze objects of class \texttt{Network} to return average, transient, distributions, or state probability metrics. A solver can implement one or more {\em methods}, which although sharing a similar overall solution strategy, they can differ significantly from each other in the way this is actually implemented and on wether the final solution is exact or approximate.

The \texttt{method} field in the options structure array passed to a solver can be used to select the desired method, e.g., \texttt{options.method='default'} requires the solver to use default options, while \texttt{options.method='exact'} requires to solve the model exactly, if an exact solution method is available.

In what follows, we describe the general characteristics and supported model features for each solver available in \textsc{LINE} and their methods.
%By definition, a solver cannot modify the \texttt{Network} object.
\subsubsection{Available solvers}
\noindent The following \texttt{Network} solvers are available within \textsc{Line} 2.0.0-ALPHA:
%\section{Solvers}
%\label{SEC_solvers}
%\begin{table}[t!]
%\renewcommand{\arraystretch}{1.2}
%\centering
%\begin{tabular}{|l|c|c|c|c|c|c|}
%\cline{2-6}
%\multicolumn{1}{c|}{}&\multicolumn{5}{c|}{\textbf{Solver}}\\
%\cline{1-6}
%\textbf{Feature}&\texttt{MVA}	&\texttt{CTMC}&\texttt{FLUID}	 	&\texttt{JMT} 	&\texttt{SSA}\\
%\hline
%%CQN &  $\checkmark$  & $\checkmark$  & $\checkmark$  & $\checkmark$& $\checkmark$ \\
%Cox & $\checkmark$  & $\checkmark$  & $\checkmark$  & $\checkmark$& $\checkmark$ \\
%CS & $\checkmark$  & $\checkmark$ & $\checkmark$ &$\checkmark$ & $\checkmark$\\
%RE &  &  & API-only & & \\
%%TD &  &  &  & & $\checkmark$\\
%\hline
%\end{tabular}
%\caption{Advanced model features supported by the \textsc{Line} solvers}
%\label{TAB_solver_features}
%\end{table}
%Table~\ref{TAB_solver_features} summarizes the solvers included in \textsc{Line} and the model features they support. As indicated in Table~\ref{TAB_solver_features}, the RE feature is currently supported only via the LINE API. Conversely, the AVG indexes are available both in the \textsc{Line} modeling language and in the API. A detailed description of the solvers is as follows:
\begin{itemize}
\item \texttt{AUTO}: This solver uses an algorithm to select the best solution method for the model under consideration, among those offered by the other solvers. Analytical solvers are always preferred to simulation-based solvers. This solver is implemented by the \texttt{SolverAuto} class.
\item \texttt{CTMC}: This is a solver that returns the exact values of the performance metrics by explicit generation of the continuous-time Markov chain (CTMC) underpinning the model. As the CTMC typically incurs state-space explosion, this solver can successfully analyze only small models. The {CTMC} solver is the only method offered within \textsc{Line} that can return an exact solution on all Markovian models, all other solvers are either approximate or are simulators. This solver is implemented by the \texttt{SolverCTMC} class.
\item \texttt{FLUID}: This solver analyzes the model by means of an approximate fluid model, leveraging a representation of the queueing network as a system of ordinary differential equations (ODEs). The fluid model is approximate, but if the servers are all PS or INF, it can be shown to become exact in the limit where the number of users and the number of servers in each node grow to infinity~\cite{pere.casa13}. This solver is implemented by the \texttt{SolverFluid} class.
\item \texttt{JMT}: This is a solver that uses a model-to-model transformation to export the \textsc{Line} representation into a JMT simulation model~\cite{BerCS07}. This solver can analyze also non-Markovian models, in particular those involving deterministic or Pareto distributions, or empirical traces. This solver is implemented by the \texttt{SolverJMT} class.
\item \texttt{MAM}: This is a matrix-analytic method solver, which relies on quasi-birth death (QBD) processes to analyze open queueing systems. This solver is implemented by the \texttt{SolverMAM} class.
\item \texttt{MVA}: This is a solver based on approximate and exact mean-value analysis. This solver is typically the fastest and offers very good accuracy in a number of situations, in particular models where stations have a single-server. This solver is implemented by the \texttt{SolverMVA} class. %The {MVA} solver in \textsc{Line} allow for queue-dependent (QD) stations, where the rate of processing depends on the queue-length, such as nodes with multiple servers. However, {MVA} cannot produce response time distributions, due to an intrinsic limitation of the solution paradigm. A detailed description of the {MVA} algorithm used in \textsc{Line} 2.0.0-ALPHA is provided in \cite{casale2015qdamva}.
\item \texttt{NC}: This solver uses a combination of methods based on the normalizing constant of state probability to solve a model. The underpinning algorithm are particularly useful to compute marginal and joint state probabilities in queueing network models. This solver is implemented by the \texttt{SolverNC} class.
\item \texttt{SSA}: This is a discrete-event simulator based on the CTMC representation of the model. The solver is implemented in MATLAB language and thus tends to offer lower speed than JMT, but the model execution can be easily parallelized using MATLAB's {\em spmd} construct. This solver is implemented by the \texttt{SolverSSA} class.
\end{itemize}

%\subsubsection{{Layered network} solvers}
%\noindent In addition, the following \texttt{LayeredNetwork} solvers are available:
%\begin{itemize}
%\item \texttt{LQNS}: This is a wrapper of the LQNS solver. It assumes that both \texttt{lqns} and \texttt{lqsim} are available on the operating system path so that they can be found by MATLAB's \texttt{system} API.
%\item \texttt{LN}: This is \textsc{Line}'s own layered network solver. Compared to the published version, the current release is based on a SRVN-style decomposition, whereby each server is modelled using a separate submodel.
%\end{itemize}

\section{Solution algorithms}
\subsection{\texttt{AUTO}}
The \texttt{SolverAuto} class provides interfaces to the core solution functions (e.g., \texttt{getAvg}, ...) that dynamically bind to one of the other solvers implemented in \textsc{Line} (\texttt{CTMC}, \texttt{NC}, ...). It is often not possible to identify the best solver without some performance results on the model, for example to determine if it operates in light, moderate, or heavy-load regime.

Therefore, heuristics are used to identify a solver based on structural properties of the model, such as based on the scheduling strategies used at the stations as well as the number of jobs, chains, and classes. Such heuristics, though, are independent of the core function called, thus it is possible that the optimal solver does not  support the specific function called (e.g., \texttt{getTranAvg}). In such cases \texttt{SolverAuto} determines what other solvers would be feasible and prioritizes them in execution time order, with the fastest one on average having the higher priority. Eventually, the solver will be always able to identify a solution strategy, through at least simulation-based solvers such as \texttt{JMT} or \texttt{SSA}.

\subsection{\texttt{CTMC}}
The \texttt{SolverCTMC} class solves the model by first generating the infinitesimal generator of the \texttt{Network} and then calling an appropriate solver. Steady-state analysis is carried out by solving the global balance equations defined by the infinitesimal generator. If the \texttt{keep} option is set to true, the solver will save the infinitesimal generator in a temporary file and its location will be shown to the user.

Transient analysis is carried out by numerically solving Kolmogorov's forward equations using MATLAB's ODE solvers. The range of integration is controlled by the \texttt{timespan} option. The ODE solver choice is the same as for \texttt{SolverFluid}.

The CTMC solver heuristically limits the solution to models with no more than 6000 states. The \texttt{force} option needs to be set to true to bypass this control. In models with infinite states, such as networks with open classes, the \texttt{cutoff} option should be used to reduce the CTMC to a finite process. If specified as a scalar value, \texttt{cutoff} is the maximum number of jobs that a class can place at an arbitrary station. More generally, a matrix assignment of \texttt{cutoff} indicates to \texttt{LINE} that \texttt{cutoff}$(i,r)$ is the maximum number of jobs of class $r$ that can be placed at station $i$.

%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverCTMC methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_CTMC_methods}
%\end{table}
%}

\subsection{\texttt{FLUID}}
This solver is based on the system of fluid ordinary differential equations for INF-PS queueing networks presented in \cite{PerC17}.

The fluid ODEs are normally solved with the \texttt{'NonNegative'} ODE solver option enabled. Four types of ODE solvers are used: \emph{fast} or \emph{accurate}, the former only if \texttt{options.iter\_tol}$> 10^{-3}$, and \emph{stiff} or \emph{non-stiff}, depending on the value of \texttt{options.stiff}. The default choice of solver is stored in the following static functions:
\begin{itemize}
\item \texttt{Solver.accurateStiffOdeSolver}, set to MATLAB's \texttt{ode15s}.
\item \texttt{Solver.accurateOdeSolver}, set to \texttt{ode45}.
\item \texttt{Solver.fastStiffOdeSolver}, set to \texttt{ode23s}.
\item \texttt{Solver.fastOdeSolver}, set to \texttt{ode23}.
\end{itemize}

ODE variables corresponding to an infinite number of jobs, as in the job pool of a source station, or to jobs in a disabled class are not included in the solution vector. These rules apply also to the \texttt{options.init\_sol} vector.

The solution of models with FCFS stations maps these stations into corresponding PS stations where the service rates across classes are set identical to each other with a service distribution given by a mixture of the service processes of the service classes. The mixture weights are determined iteratively by solving a sequence of PS models until convergence. Upon initializing FCFS queues, jobs in the buffer are all initialized in the first phase of the service.

%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverFluid methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_Fluid_methods}
%\end{table}
%}

\subsection{\texttt{JMT}}
The class is a wrapper for the \texttt{JMT} simulation and consists of a model-to-model transformation from the \texttt{Network} data structure into the JMT's input XML format (\texttt{.jsimg}) and a corresponding parser for JMT's results. In the transformation, artificial nodes will be automatically added to the routing table to represent class-switching nodes used in the simulator to specify the switching rules. One such class-switching node is defined for every ordered pair of stations $(i,j)$ such that jobs change class in transit from $i$ to $j$.

Upon invocation, the \texttt{JMT} JAR archive will be searched in the MATLAB path and if unavailable automatically downloaded.
%\texttt{JMT} allows to specify the initial number of jobs in a queue, but their ordering within the buffer and the selection of the ones running is internally randomized.

%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverJMT methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_JMT_methods}
%\end{table}
%}
\subsection{\texttt{MAM}}
This is a basic solver for some Markovian open queueing systems that can be analyzed using matrix analytic methods. The solver at the moment is a basic wrapper for the {BU tools} library for matrix-analytic methods~\cite{Hor17}. At present, it is not possible to solve a queueing network model using \texttt{SolverMAM}.

%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverMAM methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_MAM_methods}
%\end{table}
%}

\subsection{\texttt{MVA}}
The solver is primarily based on the Bard-Schweitzer approximate mean value analysis (AMVA) algorithm (\texttt{options.method='default'}), but also offers and implementation of the exact MVA algorithm (\texttt{options.method='exact'}). Non-exponential service times in FCFS nodes are treated using a M/G/1-type approximation. Multi-server FCFS is dealt with using a slight modification of the Rolia-Sevcik method~\cite{roli.sevc95}. DPS queues are analyzed with a time-scale separation method, so that for an incoming job of class $r$ and weight $w_r$, classes with weight $w_s\geq 5w_r$ are replaced by high-priority classes that are analyzed using the standard MVA priority approximation. Conversely the remaining classes are treated by weighting the queue-length seen upon arrival in class $s\neq r$ by the correction factor $w_s/w_r$.
%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverMVA methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_MVA_methods}
%\end{table}
%}

\subsection{\texttt{NC}}
The \texttt{SolverNC} class implements a family of solution algorithms based on the normalizing constant of state probability of product-form queueing networks. Contrary to the other solvers, this method typicallly maps the problem to certain multidimensional integrals, allowing the use of numerical methods such as MonteCarlo sampling and asymptotic expansions in their approximation.
%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverNC methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_NC_methods}
%\end{table}
%}

\subsection{\texttt{SSA}}
The \texttt{SolverSSA} class is a basic stochastic simulator for continuous-time Markov chains. It reuses some of the methods that underpin \texttt{SolverCTMC} to generate the network state space and subsequently simulates the state dynamics by probabilistically choosing one among the possible events that can incur in the system, according to the state spaces of each of node in the network. For efficiency reasons, states are tracked at the level of individual stations, and hashed. The state space is not generated upfront, but rather stored during the simulation, starting from the initial state. If the initialization of a station generates multiple possible initial states, \texttt{SSA} initializes the model using the first state found. The list of initial states for each station can be obtained using the \texttt{getInitState} functions of the \texttt{Network} class.

The \texttt{SSA} solver offers four methods: \texttt{'serial'} (default), \texttt{'serial-hashed'}, \texttt{'parallel'}, and \texttt{'parallel-hashed'}. The serial methods run on a single core, while the parallel methods run on multicore via MATLAB's \texttt{spmd} command. The \texttt{'hashed'} option requires the solver to maintain in memory a hashed list of the node states, as opposed to the joint state vector for the system. As a result, the memory occupancy is lower, but the simulation tends to become slower on models with nodes that have large state spaces, due to the extra cost for hashing. 

%\begin{table}[h!]
%\caption{\texttt{SSA} solver methods.}
%\begin{tabular}{|l|p|}
%\hline
%Method &  {Description} \\
%\hline
%default & \\
%serial & \\
%serial-hashed & State hashing in serial simulation, slower on large models but more memory efficient.\\
%parallel & \\
%parallel-hashed & State hashing in serial simulation, slower on large models but more memory efficient.\\
%\hline
%\end{tabular}
%\end{table}

%{
%\begin{table}[thbp]
%\footnotesize
%\renewcommand{\arraystretch}{1.2}
%\centering
%\caption{SolverSSA methods}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Method} & \textbf{Description}\\
%\hline
%\texttt{std} &  \\
%\texttt{exact} &  \\
%\hline
%\end{tabular}
%\label{TAB_SSA_methods}
%\end{table}
%}

\section{Supported language features and options}
\subsection{Solver features}
Once a model is specified, it is possible to use the \texttt{getUsedLangFeatures} function to obtain a list of the features of a model. For example, the following conditional statement checks if the model contains a FCFS node
\begin{lstlisting}
if (model.getUsedLangFeatures.list.SchedStrategy_FCFS)
...
\end{lstlisting}
Every \textsc{LINE} solver implements the \texttt{support} to check if it supports all language features used in a certain model
\begin{lstlisting}
>> SolverJMT.supports(model)
ans =
  logical
   1
\end{lstlisting}
It is possible to programmatically check which solvers are available for a given model as follows
\begin{lstlisting}
>> Solver.getAllFeasibleSolvers(model)
ans =
  1x6 cell array
    {1x1 SolverCTMC}    {1x1 SolverJMT}    {1x1 SolverSSA}    {1x1 SolverFluid}    {1x1 SolverMVA}    {1x1 SolverNC}
\end{lstlisting}
In the example, \texttt{SolverMAM} is not feasible for the considered model and therefore not returned.  Note that \texttt{SolverAuto} is never included in the list returned by this methods since this is a wrapper for other solvers.

\subsection{Class functions}
The table below lists the steady-state and transient analysis functions implemented by the \texttt{Network} solvers. Since the features of the \texttt{AUTO} solver are the union of the features of the other solvers, in what follows it will be omitted from the description.
{\scriptsize
\begin{table}[thbp]
\renewcommand{\arraystretch}{1.2}
\centering
\caption{Solver support for scheduling strategies}
\begin{tabular}{|l|c|c|c|c|c|c|c|c|}
\cline{3-9}
\multicolumn{1}{l}{}& &\multicolumn{7}{c|}{\textbf{Network Solver}}\\
\cline{1-9}
\textbf{Function}& \textbf{Regime}&\texttt{CTMC}&\texttt{FLUID} 	&\texttt{JMT} 	&\texttt{MAM}	&\texttt{MVA}	&\texttt{NC} &\texttt{SSA}	\\
\hline
\texttt{getAvg}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgTable} & Steady-state 	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgChain} & Steady-state 	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgChainTable} & Steady-state  &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\	
\texttt{getAvgSys} & Steady-state  &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgSysTable} & Steady-state  &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\	
\hline
\texttt{getAvgArvR}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgArvRChain}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgQLen}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgQLenChain} & Steady-state 	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgRespT}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgRespTChain}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgTput}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgTputChain}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgUtil}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\texttt{getAvgUtilChain}	& Steady-state &$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		& $\checkmark$	\\
\hline
\texttt{getCdfRespT} & Steady-state  	 &	& $\checkmark$	& &	&  & &\\
\texttt{getProbState} & Steady-state  	 &	$\checkmark$ & &	&	 &	& $\checkmark$ & \\	
%\texttt{getProbStateChain} & Steady-state   &	& 	&	 &	&  && \\
\texttt{getProbStateSys} & Steady-state   & $\checkmark$	& 	&	 $\checkmark$&	&  & $\checkmark$ & \\
%\texttt{getProbStateSysChain} & Steady-state  	 &	& 	&	 &	&  && \\	
\hline
\texttt{getTranAvg} & Transient  	 &&$\checkmark$	& $\checkmark$	& &	&  & \\
\texttt{getTranCdfPassT} & Transient 	 &	& 	$\checkmark$&	 &	&  && \\
\texttt{getTranCdfRespT} & Transient 	 &	& 	&	$\checkmark$ &	&  && \\
\texttt{getTranState} & Transient	 & &	& $\checkmark$	& &	 && \\
\texttt{getTranStateSys} & Transient	 & &	& $\checkmark$	& &	 && \\
\hline
\end{tabular}
\label{TAB_solver_functions}
\end{table}
}

The functions listed above with the \texttt{Table} suffix (e.g., \texttt{getAvgTable}) provide results in tabular format corresponding to the corresponding core function (e.g., \texttt{getAvg}). The features of the core functions are as follows:
\begin{itemize}
\item \texttt{getAvg}: returns the mean queue-length, utilization, mean response time (for one visit), and throughput for each station and class.
\item \texttt{getAvgChain}: returns the mean queue-length, utilization, mean response time (for one visit), and throughput for every station and chain.
\item \texttt{getAvgSys}: returns the system response time and system throughput, as seen as the reference node, by chain.
\item \texttt{getCdfRespT}: returns the distribution of response times (for one visit) for the stations at steady-state.
\item \texttt{getProbState}: returns joint and marginal state probabilities for jobs of different classes for each station at steady-state.
%\item \texttt{getProbStateChain}: returns joint and marginal state probabilities for jobs organized by chains and for each station at steady-state.
\item \texttt{getProbStateSys}: returns joint probabilities for the system state for each class at steady-state.
%\item \texttt{getProbStateSysChain}: returns joint probabilities for the system state for each chain at steady-state.
\item \texttt{getTranAvg}: returns transient mean queue length, utilization and throughput for every station and chain from a given initial state.
\item \texttt{getTranCdfPassT}: returns the distribution of first passage times in transient regime.
\item \texttt{getTranCdfRespT}: returns the distribution of response times in transient regime.
\item \texttt{getTranState}: returns the transient marginal state for every stations and class from a given initial state.
\item \texttt{getTranStateSys}: returns the transient marginal system state from a given initial state.
\end{itemize}


\subsection{Scheduling strategies}
The table below shows the supported scheduling strategies within \textsc{Line} queueing stations. Each strategy belongs to a policy class: preemptive resume (\texttt{SchedPolicy.PR})%, preemptive non-resume(\texttt{SchedPolicy.PNR})
, non-preemptive (\texttt{SchedPolicy.NP}), non-preemptive priority (\texttt{SchedPolicy.NPPrio}).
\begin{table}[thbp]
\renewcommand{\arraystretch}{1.2}
\centering
\caption{Solver support for scheduling strategies}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\cline{3-9}
\multicolumn{2}{c|}{}&\multicolumn{7}{c|}{\textbf{Network Solver}}\\
\cline{1-9}
\textbf{Strategy}	&\textbf{Policy Class}	&\texttt{CTMC}&\texttt{FLUID} 	&\texttt{JMT} 	&\texttt{MAM}	&\texttt{MVA}	&\texttt{NC}	&\texttt{SSA}	\\
\hline
FCFS &NP	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 & $\checkmark$	&  $\checkmark$		&  $\checkmark$	 \\
\hline
INF	&NP	&$\checkmark$			&$\checkmark$	&  $\checkmark$		& 	 & $\checkmark$ 	&  $\checkmark$		&  $\checkmark$	 \\
%\hline
%Coxian 	&$\checkmark$			&$\checkmark$	& $\checkmark$		&  $\checkmark$	 	&  $\checkmark$	  \\
\hline
RAND 	&NP	&	$\checkmark$	&	& $\checkmark$	&	&$\checkmark$	& $\checkmark$	& $\checkmark$	\\
\hline
SEPT 	&NP	&		$\checkmark$&	&$\checkmark$&	& &&$\checkmark$	\\
%\hline
%LEPT 	&NP	&			&$\checkmark$& 	&$\checkmark$	&&$\checkmark$&	\\
\hline
SJF 	&NP	&			&	& $\checkmark$	&&&&	\\
%\hline
%LJF 	&NP	&			&	& 	& $\checkmark$	&& &\\
\hline
HOL & NPPrio &		 $\checkmark$	& 	&$\checkmark$	&&&& $\checkmark$	\\
\hline
PS	&  PR	&$\checkmark$			&$\checkmark$	&  $\checkmark$		&&  $\checkmark$	  	& $\checkmark$	& $\checkmark$	  \\
\hline
DPS	& PR	&	$\checkmark$		&$\checkmark$	&  	$\checkmark$	&&  	 $\checkmark$ 	& 	&$\checkmark$  \\
\hline
GPS	& PR	&$\checkmark$	&  		&  	$\checkmark$  	& & 	& & $\checkmark$ \\
\hline
\end{tabular}
\label{TAB_solver_policies}
\end{table}

\subsection{Statistical distributions}
The table below summarizes the current level of support for arrival and service distributions within each solver. \texttt{Replayer} represents an empirical trace read from a file, which will be either replayed as-is by the JMT solver, or fitted automatically to a \texttt{Cox} by the other solvers. Note that JMT requires that the last row of the trace must be a number, {\em not} an empty row.

\begin{table}[h!]
\renewcommand{\arraystretch}{1.2}
\centering
\caption{Solver support for statistical distributions}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\cline{2-8}
\multicolumn{1}{c|}{}&\multicolumn{7}{c|}{\textbf{Network Solver}}\\
\cline{1-8}
\textbf{Distribution}	&\texttt{CTMC}&\texttt{FLUID} 	&\texttt{JMT} 	&\texttt{MAM}	&\texttt{MVA}	&\texttt{NC}	&\texttt{SSA}	\\
\hline
Cox2	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 	& $\checkmark$ &$\checkmark$	&$\checkmark$	   \\
\hline
Exp	&$\checkmark$			&$\checkmark$	&  $\checkmark$	 	&  $\checkmark$	 	& $\checkmark$ & $\checkmark$	&$\checkmark$	   \\
\hline
Erlang	&$\checkmark$			&$\checkmark$	&  $\checkmark$		&  $\checkmark$	   	& $\checkmark$ &$\checkmark$	&$\checkmark$	  \\
\hline
HyperExp	&$\checkmark$			&$\checkmark$	&  $\checkmark$		&  $\checkmark$	  	& $\checkmark$ &$\checkmark$&$\checkmark$		  \\
%\hline
%Coxian 	&$\checkmark$			&$\checkmark$	& $\checkmark$		&  $\checkmark$	 	&  $\checkmark$	  \\
\hline
Disabled 	&$\checkmark$		&	$\checkmark$&$\checkmark$ 	& $\checkmark$	&	$\checkmark$ & $\checkmark$ &$\checkmark$	\\
\hline
Det 				&	&	& $\checkmark$	&&&&	\\
\hline
Gamma 				&	&	& $\checkmark$	&&&&	\\
\hline
Pareto 			&	& 	& $\checkmark$&	&&&	\\
\hline
Replayer 				& 	& 	&	$\checkmark$ &  &  & 	&	\\
\hline
Uniform 	&	& 	& $\checkmark$&	&&	&\\
\hline
\end{tabular}
\label{TAB_stat_distributions}
\end{table}


\subsection{Solver options}
%Table~\ref{TAB_solver_options} summarizes the main options available within the \textsc{Line} solvers and their default values.
Solver options are encoded in \textsc{Line} in a structure array that is internally passed to the solution algorithms. This can be specified as an argument to the constructor of the solver. For example, the following two constructor invocations are identical
\begin{lstlisting}
s = SolverJMT(model)
opt = SolverJMT.defaultOptions; s = SolverJMT(model, opt)
\end{lstlisting}
Modifiers to the default options can either be specified directly in the \texttt{options} data structure, or alternatively be specified as argument pairs to the constructor, i.e., the following two invocations are equivalent
\begin{lstlisting}
s = SolverJMT(model,'method','exact')
opt = SolverJMT.defaultOptions; opt.method='exact'; s = SolverJMT(model, opt)
\end{lstlisting}

Available solver options are as follows:
\begin{itemize}
\item \texttt{cutoff} (\texttt{integer} $\geq 1$) requires to ignore states where stations have more than the specified number of jobs. This is a mandatory option to analyze open classes using the CTMC solver.
\item \texttt{force} (\texttt{logical}) requires the solver to proceed with analyzing the model. This bypasses checks and therefore can result in the solver either failing or requiring an excessive amount of resources from the system.

\item \texttt{iter\_max} (\texttt{integer} $\geq 1$) controls the maximum number of iterations that a solver can use, where applicable. If  \texttt{iter\_max= }$n$, this option forces the \texttt{FLUID} solver to compute the ODEs over the timespan $t\in[0,10n/\mu^{\min}]$, where $\mu^{\min}$ is the slowest service rate in the model. For the \texttt{MVA} solver this option instead regulates the number of successive substitutions allowed in the fixed-point iteration.

\item \texttt{iter\_tol} (\texttt{double}) controls the numerical tolerance used to convergence of iterative methods. In the \texttt{FLUID} solver this option regulates both the absolute and relative tolerance of the ODE solver.

\item \texttt{init\_sol} (\texttt{solver dependent}) re-initializes iterative solvers with the given configuration of the solution variables. In the case of \texttt{MVA}, this is a matrix where element $(i,j)$ is the mean queue-length at station $i$ in class $j$. In the case of \texttt{FLUID}, this is a model-dependent vector with the values of all the variables used within the ODE system that underpins the fluid approximation.

\item \texttt{keep} (\texttt{logical}) determines if the model-to-model transformations store on file their intermediate outputs. In particular, if \texttt{verbose}$\geq 1$ then the location of the \texttt{.jsimg} models sent to JMT will be printed on screen.

\item \texttt{method} (\texttt{string}) configures the internal algorithm used to solve the model.

\item \texttt{samples} (\texttt{integer} $\geq 1$) controls the number of samples collected {\em for each} performance index by simulation-based solvers. \texttt{JMT} requires a minimum number of samples of $5\cdot 10^3$ samples.

\item \texttt{seed} (\texttt{integer} $\geq 1$) controls the seed used by the pseudo-random number generators. For example, simulation-based solvers will give identical results across invocations only if called with the same \texttt{seed}.

\item \texttt{stiff} (\texttt{logical}) requires the solver to use a stiff ODE solver.

\item \texttt{timestamp} (\texttt{real interval}) requires the transient solver to produce a solution in the specified temporal range. If the value is set to $[\texttt{Inf},\texttt{Inf}]$ the solver will only return a steady-state solution. In the case of the \texttt{FLUID} solver and in simulation, $[\texttt{Inf},\texttt{Inf}]$ has the same computational cost of $[\texttt{0},\texttt{Inf}]$ therefore the latter is used as default.

\item \texttt{verbose} controls the verbosity level of the solver. Supported levels are 0 for silent, 1 for standard verbosity, 2 for debugging.
\end{itemize}

%{\scriptsize
%\hspace{-2cm}
%\begin{table}[h!]
%\caption{Default values of the \textsc{Line} solver options and their default assignments}
%\renewcommand{\arraystretch}{1.2}
%\centering
%\begin{tabular}{|l|c|c|c|c|c|c|c|}
%\cline{2-8}
%\multicolumn{1}{c|}{}&\multicolumn{7}{c|}{\textbf{Solver default}}\\
%\cline{1-8}
%\textbf{Option}&\texttt{MVA}	&\texttt{CTMC}&\texttt{FLUID}	 	&\texttt{JMT} 	&\texttt{MAM} &\texttt{NC} 	&\texttt{SSA}\\
%\hline
%\texttt{cutoff} &  & (no default) & &  &  &   &   \\
%\hline
%\texttt{force} & false & false & false & false & false & false & false   \\
%\hline
%\texttt{keep} &  &   &  & false & & &  \\
%\hline
%\texttt{init\_sol} & $[~]$ & & $[~]$&   &  &&      \\
%\hline
%\texttt{iter\_max} & $10^3$ & & $10$&   &  &   &    \\
%\hline
%\texttt{iter\_tol} & $10^{-6}$ &   & $10^{-4}$&   &$10^{-4}$ & &  \\
%\hline
%\texttt{method} & \texttt{'default'} & \texttt{'default'} & \texttt{'default'}  & \texttt{'default'} &\texttt{'default'} & \texttt{'default'} & \texttt{'default'}   \\
%\hline
%\texttt{samples} &  & &   &     $10^4$ & &   &  $10^4$ \\
%\hline
%\texttt{seed} & rand & rand  & rand & rand &rand &rand &rand   \\
%\hline
%\texttt{stiff} &  &   & true &  & &   & \\
%\hline
%\texttt{timespan} &  & \texttt{[Inf,Inf]} & \texttt{[0,Inf]} & \texttt{[0,Inf]} & & \texttt{[Inf,Inf]} & \texttt{[0,Inf]}   \\
%\hline
%\texttt{verbose} & 0  & 0  & 0& 0& 0& 0& 0 \\
%\hline
%\end{tabular}
%\label{TAB_solver_options}
%\end{table}
%}

\section{Solver maintenance}
The following best practices can be helpful in maintaining the \textsc{Line} installation:
\begin{itemize}
\item To install a new release of JMT, it is necessary to delete the \texttt{JMT.jar} file under thr \texttt{'SolverJMT'} folder. This forces \textsc{Line} to download the latest version of the JMT executable.
\item Periodically running the \texttt{jmtCleanTempDir} script can help removing temporary by-products of the JMT solver. This is strongly encouraged under repeated enabling of the \texttt{'keep'} option, as this stores on disk the temporary models sent to JMT.
\end{itemize}

%\section{Importing from LQNS}
%\section{Importing from PMIF}
%\section{Exporting to \textsc{Line} script}
