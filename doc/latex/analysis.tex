\chapter{Analysis methods}
\label{analysis-methods}

\section{Steady-state analysis}
\subsection{Station average performance}
\textsc{Line} decouples network specification from its solution, allowing to evaluate the same model with multiple solvers.
Model analysis is carried out in \textsc{Line} according to the following general steps:
\begin{description}
\item[Step 1: Definition of the model.] This proceeds as explained in the previous chapters.
\item[Step 2: Instantiation of the solver(s).] A solver is an instance of the \texttt{Solver} class. \textsc{Line} offers multiple solvers, which can be configured through a set of common and individual solver options. For example,
\begin{lstlisting}
solver = SolverJMT(model);
\end{lstlisting}
returns a handle to a simulation-based solver based on JMT, configured with default options.
\item[Step 3: Solution.] Finally, this step solves the network and retrieves the concrete values for the performance indexes of interest. This may be done as follows, e.g.,
\begin{lstlisting}
% QN(i,r): mean queue-length of class r at station i
QN = solver.getAvgQLen()
% UN(i,r): utilization of class r at station i
UN = solver.getAvgUtil()
% RN(i,r): mean response time of class r at station i (summed on visits)
RN = solver.getAvgRespT()
% TN(i,r): mean throughput of class r at station i
TN = solver.getAvgTput()
\end{lstlisting}
Alternatively, all the above metrics may be obtained in a single method call as
\begin{lstlisting}
[QN,UN,RN,TN] = solver.getAvg()
\end{lstlisting}
\end{description}
In the methods above, \textsc{Line} assigns station and class indexes (e.g., $i$, $r$) in order of creation in order of creation of the corresponding station and class objects. However, large models may be easier to debug by checking results using class and station names, as opposed to indexes. This can be done either by requesting \textsc{Line} to build a table with the result
\begin{lstlisting}
AvgTable = solver.getAvgTable()
\end{lstlisting}
which however tends to be a rather slow data structure to use in case of repeated invocations of the solver, or by indexing the matrices returned by \texttt{getAvg} using the model objects. That is, if the first instantiated node is \texttt{queue} with name \texttt{'MyQueue'} and the second instantiated class is \texttt{cclass} with name \texttt{'MyClass'}, then the following commands are equivalent
\begin{lstlisting}
QN(1,2)
QN(queue,cclass)
QN(model.getStationIndex('MyQueue'),model.getClassIndex('MyClass'))
\end{lstlisting}
Similar methods are defined to obtain aggregate performance metrics at chain level at each station, namely \texttt{getAvgQLenChain} for queue-lengths, \texttt{getAvgUtilChain} for utilizations, \texttt{getAvgRespTChain} for response times, \texttt{getAvgTputChain} for throughputs, and the \texttt{getAvgChain} method to obtain all the previous metrics.

\subsection{Station response time distribution}
\texttt{SolverFluid} supports the computation of response time distributions for individual classes through the \texttt{getCdfRespT} function. The function returns the response time distribution for every station and class. For example, the following code plots the cumulative distribution function at steady-state for class 1 jobs when they visit station 2:
\begin{lstlisting}
solver = SolverFluid(model);
FC = solver.getCdfRespT();
plot(FC{2,1}(:,2),FC{2,1}(:,1)); xlabel('t'); ylabel('Pr(RespT<t)');
\end{lstlisting}

\subsection{System average performance}
\textsc{Line} also allows users to analyze models for end-to-end performance indexes such a system throughput or system response time. However, in models with class switching the notion of system-wide metrics can be ambiguous. For example, consider a job that enters the network in one class and departs the network in another class. In this situation one may attribute system response time to either the arriving class or the departing one, or attempt to partition it proportionally to the time spent by the job within each class. In general, the right semantics depends on the aim of the study.

LINE tackles this issue by supporting only the computation of system performance indexes {\em by chain}, instead than by class. In this way, since a job switching from a class to another remains by definition in the same chain, there is no ambiguity in attributing the system metrics to the chain.  The solver functions \texttt{getAvgSys} and \texttt{getAvgSysTable} return system response time and system throughput per chain as observed: (i) upon arrival to the sink, for open classes; (ii) upon arrival to the reference station, for closed classes.

In some cases, it is possible that a chain visits multiple times the reference station before the job completes. This also affects the definition of the system averages, since in some applications one may want to avoid counting each visit as a completion of the visit to the system. In such cases, \textsc{Line} allows to specify which classes of the chain can complete at the reference station. For example, in the code below we require that a job visits reference station 1 twice, in classes 1 and 2, but completes at the reference station only when arriving in class 2. Therefore, the system response time will be counted between successive passages in class 2.
\begin{lstlisting}
class1 = ClosedClass(model, 'ClosedClass1', 1, queue, 0);
class2 = ClosedClass(model, 'ClosedClass2', 0, queue, 0);

class1.completes = false;

P = cell(2); % 2-classes model
P{1,1} = [0,1; 0,0]; % routing within class 1 (no switching)
P{1,2} = [0,0; 1,0]; % routing from class 1 into class 2
P{2,1} = [0,0; 1,0]; % routing within class 2 (no switching)
P{2,2} = [0,1; 0,0]; % routing from class 2 into class 2

model.link(P);
\end{lstlisting}
Note that \textsc{Line} does not allow a chain to complete at heterogeneous stations, therefore the \texttt{completes} property of a class always refers to the reference station for the chain.


\section{Specifying states}
In some analyses it is important to specify the state of the network, for example to assign the initial position of the jobs in a transient analysis. We thus discuss the native support in \textsc{Line} for state modeling.
\subsection{Station states}
We begin by explaining how to specify a state $s_0$. State modelling is supported only for stations with scheduling policies that depend on the number of jobs running or waiting at the node. For example, it is not supported for shortest job first (\texttt{SchedStrategy.SJF}) scheduling, in which state depends on the service time samples for the jobs.

Suppose that the network has $R$ classes and that service distributions are phase-type, i.e., that they inherit from \texttt{PhaseType}. Let $K_{r}$ be the number of phases for the service distribution in class $r$ at a given station. Then, we define three types of state variables:
\begin{itemize}
\item $c_j$: class of the job waiting in position $j\leq b$ of the buffer, out of the $b$ currently occupied positions. If $b=0$, then the state vector is indicated with a single empty element $c_1=0$.
\item $n_r$: total number of jobs of class $r$ in the station
\item $b_r$: total number of jobs of class $r$ in the station's buffer
\item $s_{rk}$: total number of jobs of class $r$ running in phase $k$ in the server
\end{itemize}
Here, by phase we mean the number of states of a distribution of class \texttt{PhaseType}. If the distribution is not Markovian, then there is a  single phase.
With these definitions, the table below illustrates how to specify in \textsc{Line} a valid state for a station depending on its scheduling strategy. All state variables are non-negative integers. The \texttt{SchedStrategy.EXT} policy is used for the \texttt{Source} node, which may be seen as a special station with an infinite pool of jobs sitting in the buffer and a dedicated server for each class $r=1,...,R$.
\begin{table}[thbp]
\renewcommand{\arraystretch}{1.2}
\centering
\caption{State descriptors for Markovian scheduling policies}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Sched. strategy} & \textbf{Station state vector} & \textbf{State condition}\\
\hline
\texttt{EXT} & $[\texttt{Inf},s_{11},...,s_{1K_1},...,s_{R1},...,s_{RK_R}]$ & $\sum_k s_{rk}=1$, $\forall r$\\
\hline
\texttt{FCFS}, \texttt{HOL}, \texttt{LCFS} &   $[c_{b},...,c_{1},s_{11},...,s_{1K_1},...,s_{R1},...,s_{RK_R}]$& $\sum_{r}\sum_{k} s_{rk}=1$\\
\hline
\texttt{SEPT}, \texttt{RAND} &   $[b_{1},...,b_{R},s_{11},...,s_{1K_1},...,s_{R1},...,s_{RK_R}]$& $\sum_{r}\sum_{k} s_{rk}=1$\\
%\hline
%LEPT 	&NP	&			&$\checkmark$& 	&$\checkmark$	&&$\checkmark$&	\\
%\hline
%LJF & \\
\hline
\texttt{PS}, \texttt{DPS}, \texttt{GPS}, \texttt{INF}	&   $[s_{11},...,s_{1K_1},...,s_{R1},...,s_{RK_R}]$& None\\
%\hline
%SJF & Not supported.\\
\hline
\end{tabular}
\label{TAB_state_policies}
\end{table}

States can be manually specified or enumerated automatically. \textsc{Line} library functions for handling and generating states are as follows:
\begin{itemize}
\item \texttt{State.fromMarginal}: enumerates all states that have the same marginal state $[n_{1},n_{2},...,n_{R}]$.
\item \texttt{State.fromMarginalAndRunning}: restricts the output of \texttt{State.fromMarginal} to states with given number of running jobs, irrespectively of the service phase in which they currently run.
\item \texttt{State.fromMarginalAndStarted}: restricts the output of \texttt{State.fromMarginal} to states with given number of running jobs, all assumed to be in service phase $k=1$.
\item \texttt{State.fromMarginalBounds}: similar to \texttt{State.fromMarginal}, but produces valid states between given minimum and maximum of resident jobs.
\item \texttt{State.toMarginal}: extracts statistics from a state, such as the total number of jobs in a given class that are running at the station in a certain phase.
\end{itemize}
Note that if a function call returns an empty state (\texttt{[]}), this should be interpreted as an indication that no valid state exists that meets the required criteria. Often, this is because the state supplied in input is invalid.

\subsubsection{Example} We consider the example network in \texttt{example\_closedModel\_4.m}. We look at the state of station 3, which is a multi-server FCFS station. There are 4 classes all having exponential service times except class 2 that has Erlang-2 service times. We are interested to states with 2 running jobs in class 1 and 1 in class 2, and with 2 jobs, respectively of classes 3 and 4, waiting in the buffer. We can automatically generate this state space, which we store in the \texttt{space} variable, as:
\begin{lstlisting}
>> example_closedModel_4;
>> space = State.fromMarginalAndRunning(model,3,[2,1,1,1],[2,1,0,0])
space =
     4     3     2     1     0     0     0
     4     3     2     0     1     0     0
     3     4     2     1     0     0     0
     3     4     2     0     1     0     0
\end{lstlisting}
Here, each row of \texttt{space} corresponds to a valid state. The argument \texttt{[2,1,1,1]} gives the number of jobs in the node for the 4 classes, while \texttt{[2,1,0,0]} gives the number of running jobs in each class. This station has four valid states, differing on whether the class-2 job runs in the first or in the second phase of the Erlang-2 and on the relative position of the jobs of class 3 and 4 in the waiting buffer.

To obtain states where the jobs have just started running, we can instead use
\begin{lstlisting}
>> space = State.fromMarginalAndStarted(model,3,[2,1,1,1],[2,1,0,0])
space =
     4     3     2     1     0     0     0
     3     4     2     1     0     0     0
\end{lstlisting}
If we instead remove the specification of the running jobs, we can use \texttt{State.fromMarginal} to generate all possible combinations of states depending on the class and phase of the running jobs. In the example, this returns a space of 20 possible states.
\begin{lstlisting}
>> space = State.fromMarginal(model,3,[2,1,1,1],[2,1,0,0])
space =
     4     3     2     1     0     0     0
     4     3     2     0     1     0     0
     4     2     2     0     0     1     0
     4     1     1     1     0     1     0
     4     1     1     0     1     1     0
     3     4     2     1     0     0     0
     3     4     2     0     1     0     0
     3     2     2     0     0     0     1
     3     1     1     1     0     0     1
     3     1     1     0     1     0     1
     2     4     2     0     0     1     0
     2     3     2     0     0     0     1
     2     1     1     0     0     1     1
     1     4     1     1     0     1     0
     1     4     1     0     1     1     0
     1     3     1     1     0     0     1
     1     3     1     0     1     0     1
     1     2     1     0     0     1     1
     1     1     0     1     0     1     1
     1     1     0     0     1     1     1
\end{lstlisting}
\subsubsection{Assigning a state to a station}
Given a single or multiple states, it is possible to assign the initial state to a station using the \texttt{setState} function on that station's object. To cope with multiple states, \textsc{Line} offers the possibility to specify a prior probability on the initial states, so that if multiple states have a non-zero prior, then the solver will need to analyze the network from all those states and weight the results according to the prior probabilities. The default prior value assigned probability 1.0 to the {\em first} specified state. The functions \texttt{setStatePrior} and \texttt{getStatePrior} of the \texttt{Station} class can be used to check and change the prior probabilities for the supplied initial states.

\subsection{Network states}
A collection of states that are valid for each station is not necessarily valid for the network as a whole. For example, if the sum of jobs of a closed class exceeds the population of the class, then the network state would be invalid. To identify these situations, \textsc{Line} requires to specify the initial state of a network using functions supplied by the \texttt{Network} class. These functions are \texttt{initFromMarginal}, \texttt{initFromMarginalAndRunning}, and \texttt{initFromMarginalAndStarted}. They require a matrix with elements \texttt{n}$(i,r)$ specifying the total number of resident class-$r$ jobs at node $i$ and the latter two require a matrix \texttt{s}$(i,r)$ with the number of running (or started) class-$r$ jobs at node $i$. The user can also manually verify if the supplied network state is going to be valid using \texttt{State.IsValid}.

It is also possible to request \textsc{Line} to automatically identify a valid initial state, which is done using the \texttt{initDefault} function available in the \texttt{Network} class. This is going to select a state where:
\begin{itemize}
\item no jobs in open classes are present in the network;
\item jobs in closed classes all start at their reference stations;
\item the server of reference stations are occupied in order of class id, i.e., jobs in the firstly created class are assigned to the server in phase 1, then spare servers are allocated to the second class in phase 1, and so forth;
\item if the scheduling strategy requires it, jobs are ordered in the buffer by class, with the firstly created class at the head and the lastly created class at the tail of the buffer.
\end{itemize}

Lastly, the \texttt{initFromAvgQLen} is a wrapper for \texttt{initFromMarginal} to initialize the system as close as possible to the average steady-state distribution of the network. Since averages are typically not integer-valued, this function rounds the average values to the nearest integer and adjusts the result to ensure feasibility of the initialization.

\subsection{Initialization of transient classes}
Because of class-switching, it is possible that a class $r$ with a non-empty population at time $t=0$ becomes empty at some position time $t'>t$ without ever being visited again by any job. \texttt{LINE} allows one to place jobs in transient classes and therefore it will not trigger an error in the presence of this situation. If a user wishes to prohibit the use of a class at a station, it is sufficient to specify that the corresponding service process uses the \texttt{Disabled} distribution.

Certain solvers may incur problems in identifying that a class is transient and in setting to zero its steady-state measures. For example, the \texttt{JMT} solver uses an heuristic whereby a class is considered transient if it has fewer events than jobs initially placed in the corresponding chain the class belongs to. For such classes, \texttt{JMT} will set the values of steady-state performance indexes to zero.


\section{Transient analysis}
So far, we have seen how to compute steady-state average performance indexes, which are given by
\[
E[n]=\lim\limits_{t\to +\infty }E[n(t)]
\]
where $n(t)$ is an arbitrary performance index, e.g., the queue-length of a given class at time $t$.

We now consider instead the computation of the quantity $E[n(t)|s_0]$, which is the {\em transient average} of the performance index, conditional on a given initial system state $s_0$. Compared to $n(t)$, this quantity averages the system state at time $t$ across all possible evolutions of the system from state $s_0$ during the $t$ time units, weighted by their probability. In other words, we observe all possible stochastic evolutions of the system from state $s_0$ for $t$ time units, recording the final values of $n(t)$ in each trajectory, and finally average the recorded values at time $t$ to obtain $E[n(t)|s_0]$.

\subsection{Computing transient averages}
At present, \textsc{Line} supports only transient computation of queue-lengths, throughputs and utilizations using the \texttt{CTMC} and \texttt{FLUID} solvers. Transient response times are not currently supported, as they do not always obey Little's law.

The computation of transient metrics proceeds similarly to the steady-state case. We first obtain the handles for transient averages:
\begin{lstlisting}
[Qt,Ut,Tt] = model.getTransientHandlers();
\end{lstlisting}
After solving the model, we will be able to retrieve {\em both} steady-state and transient averages as follows
\begin{lstlisting}
[QNt,UNt,TNt] = solver{s}.getTransientAvg(Qt,Ut,Tt)
plot(QNt{1,1}(:,2), QNt{1,1}(:,1))
\end{lstlisting}
The transient average queue-length at node $i$ for class $r$ is stored within \texttt{QNt\{i,r\}}.%, which is a MATLAB \texttt{timeseries} object. This object class can be plotted directly. Data and time values in the time series can also be accessed using the \texttt{Data} and \texttt{Time} fields within the object.

Note that the above code does not show how to specify a maximum time $t$ for the output time series. This can be done using the \texttt{timespan} field of the options, as described later in the solvers chapter. %The solver will automatically solve the network until a large enough $t$ is reached so that the network is approximately in steady-state. This is done to ensure that average steady-state performance metrics can also be determined as an output of the transient solution.

\subsection{First passage times into stations}
When the model is in a transient, the average state seen upon arrival to a station changes over time. That is, in a transient, successive visits by a job may experience different response time distributions. The function \texttt{getTransientCdfRespT}, implemented by \texttt{SolverJMT} offers the possibility to obtain this distribution given the initial state specified for the model. As time passes, this distribution will converge to the steady-state one computed by solvers equipped with the function \texttt{getCdfRespT}.

However, in some cases one prefers to replace the notion of response time distribution in transient by the one of \emph{first passage time}, i.e., the distribution of the time to complete the {\em first visit} to the station under consideration. The function \texttt{getTransientCdfFirstPassT} provides this distribution, assuming as initial state the one specified for the model, e.g., using \texttt{setState} or \texttt{initDefault}. This function is available only in \texttt{SolverFluid} and has a similar syntax as \texttt{getCdfRespT}.

\section{Sensitivity analysis and numerical optimization}
\label{sensitivity-analysis-and-numerical-optimization}
Frequently, performance and reliability analysis requires to change one or more model parameters to see the sensitivity of the results or to optimize some goal function. In order to do this efficiently, we discuss the internal representation of the \texttt{Network} objects used within the \textsc{Line} solvers. By applying changes directly to this internal representation it is possible to considerably speed-up the sequential evaluation of several models.

\subsection{Internal representation of the model structure}
For efficiency reasons, once a user requests to solve a \texttt{Network}, \textsc{Line} calls internally generates a static representation of the network structure using the \texttt{refreshStruct} function. This function returns a representation object that is then passed on to the chosen solver to parameterize the analysis.

The representation used within \textsc{Line} is the \texttt{NetworkStruct} class, which describes an extended multiclass queueing network with class-switching and Coxian service times. The representation can be obtained as follows
\begin{lstlisting}
qn = model.getStruct()
\end{lstlisting}
The table below presents the properties of the \texttt{NetworkStruct} class.

\begin{table}[thbp]
{\footnotesize
\renewcommand{\arraystretch}{1.2}
\centering
\caption{\texttt{NetworkStruct} properties} %{Legend: $i,j=$ stations; $r,s=$ classes; $c=$ chain; $k=$ phase; $t=$ state}}
\begin{tabular}{|l|l|p{9.5cm}|}
\hline
\textbf{Field} & \textbf{Type} & \textbf{Description} \\
\hline
\texttt{cap}$(i)$ & \texttt{integer} & Total capacity at station $i$ \\\hline
\texttt{chains}$(c,r)$ & \texttt{logical} &  \texttt{true} if class $r$ is in chain $c$, or \texttt{false} otherwise \\\hline
\texttt{classcap}$(i,r)$ & \texttt{integer} & Maximum buffer capacity available to class $r$ at station $i$ \\\hline
\texttt{classname}$\{r\}$ & \texttt{string} & Name of class $r$\\\hline
\texttt{classprio}$(r)$ & \texttt{integer} & Priority of class $r$ (0 = highest priority)\\\hline
\texttt{csmask}$(r,s)$ & \texttt{logical} & true if class $r$ can switch into class $s$ at some node\\\hline
{\texttt{isstation}}$(i)$ & {\texttt{logical}} & true if node $i$ is a station\\\hline
{\texttt{isstateful}}$(i)$ & {\texttt{logical}} & true if node $i$ is a stateful node\\\hline
\texttt{mu}$\{i,r\}(k)$ & \texttt{double} & Coxian service or arrival rate in phase $k$ for class $r$ at station $i$, with \texttt{mu}$\{i,r\}=$\texttt{NaN} if \texttt{Disabled} and \texttt{mu}$\{i,r\}=10^7$ if \texttt{Immediate}.\\\hline
\texttt{nchains} & \texttt{integer} & Number of chains in the network\\\hline
%\texttt{nchainjobs}$(c)$ & \texttt{integer} & Number of jobs in chain $c$\\\hline
\texttt{nclasses} & \texttt{integer} & Number of classes in the network\\\hline
\texttt{nclosedjobs} & \texttt{integer} & Total number of jobs in closed classes\\\hline
\texttt{njobs}$(r)$ & \texttt{integer} & Number of jobs in class $r$ (\texttt{Inf} for open classes)\\\hline
\texttt{nnodes} & \texttt{integer} & Number of nodes in the network\\\hline
\texttt{nservers}$(i)$ & \texttt{integer} & Number of servers at station $i$\\\hline
\texttt{nstations} & \texttt{integer} & Number of stations in the network\\\hline
\texttt{nstateful} & \texttt{integer} & Number of stateful nodes in the network\\\hline
\texttt{nodenames}$\{i\}$ & \texttt{string} & Name of node $i$\\\hline
\texttt{nodetypes}$\{i\}$ & \texttt{string} & Type of node $i$ (e.g., \texttt{NodeType.Sink})\\\hline
\texttt{nvars} & \texttt{integer} & Number of local state variables at stateful nodes\\\hline
\texttt{phases}$(i,r)$ & \texttt{integer} & Number of phases for service process of class $r$ at station $i$\\\hline
\texttt{phi}$\{i,r\}(k)$ & \texttt{double} & Coxian completion probability in phase $k$ for class $r$ at station $i$\\\hline
\texttt{rates}$(i,r)$ & \texttt{double} & Service rate of class $r$ at station $i$ (or  arrival rate if $i$ is a \texttt{Source})\\\hline
\texttt{refstat}$(r)$ & \texttt{integer} & Index of reference station for class $r$ \\\hline
\texttt{rt}$(idx_{ir},idx_{js})$  & \texttt{double} & Probability of routing from stateful node $i$ to $j$, switching class from $r$ to $s$ where, e.g., $idx_{ir}=(i-1)*\texttt{nclasses}+r$.\\\hline
\texttt{rtnodes}$(idx_{ir},idx_{js})$  & \texttt{double} & Same as \texttt{rt}, but $i$ and $j$ are nodes, not necessarily stateful ones.\\\hline
\texttt{rtfun}$(\texttt{st1},\texttt{st2})$  & \texttt{matrix} & State-dependent routing table given initial (\texttt{st1}) and final (\texttt{st2}) state cell arrays. Table entries defined as in \texttt{rt}.\\\hline
\texttt{schedparam}$(i,r)$ & \texttt{double} &  Parameter for class $r$ strategy at station $i$\\\hline
\texttt{sched}$\{i\}$& \texttt{cell} & Scheduling strategy at station $i$ (e.g., \texttt{SchedStrategy.PS})\\\hline
\texttt{schedid}$(i)$ & \texttt{integer} & Scheduling strategy id at station $i$ (e.g., \texttt{SchedStrategy.ID\_PS})\\\hline
\texttt{sync}$\{s\}$ & \texttt{struct} & Data structure specifying a synchronization $s$ among nodes\\\hline
\texttt{scv}$(i,r)$ & \texttt{double} & Squared coefficient of variation of class $r$ service times at station $i$ (or inter-arrival times if station $i$ is a \texttt{Source})\\\hline
\texttt{space}$\{t\}$  & \texttt{integer} & The $t$-th state in the state space (or a portion thereof). This field may be initially empty and updated by the solver during execution.\\\hline
\texttt{state}$\{i\}$ & \texttt{integer} & Current state of stateful node $i$. This field may be initially empty and updated by the solver during execution.\\\hline
\texttt{visits}$\{c\}(i,r)$  & \texttt{double} & Number of visits that a job in chain $c$ pays to node $i$ in class $r$\\\hline
\texttt{varsparam}$\{i\}$  & \texttt{double} & Parameters for local variable instantiation at stateful node $i$\\
\hline
\end{tabular}
}
\label{TAB_QN}
\end{table}
\subsection{Fast parameter update}
Successive invocations of \texttt{getStruct()} will return a cached copy of the \texttt{NetworkStruct} representation, unless the user has called \texttt{model.refreshStruct()} or \texttt{model.reset()} in-between the invocations. The \texttt{refreshStruct} function regenerates the internal representation, while \texttt{reset} destroys it, together with all other representations and cached results stored in the \texttt{Network} object. In the case of \texttt{reset}, the internal data structure will be regenerated at the next \texttt{refreshStruct()} or \texttt{getStruct()} call.

The performance cost of updating the representation can be significant, as some of the structure array field require a dedicated algorithm to compute. For example, finding the chains in the model requires an analysis of the weakly connected components of the network routing matrix. For this reason, the \texttt{Network} class provides several functions to selectively refresh only part of the \texttt{NetworkStruct} representation, once the modification has been applied to the objects (e.g., stations, classes, ...) used to define the network. These functions are as follows:
\begin{itemize}
\item \texttt{refreshArrival}: this function should be called after updating the inter-arrival distribution at a \texttt{Source}. %    The function is identical to \texttt{refreshService}.
\item \texttt{refreshCapacity}: this function should be called after changing buffer capacities, as it updates the \texttt{capacity} and \texttt{classcapacity} fields.
\item \texttt{refreshChains}: this function should be used after changing the routing topology, as it refreshes the \texttt{rt}, \texttt{chains}, \texttt{nchains}, \texttt{nchainjobs}, and \texttt{visits} fields.
\item \texttt{refreshPriorities}: this function updates class priorities in the \texttt{classprio} field.
%\item \texttt{refreshRates}: this function should be called after changing a service time distribution at a station as it updates the \texttt{rates} and \texttt{scv} fields.
%\item \texttt{refreshRoutingMatrix}: updates the \texttt{rt} field.
\item \texttt{refreshScheduling}: updates the \texttt{sched}, \texttt{schedid}, and \texttt{schedparam} fields.
\item \texttt{refreshService}: updates the \texttt{mu}, \texttt{phi}, \texttt{phases}, \texttt{rates} and \texttt{scv} fields.
\end{itemize}
For example, suppose we wish to update the service time distribution for class-1 at node 1 to be exponential with unit rate. This can be done efficiently as follows:
\begin{lstlisting}
queue.setService(class1, Exp(1.0));
model.refreshService;
\end{lstlisting}

\subsection{Refreshing a network topology with non-probabilistic routing}
The \texttt{resetNetwork} function should be used before changing a network topology with non-probabilistic routing. It will destroy by default all class switching nodes. This can be avoided if the function is called as, e.g., \texttt{model.resetNetwork(false)}. The default behavior is though shown in the next example
\begin{lstlisting}
>> model = Network('model');
node{1} = ClassSwitch(model,'CSNode',[0,1;0,1]);
node{2} = Queue(model, 'Queue1', SchedStrategy.FCFS);
>> model.getNodes
ans =
  2x1 cell array
    {1x1 ClassSwitch}
    {1x1 Queue}
>> model.resetNetwork
ans =
  1x1 cell array
    {1x1 Queue}
\end{lstlisting}
As shown, \texttt{resetNetwork} updates the station indexes and the revised list of nodes that compose the topology is obtained as a return parameter. To avoid stations to change index, one may simply create  \texttt{ClassSwitch} nodes as last before solving the model. This node list can be employed as usual to reinstantiate new stations or \texttt{ClassSwitch} nodes. The \texttt{addLink}, \texttt{setRouting}, and possibly the \texttt{setProbRouting} functions will also need to be re-applied as described in the previous sections.

\subsection{Saving a network object before a change}
The \texttt{Network} object, and its inner objects that describe the network elements, are always passed by reference. The \texttt{copy} function should be used to clone \textsc{Line} objects, for example before modifying a parameter for a sensitivity analysis. This function recursively clones all objects in the model, therefore creating an independent copy of the network. For example, consider the following code
\begin{lstlisting}
modelByRef = model; modelByRef.setName('myModel1');
modelByCopy = model.copy; modelByCopy.setName('myModel2');
\end{lstlisting}
Using the \texttt{getName} function it is then possible to verify that \texttt{model} has now name \texttt{'myModel1'}, since the first assignment was by reference. Conversely, \texttt{modelByCopy.setName} did not affect the original \texttt{model} since this is a clone of the original network.

